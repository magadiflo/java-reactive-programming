# Sección 2: Configuración del proyecto

El contenido de esta documentación corresponde a los temas iniciales de la `Sección 2: Mono`. Sin embargo, en los
primeros capítulos el tutor se enfoca en crear y configurar el proyecto base que se utilizará a lo largo del curso.

Por ese motivo, he considerado conveniente separar este contenido introductorio en esta sección, de modo que en el
archivo `02.mono.md` podamos entrar directamente en el estudio del publisher `Mono`, que también forma parte de
la `Sección 2: Mono`.

---

## Creación del proyecto

A continuación se muestran las dependencias que usaremos para trabajar en este proyecto junto con las configuraciones de
`logback.xml`.

````xml

<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>dev.magadiflo</groupId>
    <artifactId>java-reactive-programming</artifactId>
    <version>1.0-SNAPSHOT</version>

    <properties>
        <maven.compiler.source>21</maven.compiler.source>
        <maven.compiler.target>21</maven.compiler.target>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>

        <reactor.version>2023.0.8</reactor.version>
        <logback.version>1.5.8</logback.version>
        <faker.version>1.0.2</faker.version>
        <junit.version>5.10.1</junit.version>
    </properties>
    <dependencies>
        <dependency>
            <groupId>io.projectreactor</groupId>
            <artifactId>reactor-core</artifactId>
        </dependency>
        <dependency>
            <groupId>io.projectreactor.netty</groupId>
            <artifactId>reactor-netty-core</artifactId>
        </dependency>
        <dependency>
            <groupId>io.projectreactor.netty</groupId>
            <artifactId>reactor-netty-http</artifactId>
        </dependency>
        <dependency>
            <groupId>ch.qos.logback</groupId>
            <artifactId>logback-classic</artifactId>
            <version>${logback.version}</version>
        </dependency>
        <dependency>
            <groupId>org.slf4j</groupId>
            <artifactId>slf4j-api</artifactId>
            <version>2.0.16</version>
        </dependency>
        <dependency>
            <groupId>com.github.javafaker</groupId>
            <artifactId>javafaker</artifactId>
            <version>${faker.version}</version>
        </dependency>
        <!-- test dependencies -->
        <dependency>
            <groupId>org.junit.jupiter</groupId>
            <artifactId>junit-jupiter-engine</artifactId>
            <version>${junit.version}</version>
            <scope>test</scope>
        </dependency>
        <!-- step-verifier -->
        <dependency>
            <groupId>io.projectreactor</groupId>
            <artifactId>reactor-test</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>
    <dependencyManagement>
        <dependencies>
            <dependency>
                <groupId>io.projectreactor</groupId>
                <artifactId>reactor-bom</artifactId>
                <version>${reactor.version}</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
        </dependencies>
    </dependencyManagement>
    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <configuration>
                    <source>21</source>
                    <target>21</target>
                </configuration>
            </plugin>
        </plugins>
    </build>
</project>
````

En el directorio `src/main/resources` agregamos el archivo `logback.xml`.

````xml
<!-- http://dev.cs.ovgu.de/java/logback/manual/layouts.html -->
<configuration>
    <appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
        <encoder>
            <pattern>%d{HH:mm:ss.SSS} %-5level [%15.15t] %cyan(%-30.30logger{30}) : %m%n</pattern>
        </encoder>
    </appender>
    <logger name="io.netty.resolver.dns.DnsServerAddressStreamProviders" level="OFF"/>
    <root level="INFO">
        <appender-ref ref="STDOUT"/>
    </root>
</configuration>
````

## Implementando nuestro propio Publisher/Subscriber - Parte 1

Los flujos reactivos proporcionan un conjunto de interfaces:

- `Publisher`
- `Subscription`
- `Subscriber`

En este apartado y en el siguiente realizaremos nuestra propia implementación, pero ojo, esto no lo haremos en la vida
real. Es solo para obtener la comprensión básica. En la vida real utilizaremos una implementación proporcionada por
el proyecto `Reactor`.

Ideemos algún caso de uso para nuestra aplicación:

- Publisher, proporcionará el correo electrónico del cliente.
- Suscriber, está interesado en el correo electrónico del cliente para poder enviarle mensajes promocionales.

A continuación vamos a crear las clases `PublisherImpl`, `SubscriberImpl` y `SubscriptionImpl`. Recordar que estas
clases solo son clases que creamos para ver cómo es que funciona la `programación reactiva` con la especificación de
`Reactive Stream`, es decir, en la vida real no tenemos qué hacerlas.

````java
public class SubscriberImpl implements Subscriber<String> {

    private static final Logger log = LoggerFactory.getLogger(SubscriberImpl.class);
    private Subscription subscription;

    @Override
    public void onSubscribe(Subscription subscription) {
        this.subscription = subscription;
    }

    @Override
    public void onNext(String email) {
        log.info("recibido: {}", email);
    }

    @Override
    public void onError(Throwable throwable) {
        log.error("error", throwable);
    }

    @Override
    public void onComplete() {
        log.info("¡completado!");
    }

    public Subscription getSubscription() {
        return this.subscription;
    }
}
````

````java
public class SubscriptionImpl implements Subscription {

    private static final Logger log = LoggerFactory.getLogger(SubscriptionImpl.class);
    private final Subscriber<? super String> subscriber;

    public SubscriptionImpl(Subscriber<? super String> subscriber) {
        this.subscriber = subscriber;
    }

    @Override
    public void request(long l) {

    }

    @Override
    public void cancel() {

    }
}
````

````java
public class PublisherImpl implements Publisher<String> {
    @Override
    public void subscribe(Subscriber<? super String> subscriber) {
        SubscriptionImpl subscription = new SubscriptionImpl(subscriber);
        subscriber.onSubscribe(subscription);
    }
}
````

El código anterior muestra la implementación de la siguiente relación de interfaces.

![06.png](assets/section-01/06.png)

## Implementando nuestro propio Publisher/Subscriber - Parte 2

**Recordar**
> En la vida real no tenemos que hacer estas implementaciones, aquí solo lo estamos haciendo para entender cómo es que
> por debajo funciona y jugar un poco con estos conceptos.
>
> En entornos reales rara vez, o casi nunca, se implementan directamente las interfaces `Subscriber`, `Publisher` o
> `Subscription`, porque ya existen implementaciones robustas, eficientes y listas para usar como `Flux` y `Mono` de
> Project Reactor. Pero crear esas implementaciones a mano es una excelente forma de entender cómo fluye la información,
> cómo se maneja el backpressure, cómo se suscriben los consumidores, etc.
>
> Es como construir un motor desde cero para entender cómo funciona internamente, aunque luego uses uno ya armado.

La siguiente implementación del `Subscription` lo que hace es simular el envío de correos electrónicos generados
aleatoriamente, pero con un límite de `10 como máximo`. Cada vez que el `Subscriber` pide elementos `(con request(n))`,
esta clase responde generando hasta `n` correos (o menos si ya está por llegar al tope de 10), y se los envía con
`onNext`.

Cuando ya ha enviado los 10, llama a `onComplete()` para indicar que terminó, y marca la `suscripción` como cancelada
internamente para no seguir enviando más.

`En resumen`: es una fuente finita de correos falsos que respeta un límite y responde a la demanda del `Subscriber`.

````java
public class SubscriptionImpl implements Subscription {

    private static final Logger log = LoggerFactory.getLogger(SubscriptionImpl.class);
    private static final int MAX_ITEMS = 10;
    private final Faker faker;
    private final Subscriber<? super String> subscriber;
    private boolean isCancelled;
    private int count = 0;

    public SubscriptionImpl(Subscriber<? super String> subscriber) {
        this.subscriber = subscriber;
        this.faker = Faker.instance();
    }

    @Override
    public void request(long requested) {
        if (this.isCancelled) return;

        log.info("El subscriber ha solicitado {} items", requested);
        if (requested > MAX_ITEMS) {
            this.subscriber.onError(new RuntimeException("Falló la validación"));
            this.isCancelled = true;
            return;
        }

        for (int i = 0; i < requested && this.count < MAX_ITEMS; i++) {
            this.count++;
            this.subscriber.onNext(this.faker.internet().emailAddress());
        }

        if (this.count == MAX_ITEMS) {
            log.info("No más datos para producir");
            this.subscriber.onComplete();
            this.isCancelled = true;
        }
    }

    @Override
    public void cancel() {
        log.info("El subscriber fue cancelado");
        this.isCancelled = true;
    }
}
````

## Publisher/Subscriber demo

Tendremos en consideración los siguientes puntos al momento de realizar la demostración.

1. El `publisher` no produce datos a menos que el `subscriber` los solicite.
2. El `publisher` solo producirá <= elementos solicitados por el `subscriber`. El `publisher` también puede producir 0
   elementos.
3. El `subscriber` puede cancelar la suscripción. El productor debe detenerse en ese momento, ya que el `subscriber` ya
   no está interesado en consumir los datos.
4. El `publisher` puede enviar la señal de error para indicar que algo anda mal.

En la siguiente demostración, si llamamos al método `demo1()`, no veremos nada dado que no hemos solicitado nada al
`publisher`.

````java
public class Main {
    public static void main(String[] args) throws InterruptedException {
        demo1();
    }

    private static void demo1() {
        PublisherImpl publisher = new PublisherImpl();
        SubscriberImpl subscriber = new SubscriberImpl();
        publisher.subscribe(subscriber);
    }
}
````

En el siguiente ejemplo vemos que el publisher va devolviendo elementos según se le vayan solicitando. Llega un punto
en el que se llega al límite establecido, por lo tanto se completa el flujo.

````java
public class Main {
    public static void main(String[] args) throws InterruptedException {
        demo2();
    }

    private static void demo2() throws InterruptedException {
        PublisherImpl publisher = new PublisherImpl();
        SubscriberImpl subscriber = new SubscriberImpl();
        publisher.subscribe(subscriber);

        subscriber.getSubscription().request(3);
        Thread.sleep(Duration.ofSeconds(2));

        subscriber.getSubscription().request(3);
        Thread.sleep(Duration.ofSeconds(2));

        subscriber.getSubscription().request(3);
        Thread.sleep(Duration.ofSeconds(2));

        subscriber.getSubscription().request(3);
        Thread.sleep(Duration.ofSeconds(2));
    }
}
````

````bash
d.m.a.p.p.SubscriptionImpl     : El subscriber ha solicitado 3 items
d.m.a.p.s.SubscriberImpl       : recibido: clifford.mills@yahoo.com
d.m.a.p.s.SubscriberImpl       : recibido: eugene.muller@yahoo.com
d.m.a.p.s.SubscriberImpl       : recibido: waldo.wyman@gmail.com
d.m.a.p.p.SubscriptionImpl     : El subscriber ha solicitado 3 items
d.m.a.p.s.SubscriberImpl       : recibido: marquis.frami@yahoo.com
d.m.a.p.s.SubscriberImpl       : recibido: eduardo.lockman@yahoo.com
d.m.a.p.s.SubscriberImpl       : recibido: minh.jerde@gmail.com
d.m.a.p.p.SubscriptionImpl     : El subscriber ha solicitado 3 items
d.m.a.p.s.SubscriberImpl       : recibido: nikita.runte@yahoo.com
d.m.a.p.s.SubscriberImpl       : recibido: ha.hamill@hotmail.com
d.m.a.p.s.SubscriberImpl       : recibido: diana.murphy@hotmail.com
d.m.a.p.p.SubscriptionImpl     : El subscriber ha solicitado 3 items
d.m.a.p.s.SubscriberImpl       : recibido: bert.klocko@hotmail.com
d.m.a.p.p.SubscriptionImpl     : No más datos para producir
d.m.a.p.s.SubscriberImpl       : ¡completado!
````

En la siguiente demostración se solicitan inicialmente 3 elementos, posterior a esa solicitud se cancela la suscripción,
por lo tanto se deja de emitir elementos.

````java
public class Main {
    public static void main(String[] args) throws InterruptedException {
        demo3();
    }

    private static void demo3() throws InterruptedException {
        PublisherImpl publisher = new PublisherImpl();
        SubscriberImpl subscriber = new SubscriberImpl();
        publisher.subscribe(subscriber);

        subscriber.getSubscription().request(3);
        Thread.sleep(Duration.ofSeconds(2));

        subscriber.getSubscription().cancel();
    }
}
````

````bash
d.m.a.p.p.SubscriptionImpl     : El subscriber ha solicitado 3 items
d.m.a.p.s.SubscriberImpl       : recibido: margareta.bashirian@yahoo.com
d.m.a.p.s.SubscriberImpl       : recibido: bryant.schaefer@yahoo.com
d.m.a.p.s.SubscriberImpl       : recibido: robbie.botsford@gmail.com
d.m.a.p.p.SubscriptionImpl     : El subscriber fue cancelado
````

En la siguiente demostración, inicialmente se solicitan 3 elementos, mismos que son entregados sin problemas. A
continuación se solicitan 30 elementos, pero internamente en la `SubscriptionImpl` hay una validación que dice que si
supera la cantidad máxima permitida (10 elementos) el subscriber lance un error
`this.subscriber.onError(new RuntimeException("Falló la validación"));`

````java
public class Main {
    public static void main(String[] args) throws InterruptedException {
        demo4();
    }

    private static void demo4() throws InterruptedException {
        PublisherImpl publisher = new PublisherImpl();
        SubscriberImpl subscriber = new SubscriberImpl();
        publisher.subscribe(subscriber);

        subscriber.getSubscription().request(3);
        Thread.sleep(Duration.ofSeconds(2));
        subscriber.getSubscription().request(30);
        Thread.sleep(Duration.ofSeconds(2));
    }
}
````

````bash
23:54:28.917 INFO  [           main] d.m.a.p.p.SubscriptionImpl     : El subscriber ha solicitado 3 items
23:54:29.097 INFO  [           main] d.m.a.p.s.SubscriberImpl       : recibido: janiece.homenick@hotmail.com
23:54:29.098 INFO  [           main] d.m.a.p.s.SubscriberImpl       : recibido: jerry.okuneva@hotmail.com
23:54:29.099 INFO  [           main] d.m.a.p.s.SubscriberImpl       : recibido: erasmo.pollich@hotmail.com
23:54:31.109 INFO  [           main] d.m.a.p.p.SubscriptionImpl     : El subscriber ha solicitado 30 items
23:54:31.109 ERROR [           main] d.m.a.p.s.SubscriberImpl       : error
java.lang.RuntimeException: Falló la validación
	at dev.magadiflo.app.pubsub.publisher.SubscriptionImpl.request(SubscriptionImpl.java:29)
	at dev.magadiflo.app.pubsub.Main.demo4(Main.java:94)
	at dev.magadiflo.app.pubsub.Main.main(Main.java:22)
````

## Creando un subscriber predeterminado

A lo largo del curso usaremos el método `.subscribe()` para ver el resultado del flujo en los `Mono` y `Flux`. En este
sentido, para evitar escribir repetidamente dentro del `subscribe(...)` los tres parámetros
`value, error, () -> complete`, similar a como se muestra a continuación, es que crearemos un `subscriber`
predeterminado.

````java
public static void main(String[] args) {
    Mono<String> mono = Mono.just("Spanish");
    mono.subscribe(
            value -> log.info("recibido: {}", value),
            error -> log.info("error: {}", error.getMessage()),
            () -> log.info("¡completado!")
    );
}
````

Nuestro `DefaultSubscriber` implementa la interfaz `Subscriber`. Esto nos permitirá utilizarlo dentro del
método `.subscribe(...)` quien acepta una implementación del `subscriber`.

````java
public class DefaultSubscriber<T> implements Subscriber<T> {

    private static final Logger log = LoggerFactory.getLogger(DefaultSubscriber.class);
    private final String name;

    public DefaultSubscriber(String name) {
        this.name = name;
    }

    @Override
    public void onSubscribe(Subscription subscription) {
        subscription.request(Long.MAX_VALUE);
    }

    @Override
    public void onNext(T item) {
        log.info("{} recibido: {}", this.name, item);
    }

    @Override
    public void onError(Throwable throwable) {
        log.error("{} error: {}", this.name, throwable.getMessage());
    }

    @Override
    public void onComplete() {
        log.info("{} ¡completado!", this.name);
    }
}
````

Como vemos en el código anterior, la clase `DefaultSubscriber<T>` implementa `Subscriber<T>`, recibe un nombre para
identificar quién lo está usando, y maneja todos los métodos (`onSubscribe`, `onNext`, `onError`, `onComplete`)
de forma clara y reutilizable. Además, en `onSubscribe` hacemos `subscription.request(Long.MAX_VALUE)` para evitar
tener que pedir manualmente los elementos en cada uso.

Utilizaremos el `DefaultSubscriber` a través de una clase de utilidad. Esta clase nos retorna dos variantes de la
implementación del `Subscriber`. El primer método genérico retorna una implementación del `Subscriber<T>` al cual se
le pasa una cadena vacía por constructor. El segundo método genérico sí recibe un valor por parámetro y se lo envía al
constructor de la implementación. Además, estamos trabajando con la librería `Faker` que nos permitirá trabajar con
datos aleatorios, como correos, nombres, etc.

````java
public class Util {

    private static final Faker faker = Faker.instance();

    private Util() {
    }

    public static <T> Subscriber<T> subscriber() {
        return new DefaultSubscriber<>("");
    }

    public static <T> Subscriber<T> subscriber(String name) {
        return new DefaultSubscriber<>(name);
    }

    public static Faker faker() {
        return faker;
    }

    public static void sleepSeconds(long seconds) {
        try {
            Thread.sleep(Duration.ofSeconds(seconds));
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
    }
}
````

Realizamos una prueba rápida para ver cómo es que podemos usar nuestras clases implementadas anteriormente.

````java
public class Main {
    public static void main(String[] args) {
        Mono<String> mono = Mono.just("Spring Boot");
        mono.subscribe(Util.subscriber());
        mono.subscribe(Util.subscriber("martin"));
    }
}
````

Si vemos los resultados, todo está funcionando como esperábamos.

````bash
23:53:00.548 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Spring Boot
23:53:00.556 INFO  [           main] d.m.a.common.DefaultSubscriber :  ¡completado!
23:53:00.556 INFO  [           main] d.m.a.common.DefaultSubscriber : martin recibido: Spring Boot
23:53:00.556 INFO  [           main] d.m.a.common.DefaultSubscriber : martin ¡completado!
````

Por lo tanto, cada vez que queramos ver los valores de un `Publisher` cuando hagamos un `.subscribe()` solo necesitamos
utilizar nuestra clase de utilidad y llamar a uno de los dos métodos del `subscriber`. De esta manera, evitamos tener
que escribir constantemente los `callbacks` para manejar los `valores`, los `errores` o el `complete`.
