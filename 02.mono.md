# Sección 2: Mono

---

## Creación del proyecto

A continuación se muestran las dependencias que usaremos para trabajar en este proyecto junto con las configuraciones de
`logback.xml`.

````xml

<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>dev.magadiflo</groupId>
    <artifactId>java-reactive-programming</artifactId>
    <version>1.0-SNAPSHOT</version>

    <properties>
        <maven.compiler.source>21</maven.compiler.source>
        <maven.compiler.target>21</maven.compiler.target>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>

        <reactor.version>2023.0.8</reactor.version>
        <logback.version>1.5.8</logback.version>
        <faker.version>1.0.2</faker.version>
        <junit.version>5.10.1</junit.version>
    </properties>
    <dependencies>
        <dependency>
            <groupId>io.projectreactor</groupId>
            <artifactId>reactor-core</artifactId>
        </dependency>
        <dependency>
            <groupId>io.projectreactor.netty</groupId>
            <artifactId>reactor-netty-core</artifactId>
        </dependency>
        <dependency>
            <groupId>io.projectreactor.netty</groupId>
            <artifactId>reactor-netty-http</artifactId>
        </dependency>
        <dependency>
            <groupId>ch.qos.logback</groupId>
            <artifactId>logback-classic</artifactId>
            <version>${logback.version}</version>
        </dependency>
        <dependency>
            <groupId>org.slf4j</groupId>
            <artifactId>slf4j-api</artifactId>
            <version>2.0.16</version>
        </dependency>
        <dependency>
            <groupId>com.github.javafaker</groupId>
            <artifactId>javafaker</artifactId>
            <version>${faker.version}</version>
        </dependency>
        <!-- test dependencies -->
        <dependency>
            <groupId>org.junit.jupiter</groupId>
            <artifactId>junit-jupiter-engine</artifactId>
            <version>${junit.version}</version>
            <scope>test</scope>
        </dependency>
        <!-- step-verifier -->
        <dependency>
            <groupId>io.projectreactor</groupId>
            <artifactId>reactor-test</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>
    <dependencyManagement>
        <dependencies>
            <dependency>
                <groupId>io.projectreactor</groupId>
                <artifactId>reactor-bom</artifactId>
                <version>${reactor.version}</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
        </dependencies>
    </dependencyManagement>
    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <configuration>
                    <source>21</source>
                    <target>21</target>
                </configuration>
            </plugin>
        </plugins>
    </build>
</project>
````

En el directorio `src/main/resources` agregamos el archivo `logback.xml`.

````xml
<!-- http://dev.cs.ovgu.de/java/logback/manual/layouts.html -->
<configuration>
    <appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
        <encoder>
            <pattern>%d{HH:mm:ss.SSS} %-5level [%15.15t] %cyan(%-30.30logger{30}) : %m%n</pattern>
        </encoder>
    </appender>
    <logger name="io.netty.resolver.dns.DnsServerAddressStreamProviders" level="OFF"/>
    <root level="INFO">
        <appender-ref ref="STDOUT"/>
    </root>
</configuration>
````

## Implementando nuestro propio Publisher/Subscriber - Parte 1

Los flujos reactivos proporcionan un conjunto de interfaces:

- `Publisher`
- `Subscription`
- `Subscriber`

En este apartado y en el siguiente realizaremos nuestra propia implementación, pero ojo, esto no lo haremos en la vida
real. Es solo para obtener la comprensión básica. En la vida real utilizaremos una implementación proporcionada por
el proyecto `Reactor`.

Ideemos algún caso de uso para nuestra aplicación:

- Publisher, proporcionará el correo electrónico del cliente.
- Suscriber, está interesado en el correo electrónico del cliente para poder enviarle mensajes promocionales.

A continuación vamos a crear las clases `PublisherImpl`, `SubscriberImpl` y `SubscriptionImpl`. Recordar que estas
clases solo son clases que creamos para ver cómo es que funciona la `programación reactiva` con la especificación de
`Reactive Stream`, es decir, en la vida real no tenemos qué hacerlas.

````java
public class SubscriberImpl implements Subscriber<String> {

    private static final Logger log = LoggerFactory.getLogger(SubscriberImpl.class);
    private Subscription subscription;

    @Override
    public void onSubscribe(Subscription subscription) {
        this.subscription = subscription;
    }

    @Override
    public void onNext(String email) {
        log.info("recibido: {}", email);
    }

    @Override
    public void onError(Throwable throwable) {
        log.error("error", throwable);
    }

    @Override
    public void onComplete() {
        log.info("¡completado!");
    }

    public Subscription getSubscription() {
        return this.subscription;
    }
}
````

````java
public class SubscriptionImpl implements Subscription {

    private static final Logger log = LoggerFactory.getLogger(SubscriptionImpl.class);
    private final Subscriber<? super String> subscriber;

    public SubscriptionImpl(Subscriber<? super String> subscriber) {
        this.subscriber = subscriber;
    }

    @Override
    public void request(long l) {

    }

    @Override
    public void cancel() {

    }
}
````

````java
public class PublisherImpl implements Publisher<String> {
    @Override
    public void subscribe(Subscriber<? super String> subscriber) {
        SubscriptionImpl subscription = new SubscriptionImpl(subscriber);
        subscriber.onSubscribe(subscription);
    }
}
````

El código anterior muestra la implementación de la siguiente relación de interfaces.

![06.png](assets/section-01/06.png)

## Implementando nuestro propio Publisher/Subscriber - Parte 2

**Recordar**
> En la vida real no tenemos que hacer estas implementaciones, aquí solo lo estamos haciendo para entender cómo es que
> por debajo funciona y jugar un poco con estos conceptos.
>
> En entornos reales rara vez, o casi nunca, se implementan directamente las interfaces `Subscriber`, `Publisher` o
> `Subscription`, porque ya existen implementaciones robustas, eficientes y listas para usar como `Flux` y `Mono` de
> Project Reactor. Pero crear esas implementaciones a mano es una excelente forma de entender cómo fluye la información,
> cómo se maneja el backpressure, cómo se suscriben los consumidores, etc.
>
> Es como construir un motor desde cero para entender cómo funciona internamente, aunque luego uses uno ya armado.

La siguiente implementación del `Subscription` lo que hace es simular el envío de correos electrónicos generados
aleatoriamente, pero con un límite de `10 como máximo`. Cada vez que el `Subscriber` pide elementos `(con request(n))`,
esta clase responde generando hasta `n` correos (o menos si ya está por llegar al tope de 10), y se los envía con
`onNext`.

Cuando ya ha enviado los 10, llama a `onComplete()` para indicar que terminó, y marca la `suscripción` como cancelada
internamente para no seguir enviando más.

`En resumen`: es una fuente finita de correos falsos que respeta un límite y responde a la demanda del `Subscriber`.

````java
public class SubscriptionImpl implements Subscription {

    private static final Logger log = LoggerFactory.getLogger(SubscriptionImpl.class);
    private static final int MAX_ITEMS = 10;
    private final Faker faker;
    private final Subscriber<? super String> subscriber;
    private boolean isCancelled;
    private int count = 0;

    public SubscriptionImpl(Subscriber<? super String> subscriber) {
        this.subscriber = subscriber;
        this.faker = Faker.instance();
    }

    @Override
    public void request(long requested) {
        if (this.isCancelled) return;

        log.info("El subscriber ha solicitado {} items", requested);
        if (requested > MAX_ITEMS) {
            this.subscriber.onError(new RuntimeException("Falló la validación"));
            this.isCancelled = true;
            return;
        }

        for (int i = 0; i < requested && this.count < MAX_ITEMS; i++) {
            this.count++;
            this.subscriber.onNext(this.faker.internet().emailAddress());
        }

        if (this.count == MAX_ITEMS) {
            log.info("No más datos para producir");
            this.subscriber.onComplete();
            this.isCancelled = true;
        }
    }

    @Override
    public void cancel() {
        log.info("El subscriber fue cancelado");
        this.isCancelled = true;
    }
}
````

## Publisher/Subscriber demo

Tendremos en consideración los siguientes puntos al momento de realizar la demostración.

1. El `publisher` no produce datos a menos que el `subscriber` los solicite.
2. El `publisher` solo producirá <= elementos solicitados por el `subscriber`. El `publisher` también puede producir 0
   elementos.
3. El `subscriber` puede cancelar la suscripción. El productor debe detenerse en ese momento, ya que el `subscriber` ya
   no está interesado en consumir los datos.
4. El `publisher` puede enviar la señal de error para indicar que algo anda mal.

En la siguiente demostración, si llamamos al método `demo1()`, no veremos nada dado que no hemos solicitado nada al
`publisher`.

````java
public class Main {
    public static void main(String[] args) throws InterruptedException {
        demo1();
    }

    private static void demo1() {
        PublisherImpl publisher = new PublisherImpl();
        SubscriberImpl subscriber = new SubscriberImpl();
        publisher.subscribe(subscriber);
    }
}
````

En el siguiente ejemplo vemos que el publisher va devolviendo elementos según se le vayan solicitando. Llega un punto
en el que se llega al límite establecido, por lo tanto se completa el flujo.

````java
public class Main {
    public static void main(String[] args) throws InterruptedException {
        demo2();
    }

    private static void demo2() throws InterruptedException {
        PublisherImpl publisher = new PublisherImpl();
        SubscriberImpl subscriber = new SubscriberImpl();
        publisher.subscribe(subscriber);

        subscriber.getSubscription().request(3);
        Thread.sleep(Duration.ofSeconds(2));

        subscriber.getSubscription().request(3);
        Thread.sleep(Duration.ofSeconds(2));

        subscriber.getSubscription().request(3);
        Thread.sleep(Duration.ofSeconds(2));

        subscriber.getSubscription().request(3);
        Thread.sleep(Duration.ofSeconds(2));
    }
}
````

````bash
d.m.a.p.p.SubscriptionImpl     : El subscriber ha solicitado 3 items
d.m.a.p.s.SubscriberImpl       : recibido: clifford.mills@yahoo.com
d.m.a.p.s.SubscriberImpl       : recibido: eugene.muller@yahoo.com
d.m.a.p.s.SubscriberImpl       : recibido: waldo.wyman@gmail.com
d.m.a.p.p.SubscriptionImpl     : El subscriber ha solicitado 3 items
d.m.a.p.s.SubscriberImpl       : recibido: marquis.frami@yahoo.com
d.m.a.p.s.SubscriberImpl       : recibido: eduardo.lockman@yahoo.com
d.m.a.p.s.SubscriberImpl       : recibido: minh.jerde@gmail.com
d.m.a.p.p.SubscriptionImpl     : El subscriber ha solicitado 3 items
d.m.a.p.s.SubscriberImpl       : recibido: nikita.runte@yahoo.com
d.m.a.p.s.SubscriberImpl       : recibido: ha.hamill@hotmail.com
d.m.a.p.s.SubscriberImpl       : recibido: diana.murphy@hotmail.com
d.m.a.p.p.SubscriptionImpl     : El subscriber ha solicitado 3 items
d.m.a.p.s.SubscriberImpl       : recibido: bert.klocko@hotmail.com
d.m.a.p.p.SubscriptionImpl     : No más datos para producir
d.m.a.p.s.SubscriberImpl       : ¡completado!
````

En la siguiente demostración se solicitan inicialmente 3 elementos, posterior a esa solicitud se cancela la suscripción,
por lo tanto se deja de emitir elementos.

````java
public class Main {
    public static void main(String[] args) throws InterruptedException {
        demo3();
    }

    private static void demo3() throws InterruptedException {
        PublisherImpl publisher = new PublisherImpl();
        SubscriberImpl subscriber = new SubscriberImpl();
        publisher.subscribe(subscriber);

        subscriber.getSubscription().request(3);
        Thread.sleep(Duration.ofSeconds(2));

        subscriber.getSubscription().cancel();
    }
}
````

````bash
d.m.a.p.p.SubscriptionImpl     : El subscriber ha solicitado 3 items
d.m.a.p.s.SubscriberImpl       : recibido: margareta.bashirian@yahoo.com
d.m.a.p.s.SubscriberImpl       : recibido: bryant.schaefer@yahoo.com
d.m.a.p.s.SubscriberImpl       : recibido: robbie.botsford@gmail.com
d.m.a.p.p.SubscriptionImpl     : El subscriber fue cancelado
````

En la siguiente demostración, inicialmente se solicitan 3 elementos, mismos que son entregados sin problemas. A
continuación se solicitan 30 elementos, pero internamente en la `SubscriptionImpl` hay una validación que dice que si
supera la cantidad máxima permitida (10 elementos) el subscriber lance un error
`this.subscriber.onError(new RuntimeException("Falló la validación"));`

````java
public class Main {
    public static void main(String[] args) throws InterruptedException {
        demo4();
    }

    private static void demo4() throws InterruptedException {
        PublisherImpl publisher = new PublisherImpl();
        SubscriberImpl subscriber = new SubscriberImpl();
        publisher.subscribe(subscriber);

        subscriber.getSubscription().request(3);
        Thread.sleep(Duration.ofSeconds(2));
        subscriber.getSubscription().request(30);
        Thread.sleep(Duration.ofSeconds(2));
    }
}
````

````bash
23:54:28.917 INFO  [           main] d.m.a.p.p.SubscriptionImpl     : El subscriber ha solicitado 3 items
23:54:29.097 INFO  [           main] d.m.a.p.s.SubscriberImpl       : recibido: janiece.homenick@hotmail.com
23:54:29.098 INFO  [           main] d.m.a.p.s.SubscriberImpl       : recibido: jerry.okuneva@hotmail.com
23:54:29.099 INFO  [           main] d.m.a.p.s.SubscriberImpl       : recibido: erasmo.pollich@hotmail.com
23:54:31.109 INFO  [           main] d.m.a.p.p.SubscriptionImpl     : El subscriber ha solicitado 30 items
23:54:31.109 ERROR [           main] d.m.a.p.s.SubscriberImpl       : error
java.lang.RuntimeException: Falló la validación
	at dev.magadiflo.app.pubsub.publisher.SubscriptionImpl.request(SubscriptionImpl.java:29)
	at dev.magadiflo.app.pubsub.Main.demo4(Main.java:94)
	at dev.magadiflo.app.pubsub.Main.main(Main.java:22)
````

## Mono/Flux - Introducción

El proyecto `Reactor` proporciona dos implementaciones de la interfaz `Publisher<T>`:

- `Mono<T>`
- `Flux<T>`

![01.png](assets/section-02/01.png)

## Mono

- Emite `0 o 1` elemento.
- Seguido por un `onComplete` / `onError`.
- Un `Mono<T>` es un `Publisher<T>` especializado que emite como máximo un elemento a través de la señal `onNext` y
  luego finaliza con una señal `onComplete` (Mono exitoso, con o sin valor) o solo emite una única señal `onError`
  (Mono fallido).

Nuestro primer enfoque será cómo crear un publisher `Mono` usando los métodos de fábrica. También para soportar la base
de código existente. El proyecto Reactor proporciona muchos métodos de fábrica, por lo que a continuación se muestran
los siguientes.

| Métodos de fábrica | Uso                                                   |
|--------------------|-------------------------------------------------------|
| just               | Cuando el valor ya está en la memoria                 |
| empty              | No hay ningún elemento para emitir                    |
| error              | Emitir error                                          |
| fromSupplier       | Aplazar la ejecución mediante el uso de `Supplier<T>` |
| fromCallable       | Aplazar la ejecución mediante `Callable<T>`           |
| fromFuture         | Publisher creado desde un `CompletableFuture<T>`      |

## Mono Just

- Crea un nuevo `Mono` que emite el elemento especificado, que se captura en el momento de la instanciación.
- Emite el valor especificado inmediatamente cuando alguien se suscribe a él.
- Luego envía una señal de completion `(onComplete)`.
- Es útil cuando ya tenemos un valor en memoria.
- Es útil cuando queremos adaptar ese valor al mundo `reactivo`, porque necesitamos retornar un `Publisher`.

En `programación reactiva`, trabajamos con flujos de datos que aún no se han producido, o que se producirán
`asíncronamente`. Pero a veces ya tienes el dato, y aún así necesitas envolverlo en un flujo para que todo nuestro
`pipeline` siga siendo `reactivo`.

Entonces `Mono.just(...)` sirve como una forma de decir:

> "Tengo este dato ya listo, pero igual quiero entregártelo en formato reactivo."

**Importante**
> `Mono.just(...)` no es perezoso `(not lazy)`. El valor se asigna o calcula inmediatamente. Es decir, el valor que le
> pasamos ya fue calculado y evaluado en el momento en que llamamos al método `Mono.just(...)`.

Por ejemplo:

````java
Mono<String> mono = Mono.just(getExpensiveValue());
````

Aquí, `getExpensiveValue()` se ejecuta de inmediato, en el momento de crear el `Mono`, no cuando alguien se suscribe.
Entonces el valor ya está en memoria cuando se crea el `Mono`. Lo que sí es perezoso es la emisión del valor:
`el valor solo se emite cuando alguien se suscribe`.

### Ejemplo con nuestro SubscriberImpl

En este primer ejemplo vamos a utilizar nuestra implementación del `SubscriberImpl` para pasarlo al `mono (publisher)`.
Luego, con el subscriber obtenemos la subscripción y solicitamos que nos retorne 1 elemento.

````java
public class Lec02MonoJust {
    private static final Logger log = LoggerFactory.getLogger(Lec02MonoJust.class);

    public static void main(String[] args) {
        Mono<String> mono = Mono.just("Spanish");
        SubscriberImpl subscriber = new SubscriberImpl();
        mono.subscribe(subscriber);
        subscriber.getSubscription().request(1);
    }
}
````

El resultado de la ejecución anterior nos muestra este log.

````bash
23:34:24.958 INFO  [           main] d.m.a.p.s.SubscriberImpl       : recibido: Spanish
23:34:24.963 INFO  [           main] d.m.a.p.s.SubscriberImpl       : ¡completado!
````

**¿Por qué en el `SubscriberImpl` necesitamos hacer el `request(1)`?**

- En la especificación `Reactive Streams`, un `Subscriber` no recibe ningún dato hasta que le dice al `Publisher`
  cuántos quiere recibir. Eso se hace mediante `subscription.request(n);`.
- Si no hacemos `request(...)`, el `Publisher` no enviará ningún dato, porque está esperando saber cuántos ítems
  quieres. Esto es parte de la filosofía `pull-based` del `backpressure`.
- Entonces, en nuestro ejemplo con `SubscriberImpl`, nosotros somos los que controlamos la demanda explícitamente,
  y si no haces el `request(1)`, no pasa nada, no hay emisión, no hay onNext.

### Ejemplo con el proporcionado por Reactor

En este segundo ejemplo creamos el mono con `Mono.just` y luego en el propio método del `subscribe` imprimimos los
valores.

````java
public class Lec02MonoJust {
    private static final Logger log = LoggerFactory.getLogger(Lec02MonoJust.class);

    public static void main(String[] args) {
        Mono<String> mono = Mono.just("Spanish");
        mono.subscribe(
                value -> log.info("recibido: {}", value),
                error -> log.info("error: {}", error.getMessage()),
                () -> log.info("¡completado!")
        );
    }
}
````

Observamos el mismo resultado que la ejecución inicial.

````bash
23:36:45.528 INFO  [           main] d.m.app.sec02.Lec02MonoJust    : recibido: Spanish
23:36:45.531 INFO  [           main] d.m.app.sec02.Lec02MonoJust    : ¡completado!
````

**¿Por qué sí emite valor sin hacer el `request(...)`?**

- ¡Porque `Reactor` ya lo hace por nosotros debajo del capó!
- Cuando hacemos, tal como lo hemos hecho dentro del `.subscribe(value..., error..., ()...)`, `Reactor` internamente
  crea un `LambdaSubscriber` (una implementación suya de `Subscriber`) y automáticamente hace algo así
  `subscription.request(Long.MAX_VALUE);`, es decir "dame todo lo que tengas disponible".
- Esto se hace por conveniencia, porque en la mayoría de los casos la gente quiere consumir los valores directamente sin
  preocuparse por el control de flujo.

Además, en el código anterior tenemos:

1. `Mono.just("Spanish")`, crea un `Mono<String>` que emite un único valor `Spanish` y luego finaliza (envía la señal
   `onComplete`). Este valor ya está en memoria, como lo mencionamos antes.

2. `mono.subscribe(...)`, aquí estamos suscribiéndonos al `Mono` con `3 callbacks` (funciones `lambda`), que
   corresponden a las señales del flujo reactivo.

## Creando un subscriber predeterminado

A lo largo del curso usaremos el método `.subscribe()` para ver el resultado del flujo en los `Mono` y `Flux`. En este
sentido, para evitar escribir repetidamente dentro del `subscribe(...)` los tres parámetros
`value, error, () -> complete`, similar a como se muestra a continuación, es que crearemos un `subscriber`
predeterminado.

````java
public static void main(String[] args) {
    Mono<String> mono = Mono.just("Spanish");
    mono.subscribe(
            value -> log.info("recibido: {}", value),
            error -> log.info("error: {}", error.getMessage()),
            () -> log.info("¡completado!")
    );
}
````

Nuestro `DefaultSubscriber` implementa la interfaz `Subscriber`. Esto nos permitirá utilizarlo dentro del
método `.subscribe(...)` quien acepta una implementación del `subscriber`.

````java
public class DefaultSubscriber<T> implements Subscriber<T> {

    private static final Logger log = LoggerFactory.getLogger(DefaultSubscriber.class);
    private final String name;

    public DefaultSubscriber(String name) {
        this.name = name;
    }

    @Override
    public void onSubscribe(Subscription subscription) {
        subscription.request(Long.MAX_VALUE);
    }

    @Override
    public void onNext(T item) {
        log.info("{} recibido: {}", this.name, item);
    }

    @Override
    public void onError(Throwable throwable) {
        log.error("{} error: {}", this.name, throwable.getMessage());
    }

    @Override
    public void onComplete() {
        log.info("{} ¡completado!", this.name);
    }
}
````

Como vemos en el código anterior, la clase `DefaultSubscriber<T>` implementa `Subscriber<T>`, recibe un nombre para
identificar quién lo está usando, y maneja todos los métodos (`onSubscribe`, `onNext`, `onError`, `onComplete`)
de forma clara y reutilizable. Además, en `onSubscribe` hacemos `subscription.request(Long.MAX_VALUE)` para evitar
tener que pedir manualmente los elementos en cada uso.

Utilizaremos el `DefaultSubscriber` a través de una clase de utilidad. Esta clase nos retorna dos variantes de la
implementación del `Subscriber`. El primer método genérico retorna una implementación del `Subscriber<T>` al cual se
le pasa una cadena vacía por constructor. El segundo método genérico sí recibe un valor por parámetro y se lo envía al
constructor de la implementación. Además, estamos trabajando con la librería `Faker` que nos permitirá trabajar con
datos aleatorios, como correos, nombres, etc.

````java
public class Util {

    private static final Faker faker = Faker.instance();

    private Util() {
    }

    public static <T> Subscriber<T> subscriber() {
        return new DefaultSubscriber<>("");
    }

    public static <T> Subscriber<T> subscriber(String name) {
        return new DefaultSubscriber<>(name);
    }

    public static Faker faker() {
        return faker;
    }

    public static void sleepSeconds(long seconds) {
        try {
            Thread.sleep(Duration.ofSeconds(seconds));
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
    }
}
````

Realizamos una prueba rápida para ver cómo es que podemos usar nuestras clases implementadas anteriormente.

````java
public class Main {
    public static void main(String[] args) {
        Mono<String> mono = Mono.just("Spring Boot");
        mono.subscribe(Util.subscriber());
        mono.subscribe(Util.subscriber("martin"));
    }
}
````

Si vemos los resultados, todo está funcionando como esperábamos.

````bash
23:53:00.548 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Spring Boot
23:53:00.556 INFO  [           main] d.m.a.common.DefaultSubscriber :  ¡completado!
23:53:00.556 INFO  [           main] d.m.a.common.DefaultSubscriber : martin recibido: Spring Boot
23:53:00.556 INFO  [           main] d.m.a.common.DefaultSubscriber : martin ¡completado!
````

Por lo tanto, cada vez que queramos ver los valores de un `Publisher` cuando hagamos un `.subscribe()` solo necesitamos
utilizar nuestra clase de utilidad y llamar a uno de los dos métodos del `subscriber`. De esta manera, evitamos tener
que escribir constantemente los `callbacks` para manejar los `valores`, los `errores` o el `complete`.

## Mono - Empty/Error

- `Mono.empty()`, crea un `Mono` que se completa sin emitir ningún elemento. Es decir, representa un Mono que no emite
  ningún valor, pero termina de forma exitosa (es decir, no lanza error). En otras palabras:
    - No hay `onNext` (porque no hay valor).
    - Se llama directamente a `onComplete`.


- `Mono.error(...)`, crea un `Mono` que finaliza con el error especificado inmediatamente después de suscribirse. Es
  decir, es un `Mono` que `no emite valor alguno y termina con un error`.
    - No hay `onNext`.
    - No hay `onComplete`.
    - Se llama directamente a `onError`.

````java
public class Lec04MonoEmptyError {
    public static void main(String[] args) {
        getUsername(2).subscribe(Util.subscriber("Ejem1"));  //Empty
        getUsername(3).subscribe(Util.subscriber("Ejem2"));  //Error
    }

    private static Mono<String> getUsername(int userId) {
        return switch (userId) {
            case 1 -> Mono.just("Marti");
            case 2 -> Mono.empty();
            default -> Mono.error(new RuntimeException("Entrada inválida"));
        };
    }
}
````

Si ejecutamos el ejemplo anterior vemos la primera línea se corresponden con el `Ejem1` y la última línea con el
`Ejem2`.

````bash
23:10:04.576 INFO  [           main] d.m.a.common.DefaultSubscriber : Ejem1 ¡completado!
23:10:04.579 ERROR [           main] d.m.a.common.DefaultSubscriber : Ejem2 error: Entrada inválida
````
