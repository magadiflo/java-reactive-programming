# Secci√≥n 2: Mono

---

## Mono/Flux - Introducci√≥n

El proyecto `Reactor` ‚Äîparte del ecosistema `Project Reactor` utilizado en `Spring WebFlux`‚Äî define la base del modelo
de programaci√≥n reactiva en Java.

En este modelo, todos los flujos de datos as√≠ncronos se representan a trav√©s de la interfaz `Publisher<T>`, que act√∫a
como fuente de datos.

El proyecto proporciona dos implementaciones principales de esta interfaz:

- `Mono<T>`: representa un flujo que puede emitir como m√°ximo un elemento (o ninguno).
- `Flux<T>`: representa un flujo que puede emitir cero, uno o m√∫ltiples elementos.

En el siguiente diagrama se muestran las relaciones entre los componentes principales del modelo reactivo:
`Publisher`, `Subscriber`, `Subscription`, `Mono` y `Flux`. Este esquema permite visualizar c√≥mo se comunican
y c√≥mo fluye la informaci√≥n desde la publicaci√≥n hasta la suscripci√≥n de datos.

![01.png](assets/section-02/01.png)

## Mono

- Emite `0 o 1` elemento.
- Seguido por un `onComplete` / `onError`.
- Un `Mono<T>` es un `Publisher<T>` especializado que emite como m√°ximo un elemento a trav√©s de la se√±al `onNext` y
  luego finaliza con una se√±al `onComplete` (Mono exitoso, con o sin valor) o solo emite una √∫nica se√±al `onError`
  (Mono fallido).

Nuestro primer enfoque ser√° c√≥mo crear un publisher `Mono` usando los m√©todos de f√°brica. Tambi√©n para soportar la base
de c√≥digo existente. El proyecto Reactor proporciona muchos m√©todos de f√°brica, por lo que a continuaci√≥n se muestran
los siguientes.

| M√©todos de f√°brica | Uso                                                   |
|--------------------|-------------------------------------------------------|
| just               | Cuando el valor ya est√° en la memoria                 |
| empty              | No hay ning√∫n elemento para emitir                    |
| error              | Emitir error                                          |
| fromSupplier       | Aplazar la ejecuci√≥n mediante el uso de `Supplier<T>` |
| fromCallable       | Aplazar la ejecuci√≥n mediante `Callable<T>`           |
| fromFuture         | Publisher creado desde un `CompletableFuture<T>`      |

## Mono Just

- Crea un nuevo `Mono` que emite el elemento especificado, que se captura en el momento de la instanciaci√≥n.
- Emite el valor especificado inmediatamente cuando alguien se suscribe a √©l.
- Luego env√≠a una se√±al de completion `(onComplete)`.
- Es √∫til cuando ya tenemos un valor en memoria.
- Es √∫til cuando queremos adaptar ese valor al mundo `reactivo`, porque necesitamos retornar un `Publisher`.

En `programaci√≥n reactiva`, trabajamos con flujos de datos que a√∫n no se han producido, o que se producir√°n
`as√≠ncronamente`. Pero a veces ya tienes el dato, y a√∫n as√≠ necesitas envolverlo en un flujo para que todo nuestro
`pipeline` siga siendo `reactivo`.

Entonces `Mono.just(...)` sirve como una forma de decir:

> "Tengo este dato ya listo, pero igual quiero entreg√°rtelo en formato reactivo."

**Importante**
> `Mono.just(...)` no es perezoso `(not lazy)`. El valor se asigna o calcula inmediatamente. Es decir, el valor que le
> pasamos ya fue calculado y evaluado en el momento en que llamamos al m√©todo `Mono.just(...)`.

Por ejemplo:

````java
Mono<String> mono = Mono.just(getExpensiveValue());
````

Aqu√≠, `getExpensiveValue()` se ejecuta de inmediato, en el momento de crear el `Mono`, no cuando alguien se suscribe.
Entonces el valor ya est√° en memoria cuando se crea el `Mono`. Lo que s√≠ es perezoso es la emisi√≥n del valor:
`el valor solo se emite cuando alguien se suscribe`.

### Ejemplo con nuestro SubscriberImpl

En este primer ejemplo vamos a utilizar nuestra implementaci√≥n del `SubscriberImpl` para pasarlo al `mono (publisher)`.
Luego, con el subscriber obtenemos la subscripci√≥n y solicitamos que nos retorne 1 elemento.

````java
public class Lec02MonoJust {
    private static final Logger log = LoggerFactory.getLogger(Lec02MonoJust.class);

    public static void main(String[] args) {
        Mono<String> mono = Mono.just("Spanish");
        SubscriberImpl subscriber = new SubscriberImpl();
        mono.subscribe(subscriber);
        subscriber.getSubscription().request(1);
    }
}
````

El resultado de la ejecuci√≥n anterior nos muestra este log.

````bash
23:34:24.958 INFO  [           main] d.m.a.p.s.SubscriberImpl       : recibido: Spanish
23:34:24.963 INFO  [           main] d.m.a.p.s.SubscriberImpl       : ¬°completado!
````

**¬øPor qu√© en el `SubscriberImpl` necesitamos hacer el `request(1)`?**

- En la especificaci√≥n `Reactive Streams`, un `Subscriber` no recibe ning√∫n dato hasta que le dice al `Publisher`
  cu√°ntos quiere recibir. Eso se hace mediante `subscription.request(n);`.
- Si no hacemos `request(...)`, el `Publisher` no enviar√° ning√∫n dato, porque est√° esperando saber cu√°ntos √≠tems
  quieres. Esto es parte de la filosof√≠a `pull-based` del `backpressure`.
- Entonces, en nuestro ejemplo con `SubscriberImpl`, nosotros somos los que controlamos la demanda expl√≠citamente,
  y si no haces el `request(1)`, no pasa nada, no hay emisi√≥n, no hay onNext.

### Ejemplo con el proporcionado por Reactor

En este segundo ejemplo creamos el mono con `Mono.just` y luego en el propio m√©todo del `subscribe` imprimimos los
valores.

````java
public class Lec02MonoJust {
    private static final Logger log = LoggerFactory.getLogger(Lec02MonoJust.class);

    public static void main(String[] args) {
        Mono<String> mono = Mono.just("Spanish");
        mono.subscribe(
                value -> log.info("recibido: {}", value),
                error -> log.info("error: {}", error.getMessage()),
                () -> log.info("¬°completado!")
        );
    }
}
````

Observamos el mismo resultado que la ejecuci√≥n inicial.

````bash
23:36:45.528 INFO  [           main] d.m.app.sec02.Lec02MonoJust    : recibido: Spanish
23:36:45.531 INFO  [           main] d.m.app.sec02.Lec02MonoJust    : ¬°completado!
````

**¬øPor qu√© s√≠ emite valor sin hacer el `request(...)`?**

- ¬°Porque `Reactor` ya lo hace por nosotros debajo del cap√≥!
- Cuando hacemos, tal como lo hemos hecho dentro del `.subscribe(value..., error..., ()...)`, `Reactor` internamente
  crea un `LambdaSubscriber` (una implementaci√≥n suya de `Subscriber`) y autom√°ticamente hace algo as√≠
  `subscription.request(Long.MAX_VALUE);`, es decir "dame todo lo que tengas disponible".
- Esto se hace por conveniencia, porque en la mayor√≠a de los casos la gente quiere consumir los valores directamente sin
  preocuparse por el control de flujo.

Adem√°s, en el c√≥digo anterior tenemos:

1. `Mono.just("Spanish")`, crea un `Mono<String>` que emite un √∫nico valor `Spanish` y luego finaliza (env√≠a la se√±al
   `onComplete`). Este valor ya est√° en memoria, como lo mencionamos antes.

2. `mono.subscribe(...)`, aqu√≠ estamos suscribi√©ndonos al `Mono` con `3 callbacks` (funciones `lambda`), que
   corresponden a las se√±ales del flujo reactivo.

## Mono - Empty/Error

- `Mono.empty()`, crea un `Mono` que se completa sin emitir ning√∫n elemento. Es decir, representa un Mono que no emite
  ning√∫n valor, pero termina de forma exitosa (es decir, no lanza error). En otras palabras:
    - No hay `onNext` (porque no hay valor).
    - Se llama directamente a `onComplete`.


- `Mono.error(...)`, crea un `Mono` que finaliza con el error especificado inmediatamente despu√©s de suscribirse. Es
  decir, es un `Mono` que `no emite valor alguno y termina con un error`.
    - No hay `onNext`.
    - No hay `onComplete`.
    - Se llama directamente a `onError`.

````java
public class Lec04MonoEmptyError {
    public static void main(String[] args) {
        getUsername(2).subscribe(Util.subscriber("Ejem1"));  //Empty
        getUsername(3).subscribe(Util.subscriber("Ejem2"));  //Error
    }

    private static Mono<String> getUsername(int userId) {
        return switch (userId) {
            case 1 -> Mono.just("Marti");
            case 2 -> Mono.empty();
            default -> Mono.error(new RuntimeException("Entrada inv√°lida"));
        };
    }
}
````

Si ejecutamos el ejemplo anterior vemos la primera l√≠nea se corresponden con el `Ejem1` y la √∫ltima l√≠nea con el
`Ejem2`.

````bash
23:10:04.576 INFO  [           main] d.m.a.common.DefaultSubscriber : Ejem1 ¬°completado!
23:10:04.579 ERROR [           main] d.m.a.common.DefaultSubscriber : Ejem2 error: Entrada inv√°lida
````

## Mono - From Supplier

El `Mono.fromSupplier(Supplier<T> supplier)` se usa cuando quieres que el c√≥digo que produce el valor se ejecute solo
cuando alguien se suscriba.

En otras palabras:

- No se ejecuta inmediatamente.
- Solo se ejecuta al hacer `.subscribe()`.
- Es √∫til cuando el valor es costoso de obtener o calcular, y no quieres hacerlo hasta que sea necesario.

El `Mono.fromSupplier`, crea un `Mono` que produce su valor utilizando el `Supplier` proporcionado. Si el `Supplier`
retorna `null`, el `Mono` resultante se completar√° vac√≠o `Mono.empty()`.

Produce un valor diferido. A diferencia de `Mono.just()`, que recibe un valor directamente, `Mono.fromSupplier()`
ejecuta el `Supplier` solo en el momento en que alguien se suscribe al `Mono`. Esto es √∫til cuando el c√°lculo o la
obtenci√≥n del valor puede tomar tiempo o cuando el valor puede cambiar entre diferentes suscripciones.

Veamos algunos detalles del `Mono.fromSupplier(...)`:

- Cuando necesitas diferir (posponer) la creaci√≥n o c√°lculo de un valor hasta que alguien se suscriba.
- Para envolver operaciones de larga duraci√≥n o c√°lculos que no deben ejecutarse hasta que realmente se necesiten.
- Para manejar situaciones donde el valor puede ser `null` y, en esos casos, devolver un `Mono.empty()` autom√°ticamente.
- `Lazy (evaluaci√≥n diferida)`, con `Mono.fromSupplier()`, el c√°lculo o la operaci√≥n que definas dentro del `Supplier`
  no se ejecuta de inmediato. La evaluaci√≥n se diferir√° hasta que alguien se suscriba al `Mono`. Es decir, el c√°lculo
  no ocurre hasta que realmente sea necesario.
- En `Mono.fromSupplier(...)`, si el `Supplier` lanza una `excepci√≥n no comprobada (unchecked)`, como
  `NullPointerException`, `RuntimeException`, etc., el `Mono` se convierte autom√°ticamente en un `Mono.error(...)`.

A continuaci√≥n se muestra un ejemplo del uso del `Mono.fromSupplier()`.

````java
public class Lec05MonoFromSupplier {

    private static final Logger log = LoggerFactory.getLogger(Lec05MonoFromSupplier.class);

    public static void main(String[] args) {
        List<Integer> list = List.of(1, 2, 3);
        Mono.fromSupplier(() -> sum(list))
                .subscribe(Util.subscriber());
    }

    private static Integer sum(List<Integer> numbers) {
        log.info("M√©todo donde se calcula la suma {}", numbers);
        return numbers.stream()
                .mapToInt(value -> value)
                .sum();
    }

}
````

````bash
23:56:07.554 INFO  [           main] d.m.a.s.Lec05MonoFromSupplier  : M√©todo donde se calcula la suma [1, 2, 3]
23:56:07.559 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 6
23:56:07.563 INFO  [           main] d.m.a.common.DefaultSubscriber :  ¬°completado!
````

**D√≥nde**

- `Mono.fromSupplier()` recibe una referencia a un m√©todo que retorna un valor (`int` en este caso).
- Ese m√©todo `no se ejecuta inmediatamente`.
- Se ejecuta solo cuando se hace `subscribe()`.
- El valor retornado (6) es emitido al `Subscriber` como un `onNext`.
- Luego, el flujo termina con `onComplete`.

**Nota**
> Si `sum()` devolviera `null`, el `Mono` actuar√≠a como `Mono.empty()` y no emitir√≠a ning√∫n valor (`onNext`), solo
`onComplete`.

## Mono - From Callable

`Mono.fromCallable(Callable<T> callable)` crea un `Mono` a partir de una funci√≥n que puede lanzar una
`excepci√≥n checked`. Si el `Callable` se resuelve como `null`, el `Mono` resultante es un `Mono.empty()`.

Es parecido a `Mono.fromSupplier()`, pero con algunas diferencias claves relacionadas con el manejo de excepciones.

| Caracter√≠stica      | fromSupplier()      | fromCallable()           |
|---------------------|---------------------|--------------------------|
| Retorna             | T                   | T                        |
| ¬øLanza excepciones? | No (solo unchecked) | S√≠ (checked o unchecked) |
| ¬øCu√°ndo se ejecuta? | Al suscribirse      | Al suscribirse           |

`Callable` es una interfaz funcional de Java que puede `devolver un valor` o `lanzar una excepci√≥n`. A diferencia de
`Supplier`, que `solo devuelve un valor`, `Callable` est√° dise√±ada para operaciones que pueden fallar, ya que puede
lanzar una excepci√≥n comprobada `(checked exception)`.

Al usar `Mono.fromCallable()` el c√°lculo no se ejecuta inmediatamente; se eval√∫a cuando alguien se suscribe al `Mono`,
al igual que `Mono.fromSupplier()`. Sin embargo, `Callable` permite manejar excepciones y propagar errores a los
suscriptores de forma m√°s sencilla.

A continuaci√≥n se muestra un ejemplo b√°sico.

````java
public class Lec06MonoFromCallable {
    private static final Logger log = LoggerFactory.getLogger(Lec06MonoFromCallable.class);

    public static void main(String[] args) {
        Mono.fromCallable(() -> getData())
                .subscribe(Util.subscriber());
    }

    private static String getData() throws Exception {
        log.info("Obteniendo datos...");
        double random = Math.random();
        if (random > 0.5) {
            throw new Exception("Fall√≥ en la obtenci√≥n de datos. random=%f".formatted(random));
        }
        return "Datos obtenidos correctamente. random=%f".formatted(random);
    }
}
````

- La funci√≥n `getData()` puede lanzar una excepci√≥n (`throws Exception`).
- `Mono.fromCallable()` captura esa excepci√≥n y la convierte en un `Mono.error()` autom√°ticamente.
- Cuando se llama a `subscribe()`, se ejecuta el m√©todo y el resultado se emite, o el `error` se propaga al
  `Subscriber`.

Si ejecutamos la aplicaci√≥n vemos que esta no se cae cuando se est√° lanzando una excepci√≥n en el m√©todo
`gatData()`, por el contrario, la excepci√≥n lanzada se captura e imprime en la secci√≥n de `onError()` de nuestro
`DefaultSubscriber()`.

````bash
23:02:31.045 INFO  [           main] d.m.a.s.Lec06MonoFromCallable  : Obteniendo datos...
23:02:31.065 ERROR [           main] d.m.a.common.DefaultSubscriber :  error: Fall√≥ en la obtenci√≥n de datos. random=0.793071
````

Si ejecutamos y no nos l anza la excepci√≥n el Mono est√° trabajando con normalidad.

````bash
23:05:32.674 INFO  [           main] d.m.a.s.Lec06MonoFromCallable  : Obteniendo datos...
23:05:32.689 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Datos obtenidos correctamente. random=0.406879
23:05:32.693 INFO  [           main] d.m.a.common.DefaultSubscriber :  ¬°completado!
````

## Mono - From Runnable

`Mono.fromRunnable(Runnable runnable)` crea un `Mono<Void>` a partir de una acci√≥n que no retorna ning√∫n valor,
pero que quieres ejecutar de forma reactiva.

A continuaci√≥n se muestran algunas caracter√≠sticas del `Mono.fromRunnable`:

| Aspecto           | Detalle                                                                                                 |
|-------------------|---------------------------------------------------------------------------------------------------------|
| Tipo de retorno   | `Mono<Void>` (no emite datos, solo la se√±al de completado)                                              |
| Cu√°ndo se ejecuta | Al suscribirse                                                                                          |
| Uso principal     | Ejecutar l√≥gica secundaria: logs, env√≠os de notificaciones, tareas, etc.                                |
| Propaga errores   | S√≠, si el `Runnable` lanza una excepci√≥n, el `Mono` emitir√° `onError` y NO se ejecutar√° `onComplete()`. |

A continuaci√≥n se muestra un ejemplo b√°sico.

````java
public class Lec07MonoFromRunnable {

    private static final Logger log = LoggerFactory.getLogger(Lec07MonoFromRunnable.class);

    public static void main(String[] args) {
        getProductName(2)
                .subscribe(Util.subscriber());
    }

    private static Mono<String> getProductName(int productId) {
        if (productId == 1) {
            return Mono.fromSupplier(() -> Util.faker().commerce().productName());
        }
        return Mono.fromRunnable(() -> notifyBusiness(productId));
    }

    private static void notifyBusiness(int productId) {
        log.info("Notificando: el producto con id {} no est√° disponible", productId);
    }

}
````

Si ejecutamos el c√≥digo anterior, vemos que el `Mono.fromRunnable()` permite que se ejecute el m√©todo `notifyBusiness()`
y luego que este m√©todo haya finalizado su ejecuci√≥n sin haber retornado nada `(void)` el `Mono.fromRunnable()` retorna
un `Mono.empty()`.

````bash
23:42:14.552 INFO  [           main] d.m.a.s.Lec07MonoFromRunnable  : Notificando: el producto con id 1 no est√° disponible
23:42:14.557 INFO  [           main] d.m.a.common.DefaultSubscriber :  ¬°completado!
````

## Mono - From Future

`Mono.fromFuture()` permite adaptar un `CompletableFuture` (o cualquier `Future`) a un `Mono`, integr√°ndolo de forma
natural al flujo reactivo de `Project Reactor`.

Lo usamos cuando ya tenemos c√≥digo que trabaja con `CompletableFuture` (por ejemplo, llamadas as√≠ncronas a servicios
externos o tareas largas) y queremos integrarlo con el modelo reactivo de `Reactor`.

````java
public class Lec08MonoFromFuture {

    private static final Logger log = LoggerFactory.getLogger(Lec08MonoFromFuture.class);

    public static void main(String[] args) {
        Mono.fromFuture(() -> getName())
                .subscribe(Util.subscriber());

        Util.sleepSeconds(3);
    }

    private static CompletableFuture<String> getName() {
        return CompletableFuture.supplyAsync(() -> {
            log.info("Generando nombre..");
            Util.sleepSeconds(2);
            return Util.faker().name().firstName();
        });
    }
}
````

**D√≥nde**

- `Mono.fromFuture()` espera a que el `Future` termine, y emite su valor.
- Si el `Future` falla, `Mono` emite `onError`.
- El `Mono` se completa cuando el `Future` se completa.
- Como los `Future` no son parte de Reactor, necesitamos evitar que el programa se cierre antes de que termine (por eso
  usamos `Util.sleepSeconds(3)` en el ejemplo).
- El `Util.sleepSeconds(2)` usado dentro del m√©todo `getName()` del `CompletableFuture` solo es para simular una demora
  de 2 segundos.
- `CompletableFuture<T>`, representa el resultado futuro de una operaci√≥n as√≠ncrona.
- `supplyAsync(Supplier<T>)`, ejecuta una tarea en segundo plano que retorna un valor.

El resultado que obtuvimos es exactamente el comportamiento esperado de `Mono.fromFuture()`:

````bash
23:22:36.190 INFO  [onPool-worker-1] d.m.a.s.Lec08MonoFromFuture    : Generando nombre..
23:22:38.316 INFO  [onPool-worker-1] d.m.a.common.DefaultSubscriber :  recibido: Terence
23:22:38.321 INFO  [onPool-worker-1] d.m.a.common.DefaultSubscriber :  ¬°completado!
````

1. `Mono.fromFuture(() -> getName())`
    - Se crea un `Mono` a partir del `CompletableFuture` que retorna el m√©todo `getName()`.

2. `Dentro de getName()`
    - Se imprime el log `Generando nombre...`
    - Se duerme el hilo durante 2 segundos simulando una tarea lenta.
    - Luego se genera un nombre aleatorio usando `Util.faker()` y se retorna.

3. `Suscripci√≥n al Mono`
    - El `Mono` se suscribe, lo que dispara la ejecuci√≥n del `CompletableFuture`.
    - Una vez que el `CompletableFuture` se completa (despu√©s de 2 segundos), el valor (`Terence` en este caso) es
      emitido al suscriptor.
    - Finalmente, se imprime `¬°completado!`.
4. `Util.sleepSeconds(3)`
    - Este `sleep` evita que el `main` termine antes de que el `Future` se complete.

## Mono - Defer

`Mono.defer` es un m√©todo est√°tico de `Reactor` que pospone la creaci√≥n del `Mono` hasta que alguien se suscriba.

Es √∫til cuando:

- Quieres crear un nuevo `Mono` para cada suscripci√≥n.
- El contenido del `Mono` depende de algo din√°mico o cambiante (como el tiempo, un estado, o una variable que cambia).
- `Mono.defer` es √∫til cuando el contenido del `Mono` es din√°mico o costoso de calcular, y necesitas que se re-eval√∫e
  cada vez que alguien se suscriba, en lugar de ejecutarse una sola vez como con `Mono.just`.

### ¬øEn qu√© se diferencia de Mono.just()?

- `Mono.just(valor)`, crea el `Mono` de inmediato, con el valor dado, aunque nadie se haya suscrito a√∫n.
- `Mono.defer(() -> Mono.just(valor))`, espera hasta que alguien se suscriba para crear el `Mono`.

````java
public class Lec10MonoDefer {

    private static final Logger log = LoggerFactory.getLogger(Lec10MonoDefer.class);

    public static void main(String[] args) {
        Mono<String> monoDefer = Mono.defer(() -> {
            log.info("Creando nuevo mono con defer...");
            return Mono.just(getNombre());
        });

        Util.sleepSeconds(1);
        monoDefer.subscribe(Util.subscriber("defer1"));

        Util.sleepSeconds(4);
        monoDefer.subscribe(Util.subscriber("defer2"));
    }


    private static String getNombre() {
        log.info("Generando nombre...");
        return Util.faker().name().firstName();
    }
}
````

**D√≥nde**

- `Mono.defer` no crea el `Mono` inmediatamente.
- La l√≥gica dentro de `Mono.defer(...)` se ejecuta cada vez que alguien se suscribe.
- Cada suscripci√≥n genera un nombre diferente, gracias a que el m√©todo `getNombre()` se llama de nuevo en cada ocasi√≥n.
- El `sleep` entre las suscripciones permite ver que no es un cach√© del primer resultado ‚Äî es una nueva ejecuci√≥n real.

A continuaci√≥n se muestra el resultado del c√≥digo anterior, donde cada suscripci√≥n ejecuta el m√©todo `getNombre()` desde
cero gracias a `Mono.defer`.

````bash
## Luego de esperar 1 segundo realiza una suscripci√≥n
23:35:19.288 INFO  [           main] d.m.app.sec02.Lec10MonoDefer   : Creando nuevo mono con defer...
23:35:19.291 INFO  [           main] d.m.app.sec02.Lec10MonoDefer   : Generando nombre...
23:35:19.413 INFO  [           main] d.m.a.common.DefaultSubscriber : defer1 recibido: Jaclyn
23:35:19.418 INFO  [           main] d.m.a.common.DefaultSubscriber : defer1 ¬°completado!

## Luego de esperar 4 segundos hay una segunda suscripci√≥n
23:35:23.426 INFO  [           main] d.m.app.sec02.Lec10MonoDefer   : Creando nuevo mono con defer...
23:35:23.426 INFO  [           main] d.m.app.sec02.Lec10MonoDefer   : Generando nombre...
23:35:23.426 INFO  [           main] d.m.a.common.DefaultSubscriber : defer2 recibido: Loren
23:35:23.426 INFO  [           main] d.m.a.common.DefaultSubscriber : defer2 ¬°completado!
````

Ahora, suponiendo que el `supplier` (contenido dentro del `.defer`) retorne un `null`, entonces lo que obtendremos ser√°
una `excepci√≥n`. Por ejemplo, tenemos el siguiente c√≥digo.

````java
public class Lec10MonoDefer {

    private static final Logger log = LoggerFactory.getLogger(Lec10MonoDefer.class);

    public static void main(String[] args) {
        Mono<String> monoDefer = Mono.defer(() -> {
            log.info("Creando nuevo mono con defer...");
            return null;
        });

        Util.sleepSeconds(1);
        monoDefer.subscribe(Util.subscriber("defer1"));
    }
}
````

El `suscriber` emitir√° un error.

````bash
23:51:04.143 INFO  [           main] d.m.app.sec02.Lec10MonoDefer   : Creando nuevo mono con defer...
23:51:04.156 ERROR [           main] d.m.a.common.DefaultSubscriber : defer1 error: The Mono returned by the supplier is null
````

## ¬øQu√© pasa con los datos de los servicios remotos o base de datos?

Normalmente cuado trabajamos con programaci√≥n reactiva en spring, utilizamos `Spring WebFlux` para realizar las
peticiones http, pero en este caso no estamos trabajando con `Spring WebFlux`, as√≠ que utilizaremos un `jar`
proporcionado por el tutor para hacer dichas peticiones http.

Descargamos el siguiente `jar` llamado
[external-services.jar](https://github.com/vinsguru/java-reactive-programming-course/raw/master/02-external-services/external-services.jar)
para demostrar el protocolo HTTP sin bloqueo.

Luego de haberlo descargado, lo copiaremos dentro de un directorio `servers` en el directorio ra√≠z de este proyecto. A
continuaci√≥n ejecutaremos el `jar`.

````bash
$ D:\programming\spring\01.udemy\03.vinoth_selvaraj\java-reactive-programming (feature/section-2)
Œª java -jar .\servers\external-services.jar

  .   ____          _            __ _ _
 /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \
( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \
 \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
  '  |____| .__|_| |_|_| |_\__, | / / / /
 =========|_|==============|___/=/_/_/_/
 :: Spring Boot ::                (v3.2.0)

2025-04-25T23:52:31.403-05:00  INFO 16688 --- [           main] c.v.e.ExternalServicesApplication        : Starting ExternalServicesApplication v0.0.1-SNAPSHOT using Java 21.0.6 with PID 16688 (D:\programming\spring\01.udemy\03.vinoth_selvaraj\java-reactive-programming\servers\external-services.jar started by magadiflo in D:\programming\spring\01.udemy\03.vinoth_selvaraj\java-reactive-programming)
2025-04-25T23:52:31.409-05:00  INFO 16688 --- [           main] c.v.e.ExternalServicesApplication        : No active profile set, falling back to 1 default profile: "default"
2025-04-25T23:52:33.437-05:00  INFO 16688 --- [           main] o.s.b.web.embedded.netty.NettyWebServer  : Netty started on port 7070
2025-04-25T23:52:33.453-05:00  INFO 16688 --- [           main] c.v.e.ExternalServicesApplication        : Started ExternalServicesApplication in 2.533 seconds (process running for 3.101)
````

Luego, si vamos a nuestro navegador e ingresamos al `http://localhost:7070/` veremos las siguientes apis expuestas con
las que iremos trabajando.

![02.png](assets/section-02/02.png)

## Cliente IO sin bloqueo

En este apartado crearemos nuestro propio `cliente HTTP no bloqueante`, utilizando las librer√≠as de `Reactor Netty`.
Esto nos permitir√° realizar peticiones HTTP de manera `reactiva`, sin bloquear hilos, siguiendo los principios de la
programaci√≥n reactiva.

Para este prop√≥sito, agregamos las siguientes dependencias en el archivo `pom.xml`.

````xml

<dependencies>
    <dependency>
        <groupId>io.projectreactor.netty</groupId>
        <artifactId>reactor-netty-core</artifactId>
    </dependency>
    <dependency>
        <groupId>io.projectreactor.netty</groupId>
        <artifactId>reactor-netty-http</artifactId>
    </dependency>
</dependencies>
````

**Nota**
> Cuando trabajemos con `Spring WebFlux`, no ser√° necesario agregar estas dependencias manualmente, ya que `WebFlux`
> nos proporciona un `cliente HTTP reactivo` llamado `WebClient`.
>
> En este ejercicio, creamos nuestro propio cliente para entender mejor c√≥mo funciona internamente un cliente reactivo
> como `WebClient`.

La siguiente clase abstracta configura un `cliente HTTP no bloqueante` utilizando `Reactor Netty`. Define lo siguiente:

- `BASE_URL`: URL base que se usar√° para todas las peticiones HTTP.
- `LoopResources`: recurso que define el grupo de hilos para manejar `IO` (permite controlar el comportamiento del
  cliente en cuanto a hilos y rendimiento).
- `HttpClient`: instancia configurada con el `loopResources` y la `baseUrl`.

Esto permite que cualquier clase que extienda de `AbstractHttpClient` herede la configuraci√≥n com√∫n del cliente.

````java
public abstract class AbstractHttpClient {
    private static final String BASE_URL = "http://localhost:7070";
    protected final HttpClient httpClient;

    protected AbstractHttpClient() {
        LoopResources loopResources = LoopResources.create("magadiflo", 1, true);
        this.httpClient = HttpClient.create()
                .runOn(loopResources)
                .baseUrl(BASE_URL);
    }
}
````

**Donde**

- `LoopResources`, crea un conjunto (pool) de hilos que manejar√°n las conexiones de red (IO) para el cliente HTTP. En
  nuestro caso tenemos `LoopResources.create("magadiflo", 1, true);`, donde.
    - `magadiflo`: Prefijo que tendr√°n los nombres de los hilos creados (√∫til para monitoreo).
    - `1`: N√∫mero de selectores (generalmente relacionado al n√∫mero de hilos de IO que quieres tener).
    - `true`: Permite optimizar o compartir recursos internamente seg√∫n la configuraci√≥n de Netty.
- `runOn(loopResources)`, le indica al `HttpClient` que utilice ese conjunto de hilos (`loopResources`) en lugar de usar
  el grupo de hilos por defecto. Esto da mayor control sobre el rendimiento y el comportamiento del cliente, como el
  n√∫mero de conexiones simult√°neas.

**En resumen**
> `LoopResources` crea los hilos que manejar√°n el trabajo de red, y `runOn()` hace que el `HttpClient` trabaje sobre
> esos hilos. As√≠ tenemos un `cliente HTTP` m√°s controlado y personalizable.

La siguiente clase extiende de `AbstractHttpClient` y representa un cliente personalizado para comunicarse con un
servicio externo. Expone un m√©todo `Mono<String> getProductName(int productId)`.

- `Hace una petici√≥n GET` al endpoint `/demo01/product/{productId}` del servidor definido en `BASE_URL`.
- `responseContent()` accede al contenido del cuerpo de la respuesta de manera reactiva.
- `asString()` transforma los bytes en un `Publisher<String>`.
- `next()` obtiene el primer elemento emitido y lo encapsula en un `Mono`.

Este dise√±o permite realizar peticiones HTTP completamente no bloqueantes, integr√°ndose naturalmente en flujos
reactivos.

````java
public class ExternalServiceClient extends AbstractHttpClient {
    public Mono<String> getProductName(int productId) {
        return this.httpClient
                .get()
                .uri("/demo01/product/" + productId)
                .responseContent()
                .asString()
                .next();
    }
}
````

## Demo IO sin bloqueo

En este apartado usaremos el cliente http que creamos anteriormente para realizar peticiones al servicio externo que nos
proporcion√≥ el tutor en apartados anterior. Para eso, es muy importante tener levantado dicho servicio.

````bash
D:\programming\spring\01.udemy\03.vinoth_selvaraj\java-reactive-programming (feature/section-2)
Œª java -jar .\servers\external-services.jar

  .   ____          _            __ _ _
 /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \
( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \
 \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
  '  |____| .__|_| |_|_| |_\__, | / / / /
 =========|_|==============|___/=/_/_/_/
 :: Spring Boot ::                (v3.2.0)

2025-04-29T23:06:39.013-05:00  INFO 6116 --- [           main] c.v.e.ExternalServicesApplication        : Starting ExternalServicesApplication v0.0.1-SNAPSHOT using Java 21.0.6 with PID 6116 (D:\programming\spring\01.udemy\03.vinoth_selvaraj\java-reactive-programming\servers\external-services.jar started by magadiflo in D:\programming\spring\01.udemy\03.vinoth_selvaraj\java-reactive-programming)
2025-04-29T23:06:39.017-05:00  INFO 6116 --- [           main] c.v.e.ExternalServicesApplication        : No active profile set, falling back to 1 default profile: "default"
2025-04-29T23:06:41.325-05:00  INFO 6116 --- [           main] o.s.b.web.embedded.netty.NettyWebServer  : Netty started on port 7070
2025-04-29T23:06:41.344-05:00  INFO 6116 --- [           main] c.v.e.ExternalServicesApplication        : Started ExternalServicesApplication in 2.884 seconds (process running for 3.546)
````

Creamos una clase de demostraci√≥n para realizar peticiones utilizando nuestro http cliente. Este c√≥digo demuestra el uso
no bloqueante de un `cliente HTTP` construido con `Reactor Netty`, haciendo m√∫ltiples solicitudes simult√°neas a un
servicio externo.

````java
public class Lec11NonBlockingIO {

    private static final Logger log = LoggerFactory.getLogger(Lec11NonBlockingIO.class);

    public static void main(String[] args) {
        ExternalServiceClient client = new ExternalServiceClient();

        log.info("iniciando");
        for (int i = 1; i <= 5; i++) {
            client.getProductName(i)
                    .subscribe(Util.subscriber());
        }

        //Solo para ver el resultado en consola es necesario bloquear el hilo principal
        Util.sleepSeconds(2);
    }
}
````

En el c√≥digo anterior se invoca `Util.sleepSeconds(2)` para evitar que el programa finalice antes de recibir las
respuestas, ya que `las operaciones son as√≠ncronas`.

El servicio externo (al que accede el `ExternalServiceClient`) fue configurado con una demora artificial para simular
la latencia t√≠pica de servicios reales. Esto permite verificar c√≥mo maneja Reactor m√∫ltiples solicitudes simult√°neamente
sin bloquear el hilo principal.

````bash
23:19:49.739 INFO  [           main] d.m.a.sec02.Lec11NonBlockingIO : iniciando
23:19:51.089 INFO  [magadiflo-nio-1] d.m.a.common.DefaultSubscriber :  recibido: product-2
23:19:51.097 INFO  [magadiflo-nio-1] d.m.a.common.DefaultSubscriber :  ¬°completado!
23:19:51.100 INFO  [magadiflo-nio-1] d.m.a.common.DefaultSubscriber :  recibido: product-1
23:19:51.100 INFO  [magadiflo-nio-1] d.m.a.common.DefaultSubscriber :  ¬°completado!
23:19:51.101 INFO  [magadiflo-nio-1] d.m.a.common.DefaultSubscriber :  recibido: product-5
23:19:51.102 INFO  [magadiflo-nio-1] d.m.a.common.DefaultSubscriber :  ¬°completado!
23:19:51.102 INFO  [magadiflo-nio-1] d.m.a.common.DefaultSubscriber :  recibido: product-3
23:19:51.102 INFO  [magadiflo-nio-1] d.m.a.common.DefaultSubscriber :  ¬°completado!
23:19:51.104 INFO  [magadiflo-nio-1] d.m.a.common.DefaultSubscriber :  recibido: product-4
23:19:51.104 INFO  [magadiflo-nio-1] d.m.a.common.DefaultSubscriber :  ¬°completado!
````

### ‚úÖ Interpretaci√≥n

- La aplicaci√≥n inicia inmediatamente (registro en `main`).
- Luego, todos los resultados de las 5 peticiones GET son recibidos casi al mismo tiempo `(~23:19:51)`.
- El procesamiento se realiza en un hilo llamado `magadiflo-nio-1`, que fue configurado expl√≠citamente en
  `LoopResources`.
- Cada suscripci√≥n imprime el resultado (`recibido: product-N`) seguido del mensaje `¬°completado!`.

### üß† Conclusi√≥n

- A pesar de que los servicios tienen una demora simulada, el cliente ejecut√≥ las peticiones de `forma concurrente` y
  `no bloque√≥ el hilo principal`, lo cual es el comportamiento esperado en programaci√≥n reactiva y no bloqueante.
- Todos los eventos fueron manejados por el hilo personalizado `magadiflo-nio-1`, configurado en el `LoopResources`, lo
  que muestra control sobre el `event loop`.
- La respuesta se muestra en orden desordenado (p. ej., `product-2`, luego `product-1`, etc.) porque las peticiones se
  ejecutan en paralelo y `cada respuesta depende del tiempo que el servidor se demora en responder`, no del orden en que
  fueron solicitadas.
    - Esto es una caracter√≠stica `natural de la programaci√≥n as√≠ncrona`: las respuestas se procesan tan pronto como
      llegan, sin esperar a que otras terminen primero.
- Este comportamiento valida que el flujo est√° funcionando en `modo no bloqueante`, lo que significa que no se impone
  ning√∫n orden artificial y se prioriza la eficiencia en tiempo de respuesta.

Supongamos que ahora modificamos el bucle for y hacemos `100 peticiones` por lo que obtenemos como respuesta `100`
resultados. A continuaci√≥n se muestra un extracto de dichos resultados.

````bash
23:45:26.298 INFO  [           main] d.m.a.sec02.Lec11NonBlockingIO : iniciando
23:45:27.795 INFO  [magadiflo-nio-1] d.m.a.common.DefaultSubscriber :  recibido: product-1
23:45:27.797 INFO  [magadiflo-nio-1] d.m.a.common.DefaultSubscriber :  ¬°completado!
23:45:27.798 INFO  [magadiflo-nio-1] d.m.a.common.DefaultSubscriber :  recibido: product-5
23:45:27.799 INFO  [magadiflo-nio-1] d.m.a.common.DefaultSubscriber :  ¬°completado!
...
23:45:27.972 INFO  [magadiflo-nio-1] d.m.a.common.DefaultSubscriber :  recibido: product-96
23:45:27.972 INFO  [magadiflo-nio-1] d.m.a.common.DefaultSubscriber :  ¬°completado!
23:45:27.972 INFO  [magadiflo-nio-1] d.m.a.common.DefaultSubscriber :  recibido: product-98
23:45:27.972 INFO  [magadiflo-nio-1] d.m.a.common.DefaultSubscriber :  ¬°completado!
23:45:27.972 INFO  [magadiflo-nio-1] d.m.a.common.DefaultSubscriber :  recibido: product-100
23:45:27.972 INFO  [magadiflo-nio-1] d.m.a.common.DefaultSubscriber :  ¬°completado!
````

### üß† ¬øPor qu√© todas las respuestas llegan "casi al mismo tiempo"?

> `Concurrencia`: Se refiere a la capacidad de un sistema para manejar m√∫ltiples tareas a la vez. Puede lograrse con un
> solo hilo o n√∫cleo, mediante t√©cnicas como el non-blocking I/O o la intercalaci√≥n de tareas. Por ejemplo, si tienes un
> solo hilo que maneja m√∫ltiples conexiones de red usando eventos o callbacks, eso es concurrencia.

Porque estamos usando una arquitectura `reactiva no bloqueante`, y estamos lanzando muchas `peticiones concurrentes`
(100 en este caso). Lo que ocurre es:

1. `Las solicitudes se procesan de forma as√≠ncrona`: no se bloquea un hilo esperando una respuesta antes de procesar la
   siguiente.
2. `El procesamiento es muy r√°pido o no tiene operaciones costosas (como sleeps o IO)`, por lo tanto, las respuestas
   "fluyen" r√°pidamente una tras otra.
3. `Todas las respuestas son gestionadas por el mismo hilo` del event loop (`magadiflo-nio-1`), lo que es caracter√≠stico
   de este modelo de programaci√≥n.

### üßµ ¬øPor qu√© solo se usa un hilo (magadiflo-nio-1)?

En WebFlux (y Reactor), por defecto se utiliza un `event loop basado en Netty`, que trabaja con un peque√±o grupo de
hilos no bloqueantes para manejar muchas conexiones concurrentes.

- El thread `magadiflo-nio-1` es uno de esos hilos del pool de Netty.
- No se necesitan m√°s hilos para cada petici√≥n como en el modelo tradicional servlet (como en Spring MVC con Tomcat).
- Si la l√≥gica dentro de cada flujo no hace trabajo bloqueante (como acceso a base de datos s√≠ncronos, Thread.sleep,
  etc.), no se delega a m√°s hilos y todo ocurre en ese hilo del event loop.

### Ventajas de la programaci√≥n reactiva frente a la imperativa

#### 1. Mayor eficiencia en el manejo de la concurrencia:

- `Programaci√≥n imperativa`: Si ejecutamos las 100 peticiones de manera secuencial (una detr√°s de otra), cada una de
  ellas esperar√° su turno, lo que significa que si cada una tarda, por ejemplo, 1 segundo, tomar√≠a 100 segundos en
  total.


- `Programaci√≥n reactiva`: En la programaci√≥n reactiva, las peticiones pueden realizarse de manera as√≠ncrona, sin
  esperar a que una termine antes de iniciar la siguiente. Usando operadores como flatMap, map, merge o zip, podemos
  enviar todas las peticiones al mismo tiempo (o casi) y manejar las respuestas a medida que llegan. En un escenario
  ideal, el tiempo total de procesamiento no se ver√≠a afectado por la cantidad de peticiones, ya que se estar√≠an
  ejecutando concurrentemente, esperando las respuestas sin bloquearse entre s√≠. El tiempo total para procesar todas las
  peticiones podr√≠a ser similar al tiempo de la m√°s larga de esas peticiones (por ejemplo, 3 segundos, si esa es la
  duraci√≥n de la petici√≥n m√°s lenta).

#### 2. No bloqueo de recursos:

- `Programaci√≥n imperativa`: Cada vez que una petici√≥n est√° esperando una respuesta (por ejemplo, de una base de datos o
  un servicio externo), el hilo se bloquea hasta que reciba esa respuesta. Esto puede ser costoso, ya que hay un gasto
  de recursos en t√©rminos de hilos bloqueados.


- `Programaci√≥n reactiva`: En la programaci√≥n reactiva, los hilos no se bloquean. En lugar de eso, cuando una tarea est√°
  esperando una respuesta, se puede liberar ese hilo para hacer otra cosa. Esto permite que el sistema maneje muchas m√°s
  peticiones simult√°neamente sin tener que crear muchos hilos. Usualmente, se puede usar un n√∫mero reducido de hilos
  para manejar muchas m√°s peticiones de manera eficiente.

## Preguntas frecuentes sobre c√≥mo funciona el bucle de eventos (Event Loop)

### E/S sin bloqueo (explicaci√≥n simplificada)

En este apartado vamos a discutir c√≥mo funciona la `E/S no bloqueante` por detr√°s, es decir, c√≥mo opera el
`bucle de eventos (event loop)` en un nivel simplificado.

Veamos la imagen inferior a muy alto nivel. Como parte del bucle de eventos, tenemos un √∫nico hilo y una
cola de tareas. Aunque todo esto est√° abstra√≠do para nosotros como desarrolladores, esto es lo que sucede internamente.

Cuando solicitamos, por ejemplo, el nombre del producto para los IDs 1, 2, 3, 4, etc., estas solicitudes se env√≠an a
`Reactor` (o `Reactor Netty`), y todas estas tareas se a√±aden a una cola. Luego, el `hilo del bucle de eventos` procesa
continuamente esa cola: si hay tareas, las toma y las ejecuta; si no, permanece inactivo.

Supongamos ahora que el servicio remoto es lento y tarda 1 segundo en responder. El hilo tomar√° la primera tarea (por
ejemplo, "obtener el nombre del producto con ID 1") y la enviar√°, pero `no esperar√°` a que llegue la respuesta.
En lugar de quedarse bloqueado, tomar√° inmediatamente la siguiente tarea y la enviar√° tambi√©n, y as√≠ sucesivamente.

De esta forma, podemos enviar incluso `100 solicitudes en paralelo`, `sin necesidad de usar 100 hilos`. Todo esto se
hace desde `un solo hilo` gracias al modelo `no bloqueante`.

### ¬øCu√°l respuesta llegar√° primero?

No hay ninguna garant√≠a sobre el orden en que llegar√°n las respuestas. La `latencia de red`, la
`carga del servidor remoto`, entre otros factores, influyen. Esto no es un problema de Java ni de la programaci√≥n
reactiva: lo mismo ocurre si usamos lenguajes como Go o Python. Es simplemente una caracter√≠stica inherente a las
comunicaciones de red.

Entonces, aunque enviemos las solicitudes en orden, podr√≠amos recibir primero la respuesta del producto con ID 3 antes
que la del ID 1.

Veamos la siguiente imagen conceptual.

![03.png](assets/section-02/03.png)

- En la cola superior se encuentran las tareas pendientes por enviar.
- El `hilo del bucle de eventos` sigue enviando solicitudes al servicio remoto.
- A medida que llegan las respuestas, el sistema operativo notifica al `hilo del bucle de eventos`.
- Estas respuestas se agregan a una cola de entrada (inferior), es decir, la cola de respuestas entrantes.

> Y nuevamente, `el orden en que llegan estas respuestas no est√° garantizado`.

Gracias a este modelo, `un solo hilo es capaz de manejar cientos de solicitudes concurrentes`, lo que hace que la
programaci√≥n reactiva sea extremadamente eficiente para aplicaciones con alta concurrencia y operaciones de E/S
intensivas.

## Preguntas frecuentes: ¬øPor qu√© no deber√≠amos usar block()?

En este apartado vamos a discutir por qu√© no se recomienda usar la sentencia `block()` en un entorno reactivo.

El m√©todo `block()` es una forma imperativa de obtener el resultado de un `Mono` o `Flux`. Lo que hace es detener el
hilo actual hasta que el valor est√© disponible, rompiendo as√≠ con el principio fundamental de la
`programaci√≥n reactiva`: la `no bloqueante` y la `asincron√≠a`.

### ¬øQu√© pasa si usamos block()?

Si llamamos a `block()` dentro de un flujo reactivo:

- Interrumpimos el procesamiento no bloqueante.
- Ocupamos un hilo innecesariamente mientras esperamos la respuesta.
- Podemos generar cuellos de botella, especialmente bajo alta carga o en aplicaciones con muchos usuarios concurrentes.
- Rompemos el flujo reactivo, lo que puede llevar a errores dif√≠ciles de depurar.

Por lo tanto, usar `block()` *elimina muchas de las ventajas de la programaci√≥n reactiva*, como el rendimiento, la
eficiencia en el uso de recursos, y la escalabilidad.

### ¬øCu√°ndo es aceptable usar block()?

Existen casos controlados donde su uso s√≠ es v√°lido:

- En `pruebas unitarias` (por ejemplo, al verificar el resultado final de un `Mono` o `Flux`).
- En c√≥digo de integraci√≥n o scripts temporales donde no hay una cadena reactiva que preservar.
- Al realizar una migraci√≥n progresiva de c√≥digo imperativo a reactivo (como paso intermedio, no como soluci√≥n final).

Sin embargo, su uso debe estar `limitado` y `consciente`, y `nunca en c√≥digo de producci√≥n reactivo`.

### ‚ùå Ejemplo de mal uso de block()

````java
public static void main(String[] args) {
    Mono<String> nombreProductoMono = servicio.obtenerNombreProducto("123");

    // Bloquea el hilo actual esperando la respuesta
    String nombre = nombreProductoMono.block(); // ‚ùå Esto rompe la naturaleza reactiva
    System.out.println("Nombre del producto: " + nombre);
}
````

En este caso, el hilo se detiene hasta que `nombreProductoMono` emita un valor. Si este Mono representa una llamada
remota o acceso a base de datos, podr√≠amos bloquear por milisegundos o incluso segundos. En un sistema con alta
concurrencia, esto es un gran problema.

### ‚úÖ Forma recomendada (reactiva)

````java
public static void main(String[] args) {
    servicio.obtenerNombreProducto("123")
            .subscribe(nombre -> System.out.println("Nombre del producto: " + nombre));
}
````

Aqu√≠ usamos `subscribe`, que `no bloquea el hilo actual`. En cambio, registramos una funci√≥n que se ejecutar√° cuando el
dato est√© disponible. Este enfoque es `totalmente no bloqueante` y se alinea con el modelo reactivo.

#### üîî NOTA: Este ejemplo usa `subscribe()` solo con fines demostrativos.

En una aplicaci√≥n real construida con `Spring WebFlux` (por ejemplo, una `API REST`), no debemos usar `subscribe()`
directamente en el c√≥digo del controlador o del servicio. `Spring WebFlux` se encarga de suscribirse por nosotros
cuando retornamos un `Mono` o `Flux` desde un `handler` o `endpoint`.

Es decir, nosotros solo escribimos:

````java

@GetMapping("/producto/{id}")
public Mono<String> obtenerNombreProducto(@PathVariable String id) {
    return servicio.obtenerNombreProducto(id); // ‚úÖ Spring WebFlux hace el subscribe
}
````

En cambio, si hacemos `subscribe()` manualmente dentro del handler, interrumpimos el flujo reactivo y el servidor no
puede controlar correctamente la respuesta.

## Asignaci√≥n

- Create `FileService`
    - read file y return content
    - create file y write content
    - delete file

  Tenemos la siguiente interfaz al que le debemos proporcionar una implementaci√≥n.

    ````java
    public interface FileService {
        Mono<String> read(String fileName);
    
        Mono<Void> write(String fileName, String content);
    
        Mono<Void> delete(String fileName);
    }
    ````
- Suposiciones
    - Algunos archivos son de tama√±o muy peque√±o.
    - Los archivos se encuentran en `src/main/resources/sec02`.

- Expectativas
    - Los m√©todos de servicio de archivos deben realizar el trabajo solo cuando los suscriptores se suscriban a ellos.
    - Comunicar el error al suscriptor en caso de problemas.
    - Simplemente, use lo aprendido hasta ahora y cualquier clase de utilidad. No necesita ninguna biblioteca especial.
      `java.nio.file`.

## Soluci√≥n

Iniciamos creando manualmente el directorio `sec02` en el siguiente path `src/main/resources/sec02`. Posteriormente,
definimos nuestra interfaz `FileService`.

````java
public interface FileService {
    Mono<String> read(String fileName);

    Mono<Void> write(String fileName, String content);

    Mono<Void> delete(String fileName);
}
````

A continuaci√≥n, realizamos la implementaci√≥n del `FileService`.

````java
public class FileServiceImpl implements FileService {

    private static final Logger log = LoggerFactory.getLogger(FileServiceImpl.class);
    private static final Path PATH = Path.of("src/main/resources/sec02");

    @Override
    public Mono<String> read(String fileName) {
        return Mono.fromCallable(() -> Files.readString(PATH.resolve(fileName)));
    }

    @Override
    public Mono<Void> write(String fileName, String content) {
        return Mono.fromRunnable(() -> this.writeFile(fileName, content));
    }

    @Override
    public Mono<Void> delete(String fileName) {
        return Mono.fromRunnable(() -> this.deleteFile(fileName));
    }

    private void writeFile(String fileName, String content) {
        try {
            Files.writeString(PATH.resolve(fileName), content);
            log.info("Contenido escrito en archivo: {}", fileName);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    private void deleteFile(String fileName) {
        try {
            Files.delete(PATH.resolve(fileName));
            log.info("Archivo eliminado: {}", fileName);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }
}
````

El m√©todo `.resolve(fileName)` de la clase `Path` en Java `concatena` el nombre del archivo (o subruta) al `Path base`.
En nuestro caso `private static final Path PATH = Path.of("src/main/resources/sec02");`, cuando luego hacemos lo
siguiente `Path resolve = PATH.resolve(fileName);` estar√≠a siendo equivalente a construir una ruta como la que sigue
`src/main/resources/sec02/{fileName}`. En nuestro caso, ser√≠a `src/main/resources/sec02/my-file.txt`. Tener en cuenta
que este m√©todo no modifica el `Path` original (`PATH` sigue siendo igual), sino que retorna un nuevo `Path` con la
ruta combinada.

En el m√©todo `read(String fileName)`, ¬øpor qu√© se ha usado `fromCallable`?

- El m√©todo `Files.readString(...)` retorna un valor (`String` con el contenido del archivo).
- Puede lanzar una `exception comprobada (IOException)` y `fromCallable` captura esa excepci√≥n y la convierte en una
  se√±al de error (`onError`) dentro del flujo reactivo.
- `fromCallable` es ideal para operaciones que retornan un valor y pueden fallar.

En el m√©todo `write(String fileName, String content)`, ¬øpor qu√© se ha usado el `fromRunnable`?

- `writeFile(...)` no retorna nada (`void`) pero tiene efectos secundarios (escribe en disco).
- El m√©todo puede lanzar una excepci√≥n, pero como `Runnable` no permite excepciones `checked`, lo manejamos
  correctamente envolviendo la excepci√≥n en una `RuntimeException`.
- `fromRunnable` es ideal para tareas `sin retorno`, pero que hacen algo √∫til (efectos secundarios como `logs`,
  `escritura`, etc.).

Finalmente, en la clase principal llamo a los m√©todos.

````java
public class Lec12Assignment {
    public static void main(String[] args) {
        String fileName = "my-file.txt";
        FileService fileService = new FileServiceImpl();

        fileService.write(fileName, "WebFlux Spring Boot")
                .subscribe(Util.subscriber());

        fileService.read(fileName)
                .subscribe(Util.subscriber());

        fileService.delete(fileName)
                .subscribe(Util.subscriber());
    }
}
````

Al ejecutar la clase principal, vemos que nuestra aplicaci√≥n est√° funcionando.

````bash
15:57:49.018 INFO  [           main] d.m.a.s.a.FileServiceImpl      : Contenido escrito en archivo: my-file.txt
15:57:49.020 INFO  [           main] d.m.a.common.DefaultSubscriber :  ¬°completado!
15:57:49.020 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: WebFlux Spring Boot
15:57:49.020 INFO  [           main] d.m.a.common.DefaultSubscriber :  ¬°completado!
15:57:49.020 INFO  [           main] d.m.a.s.a.FileServiceImpl      : Archivo eliminado: my-file.txt
15:57:49.020 INFO  [           main] d.m.a.common.DefaultSubscriber :  ¬°completado!
````
