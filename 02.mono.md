# Sección 2: Mono

---

## Creación del proyecto

A continuación se muestran las dependencias que usaremos para trabajar en este proyecto junto con las configuraciones de
`logback.xml`.

````xml

<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>dev.magadiflo</groupId>
    <artifactId>java-reactive-programming</artifactId>
    <version>1.0-SNAPSHOT</version>

    <properties>
        <maven.compiler.source>21</maven.compiler.source>
        <maven.compiler.target>21</maven.compiler.target>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>

        <reactor.version>2023.0.8</reactor.version>
        <logback.version>1.5.8</logback.version>
        <faker.version>1.0.2</faker.version>
        <junit.version>5.10.1</junit.version>
    </properties>
    <dependencies>
        <dependency>
            <groupId>io.projectreactor</groupId>
            <artifactId>reactor-core</artifactId>
        </dependency>
        <dependency>
            <groupId>io.projectreactor.netty</groupId>
            <artifactId>reactor-netty-core</artifactId>
        </dependency>
        <dependency>
            <groupId>io.projectreactor.netty</groupId>
            <artifactId>reactor-netty-http</artifactId>
        </dependency>
        <dependency>
            <groupId>ch.qos.logback</groupId>
            <artifactId>logback-classic</artifactId>
            <version>${logback.version}</version>
        </dependency>
        <dependency>
            <groupId>org.slf4j</groupId>
            <artifactId>slf4j-api</artifactId>
            <version>2.0.16</version>
        </dependency>
        <dependency>
            <groupId>com.github.javafaker</groupId>
            <artifactId>javafaker</artifactId>
            <version>${faker.version}</version>
        </dependency>
        <!-- test dependencies -->
        <dependency>
            <groupId>org.junit.jupiter</groupId>
            <artifactId>junit-jupiter-engine</artifactId>
            <version>${junit.version}</version>
            <scope>test</scope>
        </dependency>
        <!-- step-verifier -->
        <dependency>
            <groupId>io.projectreactor</groupId>
            <artifactId>reactor-test</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>
    <dependencyManagement>
        <dependencies>
            <dependency>
                <groupId>io.projectreactor</groupId>
                <artifactId>reactor-bom</artifactId>
                <version>${reactor.version}</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
        </dependencies>
    </dependencyManagement>
    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <configuration>
                    <source>21</source>
                    <target>21</target>
                </configuration>
            </plugin>
        </plugins>
    </build>
</project>
````

En el directorio `src/main/resources` agregamos el archivo `logback.xml`.

````xml
<!-- http://dev.cs.ovgu.de/java/logback/manual/layouts.html -->
<configuration>
    <appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
        <encoder>
            <pattern>%d{HH:mm:ss.SSS} %-5level [%15.15t] %cyan(%-30.30logger{30}) : %m%n</pattern>
        </encoder>
    </appender>
    <logger name="io.netty.resolver.dns.DnsServerAddressStreamProviders" level="OFF"/>
    <root level="INFO">
        <appender-ref ref="STDOUT"/>
    </root>
</configuration>
````

## Implementando nuestro propio Publisher/Subscriber - Parte 1

Los flujos reactivos proporcionan un conjunto de interfaces:

- `Publisher`
- `Subscription`
- `Subscriber`

En este apartado y en el siguiente realizaremos nuestra propia implementación, pero ojo, esto no lo haremos en la vida
real. Es solo para obtener la comprensión básica. En la vida real utilizaremos una implementación proporcionada por
el proyecto `Reactor`.

Ideemos algún caso de uso para nuestra aplicación:

- Publisher, proporcionará el correo electrónico del cliente.
- Suscriber, está interesado en el correo electrónico del cliente para poder enviarle mensajes promocionales.

A continuación vamos a crear las clases `PublisherImpl`, `SubscriberImpl` y `SubscriptionImpl`. Recordar que estas
clases solo son clases que creamos para ver cómo es que funciona la `programación reactiva` con la especificación de
`Reactive Stream`, es decir, en la vida real no tenemos qué hacerlas.

````java
public class SubscriberImpl implements Subscriber<String> {

    private static final Logger log = LoggerFactory.getLogger(SubscriberImpl.class);
    private Subscription subscription;

    @Override
    public void onSubscribe(Subscription subscription) {
        this.subscription = subscription;
    }

    @Override
    public void onNext(String email) {
        log.info("recibido: {}", email);
    }

    @Override
    public void onError(Throwable throwable) {
        log.error("error", throwable);
    }

    @Override
    public void onComplete() {
        log.info("¡completado!");
    }

    public Subscription getSubscription() {
        return this.subscription;
    }
}
````

````java
public class SubscriptionImpl implements Subscription {

    private static final Logger log = LoggerFactory.getLogger(SubscriptionImpl.class);
    private final Subscriber<? super String> subscriber;

    public SubscriptionImpl(Subscriber<? super String> subscriber) {
        this.subscriber = subscriber;
    }

    @Override
    public void request(long l) {

    }

    @Override
    public void cancel() {

    }
}
````

````java
public class PublisherImpl implements Publisher<String> {
    @Override
    public void subscribe(Subscriber<? super String> subscriber) {
        SubscriptionImpl subscription = new SubscriptionImpl(subscriber);
        subscriber.onSubscribe(subscription);
    }
}
````

El código anterior muestra la implementación de la siguiente relación de interfaces.

![06.png](assets/section-01/06.png)

## Implementando nuestro propio Publisher/Subscriber - Parte 2

**Recordar**
> En la vida real no tenemos que hacer estas implementaciones, aquí solo lo estamos haciendo para entender cómo es que
> por debajo funciona y jugar un poco con estos conceptos.
>
> En entornos reales rara vez, o casi nunca, se implementan directamente las interfaces `Subscriber`, `Publisher` o
> `Subscription`, porque ya existen implementaciones robustas, eficientes y listas para usar como `Flux` y `Mono` de
> Project Reactor. Pero crear esas implementaciones a mano es una excelente forma de entender cómo fluye la información,
> cómo se maneja el backpressure, cómo se suscriben los consumidores, etc.
>
> Es como construir un motor desde cero para entender cómo funciona internamente, aunque luego uses uno ya armado.

La siguiente implementación del `Subscription` lo que hace es simular el envío de correos electrónicos generados
aleatoriamente, pero con un límite de `10 como máximo`. Cada vez que el `Subscriber` pide elementos `(con request(n))`,
esta clase responde generando hasta `n` correos (o menos si ya está por llegar al tope de 10), y se los envía con
`onNext`.

Cuando ya ha enviado los 10, llama a `onComplete()` para indicar que terminó, y marca la `suscripción` como cancelada
internamente para no seguir enviando más.

`En resumen`: es una fuente finita de correos falsos que respeta un límite y responde a la demanda del `Subscriber`.

````java
public class SubscriptionImpl implements Subscription {

    private static final Logger log = LoggerFactory.getLogger(SubscriptionImpl.class);
    private static final int MAX_ITEMS = 10;
    private final Faker faker;
    private final Subscriber<? super String> subscriber;
    private boolean isCancelled;
    private int count = 0;

    public SubscriptionImpl(Subscriber<? super String> subscriber) {
        this.subscriber = subscriber;
        this.faker = Faker.instance();
    }

    @Override
    public void request(long requested) {
        if (this.isCancelled) return;

        log.info("El subscriber ha solicitado {} items", requested);
        if (requested > MAX_ITEMS) {
            this.subscriber.onError(new RuntimeException("Falló la validación"));
            this.isCancelled = true;
            return;
        }

        for (int i = 0; i < requested && this.count < MAX_ITEMS; i++) {
            this.count++;
            this.subscriber.onNext(this.faker.internet().emailAddress());
        }

        if (this.count == MAX_ITEMS) {
            log.info("No más datos para producir");
            this.subscriber.onComplete();
            this.isCancelled = true;
        }
    }

    @Override
    public void cancel() {
        log.info("El subscriber fue cancelado");
        this.isCancelled = true;
    }
}
````

## Publisher/Subscriber demo

Tendremos en consideración los siguientes puntos al momento de realizar la demostración.

1. El `publisher` no produce datos a menos que el `subscriber` los solicite.
2. El `publisher` solo producirá <= elementos solicitados por el `subscriber`. El `publisher` también puede producir 0
   elementos.
3. El `subscriber` puede cancelar la suscripción. El productor debe detenerse en ese momento, ya que el `subscriber` ya
   no está interesado en consumir los datos.
4. El `publisher` puede enviar la señal de error para indicar que algo anda mal.

En la siguiente demostración, si llamamos al método `demo1()`, no veremos nada dado que no hemos solicitado nada al
`publisher`.

````java
public class Main {
    public static void main(String[] args) throws InterruptedException {
        demo1();
    }

    private static void demo1() {
        PublisherImpl publisher = new PublisherImpl();
        SubscriberImpl subscriber = new SubscriberImpl();
        publisher.subscribe(subscriber);
    }
}
````

En el siguiente ejemplo vemos que el publisher va devolviendo elementos según se le vayan solicitando. Llega un punto
en el que se llega al límite establecido, por lo tanto se completa el flujo.

````java
public class Main {
    public static void main(String[] args) throws InterruptedException {
        demo2();
    }

    private static void demo2() throws InterruptedException {
        PublisherImpl publisher = new PublisherImpl();
        SubscriberImpl subscriber = new SubscriberImpl();
        publisher.subscribe(subscriber);

        subscriber.getSubscription().request(3);
        Thread.sleep(Duration.ofSeconds(2));

        subscriber.getSubscription().request(3);
        Thread.sleep(Duration.ofSeconds(2));

        subscriber.getSubscription().request(3);
        Thread.sleep(Duration.ofSeconds(2));

        subscriber.getSubscription().request(3);
        Thread.sleep(Duration.ofSeconds(2));
    }
}
````

````bash
d.m.a.p.p.SubscriptionImpl     : El subscriber ha solicitado 3 items
d.m.a.p.s.SubscriberImpl       : recibido: clifford.mills@yahoo.com
d.m.a.p.s.SubscriberImpl       : recibido: eugene.muller@yahoo.com
d.m.a.p.s.SubscriberImpl       : recibido: waldo.wyman@gmail.com
d.m.a.p.p.SubscriptionImpl     : El subscriber ha solicitado 3 items
d.m.a.p.s.SubscriberImpl       : recibido: marquis.frami@yahoo.com
d.m.a.p.s.SubscriberImpl       : recibido: eduardo.lockman@yahoo.com
d.m.a.p.s.SubscriberImpl       : recibido: minh.jerde@gmail.com
d.m.a.p.p.SubscriptionImpl     : El subscriber ha solicitado 3 items
d.m.a.p.s.SubscriberImpl       : recibido: nikita.runte@yahoo.com
d.m.a.p.s.SubscriberImpl       : recibido: ha.hamill@hotmail.com
d.m.a.p.s.SubscriberImpl       : recibido: diana.murphy@hotmail.com
d.m.a.p.p.SubscriptionImpl     : El subscriber ha solicitado 3 items
d.m.a.p.s.SubscriberImpl       : recibido: bert.klocko@hotmail.com
d.m.a.p.p.SubscriptionImpl     : No más datos para producir
d.m.a.p.s.SubscriberImpl       : ¡completado!
````

En la siguiente demostración se solicitan inicialmente 3 elementos, posterior a esa solicitud se cancela la suscripción,
por lo tanto se deja de emitir elementos.

````java
public class Main {
    public static void main(String[] args) throws InterruptedException {
        demo3();
    }

    private static void demo3() throws InterruptedException {
        PublisherImpl publisher = new PublisherImpl();
        SubscriberImpl subscriber = new SubscriberImpl();
        publisher.subscribe(subscriber);

        subscriber.getSubscription().request(3);
        Thread.sleep(Duration.ofSeconds(2));

        subscriber.getSubscription().cancel();
    }
}
````

````bash
d.m.a.p.p.SubscriptionImpl     : El subscriber ha solicitado 3 items
d.m.a.p.s.SubscriberImpl       : recibido: margareta.bashirian@yahoo.com
d.m.a.p.s.SubscriberImpl       : recibido: bryant.schaefer@yahoo.com
d.m.a.p.s.SubscriberImpl       : recibido: robbie.botsford@gmail.com
d.m.a.p.p.SubscriptionImpl     : El subscriber fue cancelado
````

En la siguiente demostración, inicialmente se solicitan 3 elementos, mismos que son entregados sin problemas. A
continuación se solicitan 30 elementos, pero internamente en la `SubscriptionImpl` hay una validación que dice que si
supera la cantidad máxima permitida (10 elementos) el subscriber lance un error
`this.subscriber.onError(new RuntimeException("Falló la validación"));`

````java
public class Main {
    public static void main(String[] args) throws InterruptedException {
        demo4();
    }

    private static void demo4() throws InterruptedException {
        PublisherImpl publisher = new PublisherImpl();
        SubscriberImpl subscriber = new SubscriberImpl();
        publisher.subscribe(subscriber);

        subscriber.getSubscription().request(3);
        Thread.sleep(Duration.ofSeconds(2));
        subscriber.getSubscription().request(30);
        Thread.sleep(Duration.ofSeconds(2));
    }
}
````

````bash
23:54:28.917 INFO  [           main] d.m.a.p.p.SubscriptionImpl     : El subscriber ha solicitado 3 items
23:54:29.097 INFO  [           main] d.m.a.p.s.SubscriberImpl       : recibido: janiece.homenick@hotmail.com
23:54:29.098 INFO  [           main] d.m.a.p.s.SubscriberImpl       : recibido: jerry.okuneva@hotmail.com
23:54:29.099 INFO  [           main] d.m.a.p.s.SubscriberImpl       : recibido: erasmo.pollich@hotmail.com
23:54:31.109 INFO  [           main] d.m.a.p.p.SubscriptionImpl     : El subscriber ha solicitado 30 items
23:54:31.109 ERROR [           main] d.m.a.p.s.SubscriberImpl       : error
java.lang.RuntimeException: Falló la validación
	at dev.magadiflo.app.pubsub.publisher.SubscriptionImpl.request(SubscriptionImpl.java:29)
	at dev.magadiflo.app.pubsub.Main.demo4(Main.java:94)
	at dev.magadiflo.app.pubsub.Main.main(Main.java:22)
````
