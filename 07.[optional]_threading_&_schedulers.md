# Secci√≥n 7: [Opcional] - Hilos y Schedulers

---

## Introducci√≥n

En esta secci√≥n hablaremos sobre `hilos` (`threads`) y `planificadores` (`schedulers`). Como sabemos, `Reactor` es una
librer√≠a para programaci√≥n reactiva as√≠ncrona basada en flujos. Dado que trabaja detr√°s de escena, utiliza herramientas
proporcionadas por Java, como hilos, canales de socket as√≠ncronos, entre otras.

Sin embargo, estas herramientas son complejas de manejar, propensas a errores y de muy bajo nivel. Es como un cuchillo:
si eres un chef, sabes c√≥mo usarlo, pero no se lo dar√≠as a un ni√±o porque podr√≠a lastimarse.

El `objetivo de Reactor` es simplificar todo esto, y lo hace bastante bien. Por ejemplo, si tenemos un `Flux` con
algunos operadores y un suscriptor, por defecto, todo se ejecutar√° en el hilo actual. Es decir, el mismo hilo que
inicia la ejecuci√≥n del programa ser√° responsable de:

- Suscribirse al publisher (`Flux`),
- Recibir el objeto de suscripci√≥n,
- Enviar solicitudes al publisher,
- Y procesar los elementos emitidos.

En otras palabras, todas las operaciones ocurren en el mismo hilo, a menos que indiquemos lo contrario.

Pero en algunos casos, esto no es ideal, ya que puede generar bloqueos o afectar el rendimiento. Es posible que
observemos comportamientos de bloqueo si no manejamos correctamente la ejecuci√≥n en m√∫ltiples hilos.

Entonces, veremos c√≥mo funciona internamente y qu√© opciones tenemos para aprovechar mejor los recursos disponibles,
como m√∫ltiples n√∫cleos de CPU, utilizando los schedulers que ofrece Reactor.

## Publisher/Subscriber - Default Thread - Demo

Por defecto, en `programaci√≥n reactiva` con `Reactor`,
`todo el flujo se ejecuta en el mismo hilo desde el cual se inicia la suscripci√≥n`. Es decir, si no se configura
expl√≠citamente un `Scheduler`, el hilo actual ser√° responsable de generar, procesar y consumir los datos.

Veamos el siguiente ejemplo:

````java
public class Lec01DefaultBehaviorDemo {

    private static final Logger log = LoggerFactory.getLogger(Lec01DefaultBehaviorDemo.class);

    public static void main(String[] args) {
        Flux<Integer> flux = Flux.<Integer>create(fluxSink -> {
            for (int i = 1; i < 3; i++) {
                log.info("Generando: {}", i);
                fluxSink.next(i);
            }
            fluxSink.complete();
        }).doOnNext(value -> log.info("value: {}", value));

        flux.subscribe(Util.subscriber());
    }
}
````

Explicaci√≥n del c√≥digo:

1. Se crea un `Flux<Integer>` usando `Flux.create`, que permite generar elementos de forma imperativa.
2. Dentro del `fluxSink`, se generan dos valores (1 y 2), y se emiten manualmente con `fluxSink.next(i)`.
3. Se usa `.doOnNext(...)` para interceptar y registrar cada valor emitido antes de que llegue al suscriptor.
4. Finalmente, se llama a `.subscribe(...)` para iniciar el flujo y consumir los elementos usando un suscriptor
   personalizado (`Util.subscriber()`).

Como se observa en el resultado, todo el flujo ‚Äîdesde la generaci√≥n hasta el consumo‚Äî se realiza en un √∫nico hilo:
`main`.

Esto confirma el `comportamiento por defecto de Reactor`, donde:

- El `publisher` emite los datos en el mismo hilo en que se ejecuta el `main`.
- Los operadores intermedios (`doOnNext`) y el `subscriber` tambi√©n operan en ese mismo hilo.

````bash
12:00:25.558 INFO  [           main] m.a.s.Lec01DefaultBehaviorDemo : Generando: 1
12:00:25.561 INFO  [           main] m.a.s.Lec01DefaultBehaviorDemo : value: 1
12:00:25.561 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 1
12:00:25.561 INFO  [           main] m.a.s.Lec01DefaultBehaviorDemo : Generando: 2
12:00:25.561 INFO  [           main] m.a.s.Lec01DefaultBehaviorDemo : value: 2
12:00:25.561 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 2
12:00:25.565 INFO  [           main] d.m.a.common.DefaultSubscriber :  ¬°completado!
````

Ahora agreguemos un `subscriber` adicional. Cuando un `Flux` es `cold` (fr√≠o), significa que cada vez que alguien se
suscribe, el flujo se vuelve a ejecutar desde el principio. En este ejemplo, agregamos dos suscriptores distintos
(`sub1` y `sub2`) al mismo `Flux`.

````java
public class Lec01DefaultBehaviorDemo {

    private static final Logger log = LoggerFactory.getLogger(Lec01DefaultBehaviorDemo.class);

    public static void main(String[] args) {
        Flux<Integer> flux = Flux.<Integer>create(fluxSink -> {
            for (int i = 1; i < 3; i++) {
                log.info("Generando: {}", i);
                fluxSink.next(i);
            }
            fluxSink.complete();
        }).doOnNext(value -> log.info("value: {}", value));

        flux.subscribe(Util.subscriber("sub1"));
        flux.subscribe(Util.subscriber("sub2"));
    }
}
````

Explicaci√≥n:

- Se crea un `Flux<Integer>` como en el ejemplo anterior.
- Esta vez, se suscriben dos consumidores distintos (`sub1` y `sub2`) al mismo flujo.
- Al tratarse de un flujo `cold`, cada suscripci√≥n desencadena una nueva ejecuci√≥n del flujo desde cero.
- Todo el procesamiento sigue ocurriendo en el hilo actual: `main`.

Si ejecutamos el c√≥digo anterior, veremos que el hilo principal `main` es el que est√° haciendo la suscripci√≥n, es decir
sigue haciendo todo el trabajo.

````bash
12:05:34.402 INFO  [           main] m.a.s.Lec01DefaultBehaviorDemo : Generando: 1
12:05:34.406 INFO  [           main] m.a.s.Lec01DefaultBehaviorDemo : value: 1
12:05:34.407 INFO  [           main] d.m.a.common.DefaultSubscriber : sub1 recibido: 1
12:05:34.407 INFO  [           main] m.a.s.Lec01DefaultBehaviorDemo : Generando: 2
12:05:34.407 INFO  [           main] m.a.s.Lec01DefaultBehaviorDemo : value: 2
12:05:34.407 INFO  [           main] d.m.a.common.DefaultSubscriber : sub1 recibido: 2
12:05:34.410 INFO  [           main] d.m.a.common.DefaultSubscriber : sub1 ¬°completado!
12:05:34.410 INFO  [           main] m.a.s.Lec01DefaultBehaviorDemo : Generando: 1
12:05:34.410 INFO  [           main] m.a.s.Lec01DefaultBehaviorDemo : value: 1
12:05:34.410 INFO  [           main] d.m.a.common.DefaultSubscriber : sub2 recibido: 1
12:05:34.410 INFO  [           main] m.a.s.Lec01DefaultBehaviorDemo : Generando: 2
12:05:34.410 INFO  [           main] m.a.s.Lec01DefaultBehaviorDemo : value: 2
12:05:34.410 INFO  [           main] d.m.a.common.DefaultSubscriber : sub2 recibido: 2
12:05:34.410 INFO  [           main] d.m.a.common.DefaultSubscriber : sub2 ¬°completado!
````

Lo que conclu√≠mos del resultado:

- Cada suscripci√≥n reinicia el flujo desde el principio. No es un "replay" del resultado anterior; se vuelve a ejecutar
  la l√≥gica de emisi√≥n.
- Ambos `sub1` y `sub2` reciben los mismos valores, pero independientemente.
- Todo el trabajo ocurre en el `hilo principal (main)`, lo que reafirma que `Reactor`, por defecto, no cambia de hilos
  ni ejecuta en paralelo si no se le indica expl√≠citamente.

Hasta ahora, todos los ejemplos se ejecutaban en el hilo principal (`main`), pero *¬øqu√© pasa si usamos un hilo
diferente para realizar la suscripci√≥n?*

````java
public class Lec01DefaultBehaviorDemo {

    private static final Logger log = LoggerFactory.getLogger(Lec01DefaultBehaviorDemo.class);

    public static void main(String[] args) {
        Flux<Integer> flux = Flux.<Integer>create(fluxSink -> {
            for (int i = 1; i < 3; i++) {
                log.info("Generando: {}", i);
                fluxSink.next(i);
            }
            fluxSink.complete();
        }).doOnNext(value -> log.info("value: {}", value));

        Runnable runnable = () -> flux.subscribe(Util.subscriber("sub1"));
        Thread.ofPlatform().start(runnable);
    }
}
````

Si nos fijamos en el resultado vemos que ahora el hilo `Thread-0` es el que est√° haciendo el trabajo y ya no el `main`.

````bash
12:12:14.506 INFO  [       Thread-0] m.a.s.Lec01DefaultBehaviorDemo : Generando: 1
12:12:14.508 INFO  [       Thread-0] m.a.s.Lec01DefaultBehaviorDemo : value: 1
12:12:14.509 INFO  [       Thread-0] d.m.a.common.DefaultSubscriber : sub1 recibido: 1
12:12:14.509 INFO  [       Thread-0] m.a.s.Lec01DefaultBehaviorDemo : Generando: 2
12:12:14.509 INFO  [       Thread-0] m.a.s.Lec01DefaultBehaviorDemo : value: 2
12:12:14.509 INFO  [       Thread-0] d.m.a.common.DefaultSubscriber : sub1 recibido: 2
12:12:14.511 INFO  [       Thread-0] d.m.a.common.DefaultSubscriber : sub1 ¬°completado!
````

Explicaci√≥n:

- En este ejemplo, en lugar de llamar directamente a `flux.subscribe(...)`, se hace desde otro hilo creado con
  `Thread.ofPlatform().start(...)`.
- Como resultado, todo el trabajo de generaci√≥n, procesamiento (`doOnNext`) y consumo (`subscribe`) se realiza en ese
  nuevo hilo: `Thread-0`.
- `Esto refuerza un principio importante en Reactor`: Por defecto, el hilo desde donde se realiza la suscripci√≥n es el
  hilo donde ocurren todas las operaciones del flujo.

¬øC√≥mo lo controlamos mejor? Para eso existen los operadores como:

- `subscribeOn(...)`: cambia el hilo donde se inicia la suscripci√≥n (es decir, desde d√≥nde se ejecuta el flujo).
- `publishOn(...)`: cambia el hilo desde donde se ejecutan las siguientes etapas del flujo (transformaciones,
  operadores, etc.).

üëâ En las siguientes secciones se explicar√° c√≥mo usar estos operadores para tener un control fino del threading model en
programaci√≥n reactiva.

## Schedulers

En la lecci√≥n anterior, vimos que, `por defecto, todo se ejecuta en el hilo actual`. En muchos casos, eso puede no ser
lo ideal.

`¬øPor qu√©?` Porque podr√≠amos tener, por ejemplo, 10 n√∫cleos de CPU disponibles en nuestra m√°quina, y, sin embargo,
estamos utilizando solo un hilo (`main`) para todo el trabajo.

Tambi√©n vimos que pod√≠amos crear un nuevo hilo y usarlo para suscribirnos al `Flux`, haciendo que ese hilo realice todo
el trabajo. Si bien eso puede funcionar, no es recomendable encargarnos nosotros mismos de crear y gestionar hilos.
Esto puede volverse complejo, propenso a errores y dif√≠cil de mantener.

### ¬øCu√°l es la soluci√≥n?

`Project Reactor` nos ofrece una soluci√≥n elegante: los `Schedulers`, que son conjuntos de *pools de hilos* optimizados
para distintos prop√≥sitos.

### ¬øQu√© es un Scheduler?

Un `Scheduler` es un componente que `define en qu√© hilo(s)` (o pool de hilos) se ejecutan las operaciones de un flujo
reactivo, como `Flux` o `Mono`.

Permite `controlar el contexto de ejecuci√≥n` para que puedas decidir si una operaci√≥n debe ejecutarse:

- en el hilo actual,
- en un hilo dedicado,
- en paralelo,
- o en hilos pensados para operaciones de bloqueo.

### Tipos comunes de Schedulers en Project Reactor:

1. `Schedulers.immediate()`, ejecuta las operaciones en el hilo actual. No cambia el contexto de ejecuci√≥n. Es el
   comportamiento por defecto.


2. `Schedulers.single()`, usa un solo hilo compartido para todas las tareas. Es √∫til cuando necesitas que las tareas se
   ejecuten secuencialmente en un mismo hilo (como en un entorno con restricciones de acceso concurrente).


3. `Schedulers.parallel()`, usa un pool de hilos de tama√±o fijo, usualmente igual al n√∫mero de n√∫cleos disponibles
   (`Runtime.getRuntime().availableProcessors()`). Es ideal para tareas `CPU-bound`, que no bloquean y pueden ejecutarse
   en paralelo.


4. `Schedulers.boundedElastic()`, usa un pool de hilos "el√°stico", con un l√≠mite superior. Est√° dise√±ado para tareas
   bloqueantes o de larga duraci√≥n, como llamadas a bases de datos, operaciones de E/S o APIs externas. Permite crecer
   si es necesario, pero con l√≠mites para evitar sobrecarga.

### ¬øC√≥mo se usan los Schedulers?

Reactor ofrece principalmente dos operadores para aplicar los `Schedulers`:

- `subscribeOn(Scheduler)`, define el `Scheduler` que se usar√° para iniciar el flujo, es decir, el hilo donde se
  generar√°n y emitir√°n los elementos. Afecta las operaciones anteriores a la ubicaci√≥n donde se coloca en el flujo.


- `publishOn(Scheduler)`, cambia el contexto de ejecuci√≥n a partir del punto donde se coloca este operador. Es √∫til
  cuando quieres procesar parte del flujo en otro hilo, sin afectar c√≥mo se generan los datos.

### Resumen gr√°fico:

| Operador      | Afecta desde...    | Afecta a...                   | Uso t√≠pico                                          |
|---------------|--------------------|-------------------------------|-----------------------------------------------------|
| `subscribeOn` | El punto de origen | Toda la cadena hacia atr√°s    | Controlar el hilo del publisher                     |
| `publishOn`   | Donde se aplica    | Toda la cadena hacia adelante | Cambiar el hilo del subscriber o etapas intermedias |
