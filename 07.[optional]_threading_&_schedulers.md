# Secci√≥n 7: [Opcional] - Hilos y Schedulers

---

## Introducci√≥n

En esta secci√≥n hablaremos sobre `hilos` (`threads`) y `planificadores` (`schedulers`). Como sabemos, `Reactor` es una
librer√≠a para programaci√≥n reactiva as√≠ncrona basada en flujos. Dado que trabaja detr√°s de escena, utiliza herramientas
proporcionadas por Java, como hilos, canales de socket as√≠ncronos, entre otras.

Sin embargo, estas herramientas son complejas de manejar, propensas a errores y de muy bajo nivel. Es como un cuchillo:
si eres un chef, sabes c√≥mo usarlo, pero no se lo dar√≠as a un ni√±o porque podr√≠a lastimarse.

El `objetivo de Reactor` es simplificar todo esto, y lo hace bastante bien. Por ejemplo, si tenemos un `Flux` con
algunos operadores y un suscriptor, por defecto, todo se ejecutar√° en el hilo actual. Es decir, el mismo hilo que
inicia la ejecuci√≥n del programa ser√° responsable de:

- Suscribirse al publisher (`Flux`),
- Recibir el objeto de suscripci√≥n,
- Enviar solicitudes al publisher,
- Y procesar los elementos emitidos.

En otras palabras, todas las operaciones ocurren en el mismo hilo, a menos que indiquemos lo contrario.

Pero en algunos casos, esto no es ideal, ya que puede generar bloqueos o afectar el rendimiento. Es posible que
observemos comportamientos de bloqueo si no manejamos correctamente la ejecuci√≥n en m√∫ltiples hilos.

Entonces, veremos c√≥mo funciona internamente y qu√© opciones tenemos para aprovechar mejor los recursos disponibles,
como m√∫ltiples n√∫cleos de CPU, utilizando los schedulers que ofrece Reactor.

## Publisher/Subscriber - Default Thread - Demo

Por defecto, en `programaci√≥n reactiva` con `Reactor`,
`todo el flujo se ejecuta en el mismo hilo desde el cual se inicia la suscripci√≥n`. Es decir, si no se configura
expl√≠citamente un `Scheduler`, el hilo actual ser√° responsable de generar, procesar y consumir los datos.

Veamos el siguiente ejemplo:

````java
public class Lec01DefaultBehaviorDemo {

    private static final Logger log = LoggerFactory.getLogger(Lec01DefaultBehaviorDemo.class);

    public static void main(String[] args) {
        Flux<Integer> flux = Flux.<Integer>create(fluxSink -> {
            for (int i = 1; i < 3; i++) {
                log.info("Generando: {}", i);
                fluxSink.next(i);
            }
            fluxSink.complete();
        }).doOnNext(value -> log.info("value: {}", value));

        flux.subscribe(Util.subscriber());
    }
}
````

Explicaci√≥n del c√≥digo:

1. Se crea un `Flux<Integer>` usando `Flux.create`, que permite generar elementos de forma imperativa.
2. Dentro del `fluxSink`, se generan dos valores (1 y 2), y se emiten manualmente con `fluxSink.next(i)`.
3. Se usa `.doOnNext(...)` para interceptar y registrar cada valor emitido antes de que llegue al suscriptor.
4. Finalmente, se llama a `.subscribe(...)` para iniciar el flujo y consumir los elementos usando un suscriptor
   personalizado (`Util.subscriber()`).

Como se observa en el resultado, todo el flujo ‚Äîdesde la generaci√≥n hasta el consumo‚Äî se realiza en un √∫nico hilo:
`main`.

Esto confirma el `comportamiento por defecto de Reactor`, donde:

- El `publisher` emite los datos en el mismo hilo en que se ejecuta el `main`.
- Los operadores intermedios (`doOnNext`) y el `subscriber` tambi√©n operan en ese mismo hilo.

````bash
12:00:25.558 INFO  [           main] m.a.s.Lec01DefaultBehaviorDemo : Generando: 1
12:00:25.561 INFO  [           main] m.a.s.Lec01DefaultBehaviorDemo : value: 1
12:00:25.561 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 1
12:00:25.561 INFO  [           main] m.a.s.Lec01DefaultBehaviorDemo : Generando: 2
12:00:25.561 INFO  [           main] m.a.s.Lec01DefaultBehaviorDemo : value: 2
12:00:25.561 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 2
12:00:25.565 INFO  [           main] d.m.a.common.DefaultSubscriber :  ¬°completado!
````

Ahora agreguemos un `subscriber` adicional. Cuando un `Flux` es `cold` (fr√≠o), significa que cada vez que alguien se
suscribe, el flujo se vuelve a ejecutar desde el principio. En este ejemplo, agregamos dos suscriptores distintos
(`sub1` y `sub2`) al mismo `Flux`.

````java
public class Lec01DefaultBehaviorDemo {

    private static final Logger log = LoggerFactory.getLogger(Lec01DefaultBehaviorDemo.class);

    public static void main(String[] args) {
        Flux<Integer> flux = Flux.<Integer>create(fluxSink -> {
            for (int i = 1; i < 3; i++) {
                log.info("Generando: {}", i);
                fluxSink.next(i);
            }
            fluxSink.complete();
        }).doOnNext(value -> log.info("value: {}", value));

        flux.subscribe(Util.subscriber("sub1"));
        flux.subscribe(Util.subscriber("sub2"));
    }
}
````

Explicaci√≥n:

- Se crea un `Flux<Integer>` como en el ejemplo anterior.
- Esta vez, se suscriben dos consumidores distintos (`sub1` y `sub2`) al mismo flujo.
- Al tratarse de un flujo `cold`, cada suscripci√≥n desencadena una nueva ejecuci√≥n del flujo desde cero.
- Todo el procesamiento sigue ocurriendo en el hilo actual: `main`.

Si ejecutamos el c√≥digo anterior, veremos que el hilo principal `main` es el que est√° haciendo la suscripci√≥n, es decir
sigue haciendo todo el trabajo.

````bash
12:05:34.402 INFO  [           main] m.a.s.Lec01DefaultBehaviorDemo : Generando: 1
12:05:34.406 INFO  [           main] m.a.s.Lec01DefaultBehaviorDemo : value: 1
12:05:34.407 INFO  [           main] d.m.a.common.DefaultSubscriber : sub1 recibido: 1
12:05:34.407 INFO  [           main] m.a.s.Lec01DefaultBehaviorDemo : Generando: 2
12:05:34.407 INFO  [           main] m.a.s.Lec01DefaultBehaviorDemo : value: 2
12:05:34.407 INFO  [           main] d.m.a.common.DefaultSubscriber : sub1 recibido: 2
12:05:34.410 INFO  [           main] d.m.a.common.DefaultSubscriber : sub1 ¬°completado!
12:05:34.410 INFO  [           main] m.a.s.Lec01DefaultBehaviorDemo : Generando: 1
12:05:34.410 INFO  [           main] m.a.s.Lec01DefaultBehaviorDemo : value: 1
12:05:34.410 INFO  [           main] d.m.a.common.DefaultSubscriber : sub2 recibido: 1
12:05:34.410 INFO  [           main] m.a.s.Lec01DefaultBehaviorDemo : Generando: 2
12:05:34.410 INFO  [           main] m.a.s.Lec01DefaultBehaviorDemo : value: 2
12:05:34.410 INFO  [           main] d.m.a.common.DefaultSubscriber : sub2 recibido: 2
12:05:34.410 INFO  [           main] d.m.a.common.DefaultSubscriber : sub2 ¬°completado!
````

Lo que conclu√≠mos del resultado:

- Cada suscripci√≥n reinicia el flujo desde el principio. No es un "replay" del resultado anterior; se vuelve a ejecutar
  la l√≥gica de emisi√≥n.
- Ambos `sub1` y `sub2` reciben los mismos valores, pero independientemente.
- Todo el trabajo ocurre en el `hilo principal (main)`, lo que reafirma que `Reactor`, por defecto, no cambia de hilos
  ni ejecuta en paralelo si no se le indica expl√≠citamente.

Hasta ahora, todos los ejemplos se ejecutaban en el hilo principal (`main`), pero *¬øqu√© pasa si usamos un hilo
diferente para realizar la suscripci√≥n?*

````java
public class Lec01DefaultBehaviorDemo {

    private static final Logger log = LoggerFactory.getLogger(Lec01DefaultBehaviorDemo.class);

    public static void main(String[] args) {
        Flux<Integer> flux = Flux.<Integer>create(fluxSink -> {
            for (int i = 1; i < 3; i++) {
                log.info("Generando: {}", i);
                fluxSink.next(i);
            }
            fluxSink.complete();
        }).doOnNext(value -> log.info("value: {}", value));

        Runnable runnable = () -> flux.subscribe(Util.subscriber("sub1"));
        Thread.ofPlatform().start(runnable);
    }
}
````

Si nos fijamos en el resultado vemos que ahora el hilo `Thread-0` es el que est√° haciendo el trabajo y ya no el `main`.

````bash
12:12:14.506 INFO  [       Thread-0] m.a.s.Lec01DefaultBehaviorDemo : Generando: 1
12:12:14.508 INFO  [       Thread-0] m.a.s.Lec01DefaultBehaviorDemo : value: 1
12:12:14.509 INFO  [       Thread-0] d.m.a.common.DefaultSubscriber : sub1 recibido: 1
12:12:14.509 INFO  [       Thread-0] m.a.s.Lec01DefaultBehaviorDemo : Generando: 2
12:12:14.509 INFO  [       Thread-0] m.a.s.Lec01DefaultBehaviorDemo : value: 2
12:12:14.509 INFO  [       Thread-0] d.m.a.common.DefaultSubscriber : sub1 recibido: 2
12:12:14.511 INFO  [       Thread-0] d.m.a.common.DefaultSubscriber : sub1 ¬°completado!
````

Explicaci√≥n:

- En este ejemplo, en lugar de llamar directamente a `flux.subscribe(...)`, se hace desde otro hilo creado con
  `Thread.ofPlatform().start(...)`.
- Como resultado, todo el trabajo de generaci√≥n, procesamiento (`doOnNext`) y consumo (`subscribe`) se realiza en ese
  nuevo hilo: `Thread-0`.
- `Esto refuerza un principio importante en Reactor`: Por defecto, el hilo desde donde se realiza la suscripci√≥n es el
  hilo donde ocurren todas las operaciones del flujo.

¬øC√≥mo lo controlamos mejor? Para eso existen los operadores como:

- `subscribeOn(...)`: cambia el hilo donde se inicia la suscripci√≥n (es decir, desde d√≥nde se ejecuta el flujo).
- `publishOn(...)`: cambia el hilo desde donde se ejecutan las siguientes etapas del flujo (transformaciones,
  operadores, etc.).

üëâ En las siguientes secciones se explicar√° c√≥mo usar estos operadores para tener un control fino del threading model en
programaci√≥n reactiva.
