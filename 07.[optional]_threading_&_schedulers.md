# Secci√≥n 7: [Opcional] - Hilos y Schedulers

---

## Introducci√≥n

En esta secci√≥n hablaremos sobre `hilos` (`threads`) y `planificadores` (`schedulers`). Como sabemos, `Reactor` es una
librer√≠a para programaci√≥n reactiva as√≠ncrona basada en flujos. Dado que trabaja detr√°s de escena, utiliza herramientas
proporcionadas por Java, como hilos, canales de socket as√≠ncronos, entre otras.

Sin embargo, estas herramientas son complejas de manejar, propensas a errores y de muy bajo nivel. Es como un cuchillo:
si eres un chef, sabes c√≥mo usarlo, pero no se lo dar√≠as a un ni√±o porque podr√≠a lastimarse.

El `objetivo de Reactor` es simplificar todo esto, y lo hace bastante bien. Por ejemplo, si tenemos un `Flux` con
algunos operadores y un suscriptor, por defecto, todo se ejecutar√° en el hilo actual. Es decir, el mismo hilo que
inicia la ejecuci√≥n del programa ser√° responsable de:

- Suscribirse al publisher (`Flux`),
- Recibir el objeto de suscripci√≥n,
- Enviar solicitudes al publisher,
- Y procesar los elementos emitidos.

En otras palabras, todas las operaciones ocurren en el mismo hilo, a menos que indiquemos lo contrario.

Pero en algunos casos, esto no es ideal, ya que puede generar bloqueos o afectar el rendimiento. Es posible que
observemos comportamientos de bloqueo si no manejamos correctamente la ejecuci√≥n en m√∫ltiples hilos.

Entonces, veremos c√≥mo funciona internamente y qu√© opciones tenemos para aprovechar mejor los recursos disponibles,
como m√∫ltiples n√∫cleos de CPU, utilizando los schedulers que ofrece Reactor.

## Publisher/Subscriber - Default Thread - Demo

Por defecto, en `programaci√≥n reactiva` con `Reactor`,
`todo el flujo se ejecuta en el mismo hilo desde el cual se inicia la suscripci√≥n`. Es decir, si no se configura
expl√≠citamente un `Scheduler`, el hilo actual ser√° responsable de generar, procesar y consumir los datos.

Veamos el siguiente ejemplo:

````java
public class Lec01DefaultBehaviorDemo {

    private static final Logger log = LoggerFactory.getLogger(Lec01DefaultBehaviorDemo.class);

    public static void main(String[] args) {
        Flux<Integer> flux = Flux.<Integer>create(fluxSink -> {
            for (int i = 1; i < 3; i++) {
                log.info("Generando: {}", i);
                fluxSink.next(i);
            }
            fluxSink.complete();
        }).doOnNext(value -> log.info("value: {}", value));

        flux.subscribe(Util.subscriber());
    }
}
````

Explicaci√≥n del c√≥digo:

1. Se crea un `Flux<Integer>` usando `Flux.create`, que permite generar elementos de forma imperativa.
2. Dentro del `fluxSink`, se generan dos valores (1 y 2), y se emiten manualmente con `fluxSink.next(i)`.
3. Se usa `.doOnNext(...)` para interceptar y registrar cada valor emitido antes de que llegue al suscriptor.
4. Finalmente, se llama a `.subscribe(...)` para iniciar el flujo y consumir los elementos usando un suscriptor
   personalizado (`Util.subscriber()`).

Como se observa en el resultado, todo el flujo ‚Äîdesde la generaci√≥n hasta el consumo‚Äî se realiza en un √∫nico hilo:
`main`.

Esto confirma el `comportamiento por defecto de Reactor`, donde:

- El `publisher` emite los datos en el mismo hilo en que se ejecuta el `main`.
- Los operadores intermedios (`doOnNext`) y el `subscriber` tambi√©n operan en ese mismo hilo.

````bash
12:00:25.558 INFO  [           main] m.a.s.Lec01DefaultBehaviorDemo : Generando: 1
12:00:25.561 INFO  [           main] m.a.s.Lec01DefaultBehaviorDemo : value: 1
12:00:25.561 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 1
12:00:25.561 INFO  [           main] m.a.s.Lec01DefaultBehaviorDemo : Generando: 2
12:00:25.561 INFO  [           main] m.a.s.Lec01DefaultBehaviorDemo : value: 2
12:00:25.561 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 2
12:00:25.565 INFO  [           main] d.m.a.common.DefaultSubscriber :  ¬°completado!
````

Ahora agreguemos un `subscriber` adicional. Cuando un `Flux` es `cold` (fr√≠o), significa que cada vez que alguien se
suscribe, el flujo se vuelve a ejecutar desde el principio. En este ejemplo, agregamos dos suscriptores distintos
(`sub1` y `sub2`) al mismo `Flux`.

````java
public class Lec01DefaultBehaviorDemo {

    private static final Logger log = LoggerFactory.getLogger(Lec01DefaultBehaviorDemo.class);

    public static void main(String[] args) {
        Flux<Integer> flux = Flux.<Integer>create(fluxSink -> {
            for (int i = 1; i < 3; i++) {
                log.info("Generando: {}", i);
                fluxSink.next(i);
            }
            fluxSink.complete();
        }).doOnNext(value -> log.info("value: {}", value));

        flux.subscribe(Util.subscriber("sub1"));
        flux.subscribe(Util.subscriber("sub2"));
    }
}
````

Explicaci√≥n:

- Se crea un `Flux<Integer>` como en el ejemplo anterior.
- Esta vez, se suscriben dos consumidores distintos (`sub1` y `sub2`) al mismo flujo.
- Al tratarse de un flujo `cold`, cada suscripci√≥n desencadena una nueva ejecuci√≥n del flujo desde cero.
- Todo el procesamiento sigue ocurriendo en el hilo actual: `main`.

Si ejecutamos el c√≥digo anterior, veremos que el hilo principal `main` es el que est√° haciendo la suscripci√≥n, es decir
sigue haciendo todo el trabajo.

````bash
12:05:34.402 INFO  [           main] m.a.s.Lec01DefaultBehaviorDemo : Generando: 1
12:05:34.406 INFO  [           main] m.a.s.Lec01DefaultBehaviorDemo : value: 1
12:05:34.407 INFO  [           main] d.m.a.common.DefaultSubscriber : sub1 recibido: 1
12:05:34.407 INFO  [           main] m.a.s.Lec01DefaultBehaviorDemo : Generando: 2
12:05:34.407 INFO  [           main] m.a.s.Lec01DefaultBehaviorDemo : value: 2
12:05:34.407 INFO  [           main] d.m.a.common.DefaultSubscriber : sub1 recibido: 2
12:05:34.410 INFO  [           main] d.m.a.common.DefaultSubscriber : sub1 ¬°completado!
12:05:34.410 INFO  [           main] m.a.s.Lec01DefaultBehaviorDemo : Generando: 1
12:05:34.410 INFO  [           main] m.a.s.Lec01DefaultBehaviorDemo : value: 1
12:05:34.410 INFO  [           main] d.m.a.common.DefaultSubscriber : sub2 recibido: 1
12:05:34.410 INFO  [           main] m.a.s.Lec01DefaultBehaviorDemo : Generando: 2
12:05:34.410 INFO  [           main] m.a.s.Lec01DefaultBehaviorDemo : value: 2
12:05:34.410 INFO  [           main] d.m.a.common.DefaultSubscriber : sub2 recibido: 2
12:05:34.410 INFO  [           main] d.m.a.common.DefaultSubscriber : sub2 ¬°completado!
````

Lo que conclu√≠mos del resultado:

- Cada suscripci√≥n reinicia el flujo desde el principio. No es un "replay" del resultado anterior; se vuelve a ejecutar
  la l√≥gica de emisi√≥n.
- Ambos `sub1` y `sub2` reciben los mismos valores, pero independientemente.
- Todo el trabajo ocurre en el `hilo principal (main)`, lo que reafirma que `Reactor`, por defecto, no cambia de hilos
  ni ejecuta en paralelo si no se le indica expl√≠citamente.

Hasta ahora, todos los ejemplos se ejecutaban en el hilo principal (`main`), pero *¬øqu√© pasa si usamos un hilo
diferente para realizar la suscripci√≥n?*

````java
public class Lec01DefaultBehaviorDemo {

    private static final Logger log = LoggerFactory.getLogger(Lec01DefaultBehaviorDemo.class);

    public static void main(String[] args) {
        Flux<Integer> flux = Flux.<Integer>create(fluxSink -> {
            for (int i = 1; i < 3; i++) {
                log.info("Generando: {}", i);
                fluxSink.next(i);
            }
            fluxSink.complete();
        }).doOnNext(value -> log.info("value: {}", value));

        Runnable runnable = () -> flux.subscribe(Util.subscriber("sub1"));
        Thread.ofPlatform().start(runnable);
    }
}
````

Si nos fijamos en el resultado vemos que ahora el hilo `Thread-0` es el que est√° haciendo el trabajo y ya no el `main`.

````bash
12:12:14.506 INFO  [       Thread-0] m.a.s.Lec01DefaultBehaviorDemo : Generando: 1
12:12:14.508 INFO  [       Thread-0] m.a.s.Lec01DefaultBehaviorDemo : value: 1
12:12:14.509 INFO  [       Thread-0] d.m.a.common.DefaultSubscriber : sub1 recibido: 1
12:12:14.509 INFO  [       Thread-0] m.a.s.Lec01DefaultBehaviorDemo : Generando: 2
12:12:14.509 INFO  [       Thread-0] m.a.s.Lec01DefaultBehaviorDemo : value: 2
12:12:14.509 INFO  [       Thread-0] d.m.a.common.DefaultSubscriber : sub1 recibido: 2
12:12:14.511 INFO  [       Thread-0] d.m.a.common.DefaultSubscriber : sub1 ¬°completado!
````

Explicaci√≥n:

- En este ejemplo, en lugar de llamar directamente a `flux.subscribe(...)`, se hace desde otro hilo creado con
  `Thread.ofPlatform().start(...)`.
- Como resultado, todo el trabajo de generaci√≥n, procesamiento (`doOnNext`) y consumo (`subscribe`) se realiza en ese
  nuevo hilo: `Thread-0`.
- `Esto refuerza un principio importante en Reactor`: Por defecto, el hilo desde donde se realiza la suscripci√≥n es el
  hilo donde ocurren todas las operaciones del flujo.

¬øC√≥mo lo controlamos mejor? Para eso existen los operadores como:

- `subscribeOn(...)`: cambia el hilo donde se inicia la suscripci√≥n (es decir, desde d√≥nde se ejecuta el flujo).
- `publishOn(...)`: cambia el hilo desde donde se ejecutan las siguientes etapas del flujo (transformaciones,
  operadores, etc.).

üëâ En las siguientes secciones se explicar√° c√≥mo usar estos operadores para tener un control fino del threading model en
programaci√≥n reactiva.

## Schedulers

En la lecci√≥n anterior, vimos que, `por defecto, todo se ejecuta en el hilo actual`. En muchos casos, eso puede no ser
lo ideal.

`¬øPor qu√©?` Porque podr√≠amos tener, por ejemplo, 10 n√∫cleos de CPU disponibles en nuestra m√°quina, y, sin embargo,
estamos utilizando solo un hilo (`main`) para todo el trabajo.

Tambi√©n vimos que pod√≠amos crear un nuevo hilo y usarlo para suscribirnos al `Flux`, haciendo que ese hilo realice todo
el trabajo. Si bien eso puede funcionar, no es recomendable encargarnos nosotros mismos de crear y gestionar hilos.
Esto puede volverse complejo, propenso a errores y dif√≠cil de mantener.

### ¬øCu√°l es la soluci√≥n?

`Project Reactor` nos ofrece una soluci√≥n elegante: los `Schedulers`, que son conjuntos de *pools de hilos* optimizados
para distintos prop√≥sitos.

### ¬øQu√© es un Scheduler?

Un `Scheduler` es un componente que `define en qu√© hilo(s)` (o pool de hilos) se ejecutan las operaciones de un flujo
reactivo, como `Flux` o `Mono`.

Permite `controlar el contexto de ejecuci√≥n` para que puedas decidir si una operaci√≥n debe ejecutarse:

- en el hilo actual,
- en un hilo dedicado,
- en paralelo,
- o en hilos pensados para operaciones de bloqueo.

### Tipos comunes de Schedulers en Project Reactor:

1. `Schedulers.immediate()`, ejecuta las operaciones en el hilo actual. No cambia el contexto de ejecuci√≥n. Es el
   comportamiento por defecto.


2. `Schedulers.single()`, usa un solo hilo compartido para todas las tareas. Es √∫til cuando necesitas que las tareas se
   ejecuten secuencialmente en un mismo hilo (como en un entorno con restricciones de acceso concurrente).


3. `Schedulers.parallel()` proporciona un pool de hilos de tama√±o fijo, usualmente igual al n√∫mero de n√∫cleos
   disponibles en el sistema (`Runtime.getRuntime().availableProcessors()`). Est√° pensado para tareas `CPU-bound`, es
   decir, tareas intensivas en procesamiento que no deben bloquear (como c√°lculos o transformaciones).


4. `Schedulers.boundedElastic()`, usa un pool de hilos "el√°stico", con un l√≠mite superior. Est√° dise√±ado para tareas
   bloqueantes o de larga duraci√≥n, como llamadas a bases de datos, operaciones de E/S o APIs externas. Permite crecer
   si es necesario, pero con l√≠mites para evitar sobrecarga.

### üß† Aclaraci√≥n sobre `Schedulers.parallel()`

Cuando la gente ve `Schedulers.parallel()`, a menudo asume que garantiza ejecuci√≥n paralela, como si todas las
operaciones se fueran a ejecutar al mismo tiempo. Pero en realidad no es as√≠. El nombre puede ser enga√±oso:
`Schedulers.parallel()` simplemente es un grupo de hilos dise√±ado para tareas relacionadas con el CPU, como c√°lculos
intensivos.

Esto `no significa que el procesamiento ocurrir√° en paralelo autom√°ticamente`. Muchos desarrolladores imaginan algo
como el de la *imagen inferior (lado izquierdo)*.

> ‚ÄúTengo un productor, tengo un suscriptor, tengo un pool de hilos‚Ä¶ as√≠ que cada hilo tomar√° un elemento del flujo y lo
> procesar√° de forma independiente‚Äù.

Pero esa `no es la forma en que funciona por defecto`.

![03.png](assets/section-07/03.png)

Lo que realmente ocurre es que cuando defines un `Flux`, creas una `tuber√≠a reactiva` (pipeline).
Y es posible que haya varios suscriptores a ese flujo: t√∫, yo, otros m√°s.
Si el flujo es un `cold publisher`, entonces cada suscriptor tendr√° su propia instancia del productor de datos.

En ese momento, cada suscriptor tomar√° prestado un hilo del pool de `Schedulers.parallel()` para ejecutar su trabajo.
As√≠, uno usar√° un hilo, otro usar√° un hilo distinto, y as√≠ sucesivamente.

> üëâ Ese es el comportamiento por defecto: `cada suscripci√≥n usa un hilo del scheduler`.
> *Imagen superior (lado derecho)*.

### ¬øC√≥mo se usan los Schedulers?

Reactor ofrece principalmente dos operadores para aplicar los `Schedulers`:

- `subscribeOn(Scheduler)`, define el `Scheduler` que se usar√° para iniciar el flujo, es decir, el hilo donde se
  generar√°n y emitir√°n los elementos. Afecta las operaciones anteriores a la ubicaci√≥n donde se coloca en el flujo.


- `publishOn(Scheduler)`, cambia el contexto de ejecuci√≥n a partir del punto donde se coloca este operador. Es √∫til
  cuando quieres procesar parte del flujo en otro hilo, sin afectar c√≥mo se generan los datos.

### Resumen gr√°fico:

| Operador      | Afecta desde...    | Afecta a...                   | Uso t√≠pico                                          |
|---------------|--------------------|-------------------------------|-----------------------------------------------------|
| `subscribeOn` | El punto de origen | Toda la cadena hacia atr√°s    | Controlar el hilo del publisher                     |
| `publishOn`   | Donde se aplica    | Toda la cadena hacia adelante | Cambiar el hilo del subscriber o etapas intermedias |

`publishOn` y `subscribeOn` son m√©todos convenientes en `Project Reactor` que aceptan cualquiera de los `Schedulers`
mencionados para cambiar el contexto de ejecuci√≥n de tareas para las operaciones en una pipeline reactiva.
Mientras que `subscribeOn` fuerza la emisi√≥n de origen a usar `Schedulers` espec√≠ficos, `publishOn` cambia los
`Schedulers` para todas las operaciones posteriores en la pipeline, como se muestra a continuaci√≥n.

![01.png](assets/section-07/01.png)

## SubscribeOn

El operador `subscribeOn(Scheduler)` en `Project Reactor` se utiliza para cambiar el `hilo (o pool de hilos)` en el que
se ejecuta la `suscripci√≥n y la generaci√≥n de los datos` dentro de un flujo reactivo (`Flux` o `Mono`). Es decir,
afecta la parte `"aguas arriba"` del flujo ‚Äî desde el punto donde se crea el flujo hasta donde se coloca el
`subscribeOn`.

![02.png](assets/section-07/02.png)

### ¬øQu√© hace exactamente?

Cuando usas `subscribeOn`, est√°s diciendo:

> ‚ÄúEjecuta todo el trabajo que ocurre antes o hasta este punto del flujo (incluida la creaci√≥n de los elementos y la
> suscripci√≥n) en el `Scheduler` que te estoy dando.‚Äù

Esto permite que las tareas que pueden ser costosas o lentas (por ejemplo, leer de un archivo, acceder a una base de
datos, etc.) se hagan en un hilo `diferente del hilo principal`.

### ¬øPor qu√© es √∫til?

- Permite liberar el hilo principal (`main`) para que no se bloquee.
- Es √∫til en aplicaciones reactivas donde necesitas evitar bloqueos y aprovechar m√∫ltiples n√∫cleos del procesador.
- Mejora el rendimiento cuando tienes flujos que hacen operaciones de bloqueo (como llamadas a servicios externos o
  lecturas desde disco).
- Se usa junto con `Schedulers` como `boundedElastic`, `parallel`, etc., para controlar el tipo de ejecuci√≥n.

### Ejemplo conceptual:

Imagina que tienes un `Flux` que lee archivos grandes. Si no usas `subscribeOn`, todo ese trabajo se har√° en el hilo
principal. Si usas:

````bash
flux.subscribeOn(Schedulers.boundedElastic())
````

Entonces la lectura y emisi√≥n de los datos del archivo se har√°n en un hilo especial del tipo el√°stico, que est√° pensado
para tareas de larga duraci√≥n o bloqueo.

### Importante:

- Aunque pongas m√∫ltiples `subscribeOn` en un flujo, `solo se respeta el primero` que aparece en la cadena.
- Se diferencia de `publishOn`, que cambia el hilo desde ese punto en adelante (flujo "aguas abajo").

## SubscribeOn - Demo

El operador `subscribeOn` en `Project Reactor` permite cambiar el `contexto (hilo o pool de hilos)` en el que se
ejecuta el flujo reactivo `desde su creaci√≥n`. Es decir, afecta todo lo que ocurre "aguas arriba", incluyendo:

- El momento en que se crea el flujo (por ejemplo, `en Flux.create(...)`).
- Cualquier operador anterior al `subscribeOn`, incluso `doFirst`.

````java
public class Lec02SubscribeOn {

    private static final Logger log = LoggerFactory.getLogger(Lec02SubscribeOn.class);

    public static void main(String[] args) {
        Flux<Integer> flux = Flux.<Integer>create(fluxSink -> {
            for (int i = 1; i < 3; i++) {
                log.info("Generando: {}", i);
                fluxSink.next(i);
            }
            fluxSink.complete();
        }).doOnNext(value -> log.info("value: {}", value));

        flux
                .doFirst(() -> log.info("first-1"))
                .subscribeOn(Schedulers.boundedElastic())
                .doFirst(() -> log.info("first-2"))
                .subscribe(Util.subscriber());

        Util.sleepSeconds(2);
    }
}
````

Este ejemplo tiene dos llamadas a `doFirst(...)`, y se aplica `subscribeOn(Schedulers.boundedElastic())`. Veamos el
orden y el hilo en que se ejecuta cada parte, compar√°ndolo con el log:

````bash
16:31:21.926 INFO  [           main] d.m.app.sec07.Lec02SubscribeOn : first-2
16:31:21.932 INFO  [oundedElastic-1] d.m.app.sec07.Lec02SubscribeOn : first-1
16:31:21.939 INFO  [oundedElastic-1] d.m.app.sec07.Lec02SubscribeOn : Generando: 1
16:31:21.940 INFO  [oundedElastic-1] d.m.app.sec07.Lec02SubscribeOn : value: 1
16:31:21.941 INFO  [oundedElastic-1] d.m.a.common.DefaultSubscriber :  recibido: 1
16:31:21.941 INFO  [oundedElastic-1] d.m.app.sec07.Lec02SubscribeOn : Generando: 2
16:31:21.941 INFO  [oundedElastic-1] d.m.app.sec07.Lec02SubscribeOn : value: 2
16:31:21.941 INFO  [oundedElastic-1] d.m.a.common.DefaultSubscriber :  recibido: 2
16:31:21.943 INFO  [oundedElastic-1] d.m.a.common.DefaultSubscriber :  ¬°completado!
````

Explicaci√≥n:

- `doFirst()` se ejecuta en orden inverso al que fueron declarados:
    - Primero se ejecuta `first-2` (√∫ltimo declarado), en el hilo `main`, antes de aplicar `subscribeOn`.
    - Luego `first-1` (declarado primero), en el hilo `boundedElastic`, porque ya est√° dentro del efecto de
      `subscribeOn`.

- La generaci√≥n (`Flux.create`) y el procesamiento (`doOnNext`, `subscribe`) tambi√©n ocurren en el hilo
  `boundedElastic`, que es el que gestionar√° todo a partir del punto en que se aplica `subscribeOn`.

> üí° `subscribeOn` siempre act√∫a desde el punto donde se declara hacia atr√°s (aguas arriba). Esto lo diferencia de
> `publishOn`, que act√∫a hacia adelante (aguas abajo).

## M√∫ltiple SubscribeOn

Cuando usas m√∫ltiples `subscribeOn`, el `subscribeOn` m√°s cercano a la fuente (`publisher`) es el que finalmente
determina el `Scheduler` que se usar√° para la ejecuci√≥n. Los dem√°s `subscribeOn` que sigan no tendr√°n efecto, porque
`subscribeOn` solo tiene impacto en el primer `subscribeOn` que se encuentre al recorrer el pipeline reactivo.

````java
public class Lec03MultipleSubscribeOn {

    private static final Logger log = LoggerFactory.getLogger(Lec03MultipleSubscribeOn.class);

    // Podemos tener varias suscripciones. La m√°s cercana a la fuente (publisher) tendr√° prioridad y es el
    // que acabar√° haciendo todo el trabajo
    public static void main(String[] args) {
        Flux<Integer> flux = Flux.<Integer>create(fluxSink -> {
                    for (int i = 1; i < 3; i++) {
                        log.info("Generando: {}", i);
                        fluxSink.next(i);
                    }
                    fluxSink.complete();
                })
                .subscribeOn(Schedulers.parallel())
                .doOnNext(value -> log.info("value: {}", value))
                .doFirst(() -> log.info("first-1"))
                .subscribeOn(Schedulers.boundedElastic())
                .doFirst(() -> log.info("first-2"));

        flux.subscribe(Util.subscriber());

        Util.sleepSeconds(2);
    }
}
````

### Revisando el c√≥digo

1. `Flux y su fuente`: El `Flux.create` es donde se genera la secuencia de datos. En este caso, se generan dos valores,
   1 y 2.


2. Primer `subscribeOn(Schedulers.parallel())`: Este es el primer `subscribeOn`, y afecta al `Publisher`. Esto indica
   que la creaci√≥n de los valores se ejecutar√° en un `Scheduler paralelo`.
    - Esto es evidente en el log: `Generando: 1` y `Generando: 2`, los cuales se est√°n ejecutando en un hilo
      `parallel-1`, que es un hilo del `Schedulers.parallel()`.


3. Segundo `subscribeOn(Schedulers.boundedElastic())`: Aunque este `subscribeOn` aparece despu√©s en el pipeline, no
   tiene efecto. El primer `subscribeOn` (en `Schedulers.parallel()`) se encarga de todo el trabajo, porque es el que
   est√° m√°s cercano a la fuente del flujo.


4. Ejecuci√≥n de `doFirst`: Se ejecuta `doFirst` antes de cada emisi√≥n, y es por eso que vemos los logs `first-1` y
   `first-2`. Estas son las acciones que se ejecutan justo antes de la ejecuci√≥n de la primera emisi√≥n (antes de
   procesar el primer elemento).

````bash
17:02:18.148 INFO  [           main] m.a.s.Lec03MultipleSubscribeOn : first-2
17:02:18.154 INFO  [oundedElastic-1] m.a.s.Lec03MultipleSubscribeOn : first-1
17:02:18.162 INFO  [     parallel-1] m.a.s.Lec03MultipleSubscribeOn : Generando: 1
17:02:18.163 INFO  [     parallel-1] m.a.s.Lec03MultipleSubscribeOn : value: 1
17:02:18.163 INFO  [     parallel-1] d.m.a.common.DefaultSubscriber :  recibido: 1
17:02:18.164 INFO  [     parallel-1] m.a.s.Lec03MultipleSubscribeOn : Generando: 2
17:02:18.164 INFO  [     parallel-1] m.a.s.Lec03MultipleSubscribeOn : value: 2
17:02:18.164 INFO  [     parallel-1] d.m.a.common.DefaultSubscriber :  recibido: 2
17:02:18.167 INFO  [     parallel-1] d.m.a.common.DefaultSubscriber :  ¬°completado!
````

1. El log muestra que el primer `subscribeOn` (paralelo) `hace el trabajo de generar y procesar los valores`.
2. El segundo `subscribeOn` no tiene impacto, como se esperaba, porque es el primero el que controla el flujo de
   trabajo.
3. El orden de los logs confirma que la secuencia sigue la `regla de prioridad del primer` `subscribeOn`.

> El `subscribeOn` m√°s cercano al `Publisher` (en este caso, el que se usa en `Flux.create`) es el que controla
> el `Scheduler` en el que se ejecutan las operaciones. El segundo `subscribeOn` se ignora y no tiene efecto.

## Scheduler - Virtual Thread

Los `Virtual Threads` son una nueva caracter√≠stica introducida en `Java 21` (como parte de `Project Loom`) que permite
crear `hilos livianos gestionados por la JVM`, `no por el sistema operativo`. Esto trae ventajas clave:

- Se pueden crear `miles o millones` de `hilos virtuales` sin agotar los recursos del sistema.
- Son ideales para aplicaciones `concurrentes y reactivas`, donde hay muchas tareas que esperan (por ejemplo, llamadas a
  base de datos o servicios externos).
- A diferencia de los `hilos tradicionales` (`plataforma` o `carrier threads`), los `virtual threads` son m√°s baratos
  de crear y m√°s eficientes.

Actualmente, `Reactor` soporta `Virtual Threads`, solo debemos habilitarlo utilizando el `System.setProperty`.
Este `System.setProperty` le indica a `Reactor` que cuando cree hilos en el `boundedElastic scheduler`, utilice
`virtual threads` en lugar de `hilos tradicionales`.

````java
public class Lec04VirtualThreads {

    private static final Logger log = LoggerFactory.getLogger(Lec04VirtualThreads.class);

    public static void main(String[] args) {
        System.setProperty("reactor.schedulers.defaultBoundedElasticOnVirtualThreads", "true");

        Flux<Integer> flux = Flux.<Integer>create(fluxSink -> {
                    for (int i = 1; i < 3; i++) {
                        log.info("Generando: {}", i);
                        fluxSink.next(i);
                    }
                    fluxSink.complete();
                })
                .doOnNext(value -> log.info("value: {}", value))
                .doFirst(() -> log.info("first-1-{}", Thread.currentThread().isVirtual()))
                .subscribeOn(Schedulers.boundedElastic())
                .doFirst(() -> log.info("first-2"));

        flux.subscribe(Util.subscriber());

        Util.sleepSeconds(2);
    }
}
````

Al ejecutar la aplicaci√≥n vemos dentro del resultado el valor `first-1-true`. Esto confirma que el hilo que ejecut√≥ esa
parte del flujo es `virtual`, porque `Thread.currentThread().isVirtual()` devolvi√≥ `true`.

````bash
17:40:24.332 INFO  [           main] d.m.a.s.Lec04VirtualThreads    : first-2
17:40:24.345 INFO  [oundedElastic-1] d.m.a.s.Lec04VirtualThreads    : first-1-true
17:40:24.352 INFO  [oundedElastic-1] d.m.a.s.Lec04VirtualThreads    : Generando: 1
17:40:24.353 INFO  [oundedElastic-1] d.m.a.s.Lec04VirtualThreads    : value: 1
17:40:24.353 INFO  [oundedElastic-1] d.m.a.common.DefaultSubscriber :  recibido: 1
17:40:24.353 INFO  [oundedElastic-1] d.m.a.s.Lec04VirtualThreads    : Generando: 2
17:40:24.353 INFO  [oundedElastic-1] d.m.a.s.Lec04VirtualThreads    : value: 2
17:40:24.353 INFO  [oundedElastic-1] d.m.a.common.DefaultSubscriber :  recibido: 2
17:40:24.356 INFO  [oundedElastic-1] d.m.a.common.DefaultSubscriber :  ¬°completado!
````

üß† ¬øQu√© significa esto para ti como desarrollador?

- Sin cambiar nada del c√≥digo reactor existente, puedes empezar a usar hilos virtuales.
- Mejora la eficiencia de uso de memoria y CPU, sobre todo en cargas pesadas.
- No necesitas preocuparte por el manejo complejo de pools de hilos.

## PublishOn

En programaci√≥n reactiva con Reactor, la ejecuci√≥n de una secuencia de eventos puede dividirse en distintos hilos, y el
operador `publishOn` es una herramienta clave para lograr eso.

El operador `publishOn` cambia el hilo en el que se ejecutan los operadores posteriores a partir del punto donde se
invoca. Es decir, redirige el flujo de ejecuci√≥n a un `Scheduler` diferente a partir de ese momento.

Cuando decimos que `publishOn` cambia el hilo de ejecuci√≥n de los operadores posteriores, nos referimos a los operadores
que est√°n aguas abajo, es decir, en direcci√≥n hacia el `Subscriber`, no hacia el `Publisher`.

### üîÑ Direcci√≥n del cambio de hilo:

- El cambio de hilo ocurre a partir del `publishOn` hacia el `Subscriber`, es decir, afecta todos los operadores que
  vienen despu√©s en la cadena.
- Los operadores que se encuentran antes del `publishOn` siguen ejecut√°ndose en el hilo original (por ejemplo, el hilo
  principal si es un flujo s√≠ncrono).

![04.png](assets/section-07/04.png)
