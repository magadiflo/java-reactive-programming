# Sección 9: Combinando Publicadores

---

## Introducción

La `Programación Reactiva` en Java implica trabajar con flujos de datos de forma asíncrona. A menudo, es necesario
combinar datos de múltiples fuentes o `publishers` para lograr el resultado deseado. Comprender cómo integrar estos
`publishers` eficientemente puede mejorar la flexibilidad y la escalabilidad de la aplicación.

Exploremos los operadores utilizados para combinar `publishers`, sus casos de uso y ejemplos.

- startWith
- concat
- merge
- zip
- flatMap
- concatMap

## StartWith

El operador `startWith` permite anteponer uno o más elementos o incluso otro `Publisher` al inicio de un flujo (`Flux`
o `Mono`). Es útil cuando queremos que el flujo comience con ciertos valores antes de emitir los elementos principales
provenientes de otra fuente.

Imaginemos que tenemos dos `Publisher`, ambos emiten elementos del mismo tipo `T` (por ejemplo, un `Flux<Integer>`, un
`Flux<Client>,` etc.). Al usar el operador `startWith`, podemos combinar estos dos `publishers` en un único flujo
reactivo, de modo que, desde la perspectiva del `Subscriber`, parecerá que se ha suscrito a un solo `Publisher<T>`.

El comportamiento clave de `startWith` es que los elementos pasados como argumento (ya sean valores individuales o un
`Publisher`) `se emitirán antes` que los elementos `del flujo original`.

El operador `startWith` se utiliza para anteponer elementos al inicio de una secuencia. Esto resulta útil cuando
se desea garantizar que algunos `datos iniciales se emitan antes del flujo de datos principal`.

![01.png](assets/section-09/01.png)

### Ejemplo conceptual

Imagine que tiene un flujo de lecturas de temperatura diarias, pero desea anteponer un mensaje de
`Inicio de lecturas de temperatura` al flujo:

````java
public static void main(String[] args) {
    Flux<String> flujoPrincipal = Flux.just("28°C", "30°C", "31°C");
    Flux<String> flujoFinal = flujoPrincipal.startWith("Temperature Readings Start");

    flujoFinal.subscribe(System.out::println);
}
````

La salida sería.

````bash
Temperature Readings Start
28°C
30°C
31°C
````

### Consideraciones

- `startWith` no es un operador de fallback (es decir, no entra en acción cuando el primer flujo no tiene suficientes
  elementos, como podría malinterpretarse).
- Su función principal es `anteponer datos`, no completarlos.
- Si necesitas manejar situaciones donde el primer `Publisher` no emite suficientes elementos, deberías considerar
  operadores como `concatWith`, `switchIfEmpty`, etc.

### Ejemplo

Veamos un ejemplo práctico del operador `startWith`:

````java
public class Lec01StartWith {

    private static final Logger log = LoggerFactory.getLogger(Lec01StartWith.class);

    public static void main(String[] args) {
        producer1()
                .startWith(0, 1, 2, 3)
                .subscribe(Util.subscriber());

        Util.sleepSeconds(3);
    }

    private static Flux<Integer> producer1() {
        return Flux.just(4, 5, 6)
                .doOnSubscribe(subscription -> log.info("Subscribiendo al producer1"))
                .delayElements(Duration.ofMillis(10));
    }
}
````

### Explicación

1. Se define un `Flux<Integer>` en el método `producer1()` que emite los valores `4, 5 y 6`.
2. Luego, usamos el operador `.startWith(0, 1, 2, 3)` para anteponer los valores `0, 1, 2, y 3` al inicio del flujo.
3. El `Subscriber` recibirá todos los elementos en el siguiente orden: `0, 1, 2, 3, 4, 5, 6`.

El operador `doOnSubscribe` se ejecuta cuando se produce la suscripción al `Flux original (producer1())`, lo cual
ocurre después de que se emiten los elementos pasados a `startWith`.

````bash
12:28:13.911 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 0
12:28:13.913 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 1
12:28:13.913 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 2
12:28:13.913 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 3
12:28:13.915 INFO  [           main] d.m.app.sec09.Lec01StartWith   : Subscribiendo al producer1
12:28:13.939 INFO  [     parallel-1] d.m.a.common.DefaultSubscriber :  recibido: 4
12:28:13.954 INFO  [     parallel-2] d.m.a.common.DefaultSubscriber :  recibido: 5
12:28:13.970 INFO  [     parallel-3] d.m.a.common.DefaultSubscriber :  recibido: 6
12:28:13.972 INFO  [     parallel-3] d.m.a.common.DefaultSubscriber :  ¡completado!
````

### Observaciones

- El `startWith` emite sus valores antes de que se realice la suscripción al `Flux original`.
- La línea `Subscribiendo al producer1` aparece después de la emisión de `0 a 3`, lo que demuestra que el `producer1()`
  aún no había comenzado a emitir.
- Los elementos 4, 5, y 6 son emitidos con un pequeño retardo simulado, cada uno en un hilo diferente del Scheduler por
  defecto (debido al delayElements).

