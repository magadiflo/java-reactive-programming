# Secci√≥n 9: Combinando Publicadores

---

## Introducci√≥n

La `Programaci√≥n Reactiva` en Java implica trabajar con flujos de datos de forma as√≠ncrona. A menudo, es necesario
combinar datos de m√∫ltiples fuentes o `publishers` para lograr el resultado deseado. Comprender c√≥mo integrar estos
`publishers` eficientemente puede mejorar la flexibilidad y la escalabilidad de la aplicaci√≥n.

Exploremos los operadores utilizados para combinar `publishers`, sus casos de uso y ejemplos.

- startWith
- concat
- merge
- zip
- flatMap
- concatMap

## StartWith

El operador `startWith` permite anteponer uno o m√°s elementos o incluso otro `Publisher` al inicio de un flujo (`Flux`
o `Mono`). Es √∫til cuando queremos que el flujo comience con ciertos valores antes de emitir los elementos principales
provenientes de otra fuente.

Imaginemos que tenemos dos `Publisher`, ambos emiten elementos del mismo tipo `T` (por ejemplo, un `Flux<Integer>`, un
`Flux<Client>,` etc.). Al usar el operador `startWith`, podemos combinar estos dos `publishers` en un √∫nico flujo
reactivo, de modo que, desde la perspectiva del `Subscriber`, parecer√° que se ha suscrito a un solo `Publisher<T>`.

El comportamiento clave de `startWith` es que los elementos pasados como argumento (ya sean valores individuales o un
`Publisher`) `se emitir√°n antes` que los elementos `del flujo original`.

El operador `startWith` se utiliza para anteponer elementos al inicio de una secuencia. Esto resulta √∫til cuando
se desea garantizar que algunos `datos iniciales se emitan antes del flujo de datos principal`.

![01.png](assets/section-09/01.png)

### Ejemplo conceptual

Imagine que tiene un flujo de lecturas de temperatura diarias, pero desea anteponer un mensaje de
`Inicio de lecturas de temperatura` al flujo:

````java
public static void main(String[] args) {
    Flux<String> flujoPrincipal = Flux.just("28¬∞C", "30¬∞C", "31¬∞C");
    Flux<String> flujoFinal = flujoPrincipal.startWith("Temperature Readings Start");

    flujoFinal.subscribe(System.out::println);
}
````

La salida ser√≠a.

````bash
Temperature Readings Start
28¬∞C
30¬∞C
31¬∞C
````

### Consideraciones

- `startWith` no es un operador de fallback (es decir, no entra en acci√≥n cuando el primer flujo no tiene suficientes
  elementos, como podr√≠a malinterpretarse).
- Su funci√≥n principal es `anteponer datos`, no completarlos.
- Si necesitas manejar situaciones donde el primer `Publisher` no emite suficientes elementos, deber√≠as considerar
  operadores como `concatWith`, `switchIfEmpty`, etc.

### Ejemplo

Veamos un ejemplo pr√°ctico del operador `startWith`:

````java
public class Lec01StartWith {

    private static final Logger log = LoggerFactory.getLogger(Lec01StartWith.class);

    public static void main(String[] args) {
        producer1()
                .startWith(0, 1, 2, 3)
                .subscribe(Util.subscriber());

        Util.sleepSeconds(3);
    }

    private static Flux<Integer> producer1() {
        return Flux.just(4, 5, 6)
                .doOnSubscribe(subscription -> log.info("Subscribiendo al producer1"))
                .delayElements(Duration.ofMillis(10));
    }
}
````

### Explicaci√≥n

1. Se define un `Flux<Integer>` en el m√©todo `producer1()` que emite los valores `4, 5 y 6`.
2. Luego, usamos el operador `.startWith(0, 1, 2, 3)` para anteponer los valores `0, 1, 2, y 3` al inicio del flujo.
3. El `Subscriber` recibir√° todos los elementos en el siguiente orden: `0, 1, 2, 3, 4, 5, 6`.

El operador `doOnSubscribe` se ejecuta cuando se produce la suscripci√≥n al `Flux original (producer1())`, lo cual
ocurre despu√©s de que se emiten los elementos pasados a `startWith`.

````bash
12:28:13.911 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 0
12:28:13.913 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 1
12:28:13.913 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 2
12:28:13.913 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 3
12:28:13.915 INFO  [           main] d.m.app.sec09.Lec01StartWith   : Subscribiendo al producer1
12:28:13.939 INFO  [     parallel-1] d.m.a.common.DefaultSubscriber :  recibido: 4
12:28:13.954 INFO  [     parallel-2] d.m.a.common.DefaultSubscriber :  recibido: 5
12:28:13.970 INFO  [     parallel-3] d.m.a.common.DefaultSubscriber :  recibido: 6
12:28:13.972 INFO  [     parallel-3] d.m.a.common.DefaultSubscriber :  ¬°completado!
````

### Observaciones

- El `startWith` emite sus valores antes de que se realice la suscripci√≥n al `Flux original`.
- La l√≠nea `Subscribiendo al producer1` aparece despu√©s de la emisi√≥n de `0 a 3`, lo que demuestra que el `producer1()`
  a√∫n no hab√≠a comenzado a emitir.
- Los elementos 4, 5, y 6 son emitidos con un peque√±o retardo simulado, cada uno en un hilo diferente del Scheduler por
  defecto (debido al delayElements).

## StartWith - Casos de uso

En aplicaciones reales, es com√∫n realizar c√°lculos costosos que deseamos evitar repetir constantemente. Para mejorar el
rendimiento, almacenamos los resultados en cach√© y los reutilizamos cuando sea posible. En este tipo de escenarios, el
operador `startWith` resulta √∫til para emitir primero los valores almacenados en cach√© antes de realizar c√°lculos
adicionales o acceder a una fuente de datos m√°s costosa.

> ‚ö†Ô∏è En este ejemplo usamos una lista local como cach√©, pero en una aplicaci√≥n real, una tecnolog√≠a como `Redis` ser√≠a
> una mejor opci√≥n para gestionar cach√© de forma eficiente.

### Ejemplo: Generador de nombres con cach√©

````java
public class NameGenerator {

    private static final Logger log = LoggerFactory.getLogger(NameGenerator.class);
    private final List<String> redis = new ArrayList<>();

    public Flux<String> generateNames() {
        return Flux.generate(synchronousSink -> {
                    log.info("generando nombre");
                    Util.sleepSeconds(1);

                    String name = Util.faker().name().firstName();
                    this.redis.add("[cach√©] " + name);
                    synchronousSink.next(name);
                })
                .startWith(this.redis)
                .cast(String.class);
    }
}
````

La clase `NameGenerator` simula un flujo que genera nombres aleatorios usando `Flux.generate()`. Cada vez que se genera
un nuevo nombre, se agrega a una lista que act√∫a como `cach√© simulada` (`redis`).

El punto clave est√° en esta l√≠nea: `.startWith(this.redis)`.

Con `startWith`, antes de emitir los nuevos nombres generados, el `Flux` primero emite los valores que ya est√°n en
cach√© (es decir, los elementos de la lista redis). Esto permite que los suscriptores reciban primero los datos
almacenados, y luego los nuevos si son necesarios.

> üí° `Ventaja`: cuando un nuevo suscriptor se conecta, puede acceder r√°pidamente a datos previos sin esperar a que se
> generen de nuevo, lo cual simula el comportamiento t√≠pico de una cach√©.

````java
public class Lec02StartWithUseCase {

    private static final Logger log = LoggerFactory.getLogger(Lec02StartWithUseCase.class);

    public static void main(String[] args) {
        NameGenerator nameGenerator = new NameGenerator();

        nameGenerator.generateNames()
                .take(2)
                .subscribe(Util.subscriber("sam"));

        nameGenerator.generateNames()
                .take(2)
                .subscribe(Util.subscriber("mike"));

        nameGenerator.generateNames()
                .take(3)
                .subscribe(Util.subscriber("jake"));
    }
}
````

1. En la primera llamada (`sam`), no hay elementos en cach√©, por lo tanto, se generan nuevos nombres y se agregan a la
   lista `redis`.
2. En la segunda llamada (`mike`), el operador `startWith` emite primero los nombres almacenados en cach√©.
3. En la tercera llamada (`jake`), se emiten primero los datos en cach√© y luego se genera un nuevo nombre adicional.

Este patr√≥n es √∫til cuando deseamos `precargar datos almacenados` antes de acceder a una fuente din√°mica o costosa.

````bash
13:08:52.450 INFO  [           main] d.m.a.s.helper.NameGenerator   : generando nombre
13:08:53.581 INFO  [           main] d.m.a.common.DefaultSubscriber : sam recibido: Sun
13:08:53.581 INFO  [           main] d.m.a.s.helper.NameGenerator   : generando nombre
13:08:54.585 INFO  [           main] d.m.a.common.DefaultSubscriber : sam recibido: Bert
13:08:54.585 INFO  [           main] d.m.a.common.DefaultSubscriber : sam ¬°completado!

13:08:54.585 INFO  [           main] d.m.a.common.DefaultSubscriber : mike recibido: [cach√©] Sun
13:08:54.585 INFO  [           main] d.m.a.common.DefaultSubscriber : mike recibido: [cach√©] Bert
13:08:54.585 INFO  [           main] d.m.a.common.DefaultSubscriber : mike ¬°completado!

13:08:54.585 INFO  [           main] d.m.a.common.DefaultSubscriber : jake recibido: [cach√©] Sun
13:08:54.585 INFO  [           main] d.m.a.common.DefaultSubscriber : jake recibido: [cach√©] Bert
13:08:54.585 INFO  [           main] d.m.a.s.helper.NameGenerator   : generando nombre
13:08:55.595 INFO  [           main] d.m.a.common.DefaultSubscriber : jake recibido: Joel
13:08:55.595 INFO  [           main] d.m.a.common.DefaultSubscriber : jake ¬°completado!
````

## ConcatWith

El operador `concatWith` funciona como el opuesto del operador `startWith`. Su comportamiento consiste en emitir primero
todos los elementos del `publisher original`, y una vez que este se completa, pasa a emitir los elementos del
`publisher que se le concatena`.

Esto significa que `concatWith` `combina dos publishers de forma secuencial`, respetando el orden de emisi√≥n:
primero uno, luego el otro. Es importante destacar que el segundo publisher no se suscribir√° hasta que el primero
haya enviado la se√±al de `completado`. Esto garantiza un flujo de datos estrictamente ordenado.

> üìå Este comportamiento es √∫til cuando queremos asegurar que los elementos de un flujo se procesen completamente antes
> de continuar con otro conjunto de datos.

![02.png](assets/section-09/02.png)

### Ejemplo 1

En este ejemplo se usa el m√©todo `.concatWithValues(...)`, que permite concatenar un `Flux` con valores individuales
directamente.

````java
public class Lec03ConcatWith {

    private static final Logger log = LoggerFactory.getLogger(Lec03ConcatWith.class);

    public static void main(String[] args) {
        demo1();
        Util.sleepSeconds(3);
    }

    private static void demo1() {
        producer1()
                .concatWithValues(6, 8, 10)
                .subscribe(Util.subscriber());
    }

    private static Flux<Integer> producer1() {
        return Flux.just(1, 2, 3)
                .doOnSubscribe(subscription -> log.info("Subscribiendo al producer1"))
                .delayElements(Duration.ofMillis(10));
    }
}
````

Como se observa en la salida, primero se emiten los elementos del `producer1()`, y una vez que este flujo se completa,
se emiten los valores adicionales definidos en `.concatWithValues(6, 8, 10)`.

````bash
15:28:20.442 INFO  [           main] d.m.app.sec09.Lec03ConcatWith  : Subscribiendo al producer1
15:28:20.467 INFO  [     parallel-1] d.m.a.common.DefaultSubscriber :  recibido: 1
15:28:20.483 INFO  [     parallel-2] d.m.a.common.DefaultSubscriber :  recibido: 2
15:28:20.499 INFO  [     parallel-3] d.m.a.common.DefaultSubscriber :  recibido: 3
15:28:20.499 INFO  [     parallel-3] d.m.a.common.DefaultSubscriber :  recibido: 6
15:28:20.499 INFO  [     parallel-3] d.m.a.common.DefaultSubscriber :  recibido: 8
15:28:20.499 INFO  [     parallel-3] d.m.a.common.DefaultSubscriber :  recibido: 10
15:28:20.502 INFO  [     parallel-3] d.m.a.common.DefaultSubscriber :  ¬°completado!
````

### Ejemplo 2

En este segundo ejemplo usamos el operador `concatWith(...)` para concatenar un `Flux` con otro `Flux`, es decir,
dos publishers completos. A diferencia del primer ejemplo donde se usaban valores individuales, aqu√≠ ambos flujos
tienen su propia l√≥gica de producci√≥n y suscripciones.

````java
public class Lec03ConcatWith {

    private static final Logger log = LoggerFactory.getLogger(Lec03ConcatWith.class);

    public static void main(String[] args) {
        demo2();
        Util.sleepSeconds(3);
    }

    private static void demo2() {
        producer1()
                .concatWith(producer2())
                .subscribe(Util.subscriber());
    }

    private static Flux<Integer> producer1() {
        return Flux.just(1, 2, 3)
                .doOnSubscribe(subscription -> log.info("Subscribiendo al producer1"))
                .delayElements(Duration.ofMillis(10));
    }

    private static Flux<Integer> producer2() {
        return Flux.just(40, 50, 60)
                .doOnSubscribe(subscription -> log.info("Subscribiendo al producer2"))
                .delayElements(Duration.ofMillis(10));
    }
}
````

La clave del comportamiento est√° en que `concatWith` espera a que el primer flujo (`producer1`) se complete antes de
suscribirse al segundo (`producer2`). Esto garantiza que los datos se emitan en el orden correcto sin entrelazarse,
incluso si ambos flujos introducen demoras (`delayElements`).

````bash
15:30:39.925 INFO  [           main] d.m.app.sec09.Lec03ConcatWith  : Subscribiendo al producer1
15:30:39.948 INFO  [     parallel-1] d.m.a.common.DefaultSubscriber :  recibido: 1
15:30:39.964 INFO  [     parallel-2] d.m.a.common.DefaultSubscriber :  recibido: 2
15:30:39.980 INFO  [     parallel-3] d.m.a.common.DefaultSubscriber :  recibido: 3
15:30:39.980 INFO  [     parallel-3] d.m.app.sec09.Lec03ConcatWith  : Subscribiendo al producer2
15:30:39.995 INFO  [     parallel-4] d.m.a.common.DefaultSubscriber :  recibido: 40
15:30:40.011 INFO  [     parallel-5] d.m.a.common.DefaultSubscriber :  recibido: 50
15:30:40.026 INFO  [     parallel-6] d.m.a.common.DefaultSubscriber :  recibido: 60
15:30:40.029 INFO  [     parallel-6] d.m.a.common.DefaultSubscriber :  ¬°completado!
````

### Ejemplo 3

En este ejemplo se usa el operador de f√°brica `Flux.concat(...)` para concatenar dos publishers, estos se ejecutar√°n
de manera secuencial, tal cual fueron definidos. En nuestro ejemplo, primero se emitir√°n los elementos del `producer1()`
y a continuaci√≥n los elementos del `producer2()`.

````java
public class Lec03ConcatWith {

    private static final Logger log = LoggerFactory.getLogger(Lec03ConcatWith.class);

    public static void main(String[] args) {
        demo3();
        Util.sleepSeconds(3);
    }

    private static void demo3() {
        Flux.concat(producer1(), producer2())
                .subscribe(Util.subscriber());
    }

    private static Flux<Integer> producer1() {
        return Flux.just(1, 2, 3)
                .doOnSubscribe(subscription -> log.info("Subscribiendo al producer1"))
                .delayElements(Duration.ofMillis(10));
    }

    private static Flux<Integer> producer2() {
        return Flux.just(40, 50, 60)
                .doOnSubscribe(subscription -> log.info("Subscribiendo al producer2"))
                .delayElements(Duration.ofMillis(10));
    }
}

````

El resultado es similar a lo que hemos visto anteriormente.

````bash
15:33:01.034 INFO  [           main] d.m.app.sec09.Lec03ConcatWith  : Subscribiendo al producer1
15:33:01.066 INFO  [     parallel-1] d.m.a.common.DefaultSubscriber :  recibido: 1
15:33:01.081 INFO  [     parallel-2] d.m.a.common.DefaultSubscriber :  recibido: 2
15:33:01.097 INFO  [     parallel-3] d.m.a.common.DefaultSubscriber :  recibido: 3
15:33:01.097 INFO  [     parallel-3] d.m.app.sec09.Lec03ConcatWith  : Subscribiendo al producer2
15:33:01.113 INFO  [     parallel-4] d.m.a.common.DefaultSubscriber :  recibido: 40
15:33:01.129 INFO  [     parallel-5] d.m.a.common.DefaultSubscriber :  recibido: 50
15:33:01.144 INFO  [     parallel-6] d.m.a.common.DefaultSubscriber :  recibido: 60
15:33:01.147 INFO  [     parallel-6] d.m.a.common.DefaultSubscriber :  ¬°completado!
````

> üí° Todos estos enfoques garantizan un flujo ordenado, en el cual no se mezcla la emisi√≥n de elementos de los
> publishers involucrados.

Esto es √∫til cuando:

- Necesitas mantener un orden espec√≠fico en la emisi√≥n.
- El segundo flujo depende de la finalizaci√≥n del primero.
- Est√°s combinando datos que deben procesarse en secuencia, como pasos en un pipeline.

## ConcatDelayError

El operador `concatDelayError` es similar a `concatWith` o `Flux.concat`, con una diferencia clave: *retrasa la emisi√≥n
de errores hasta que todos los publishers hayan sido procesados.* Es √∫til cuando se desea garantizar que todos los
flujos de datos sean evaluados, incluso si uno o m√°s fallan.

````java
public class Lec04ConcatDelayError {

    private static final Logger log = LoggerFactory.getLogger(Lec04ConcatDelayError.class);

    public static void main(String[] args) {
        demo1();
        Util.sleepSeconds(3);
    }

    private static void demo1() {
        Flux.concatDelayError(producer1(), producer3(), producer2())
                .subscribe(Util.subscriber());

    }

    private static Flux<Integer> producer1() {
        return Flux.just(1, 2, 3)
                .doOnSubscribe(subscription -> log.info("Subscribiendo al producer1"))
                .delayElements(Duration.ofMillis(10));
    }

    private static Flux<Integer> producer2() {
        return Flux.just(40, 50, 60)
                .doOnSubscribe(subscription -> log.info("Subscribiendo al producer2"))
                .delayElements(Duration.ofMillis(10));
    }

    private static Flux<Integer> producer3() {
        return Flux.error(new RuntimeException("Error en el producer3"));
    }
}
````

Aunque el error se produce en `producer3()`, su emisi√≥n se retrasa hasta que los dem√°s publishers (`producer1()` y
`producer2()`) hayan completado su flujo. Solo entonces se lanza el error al suscriptor.

````bash
16:22:51.367 INFO  [           main] d.m.a.s.Lec04ConcatDelayError  : Subscribiendo al producer1
16:22:51.398 INFO  [     parallel-1] d.m.a.common.DefaultSubscriber :  recibido: 1
16:22:51.414 INFO  [     parallel-2] d.m.a.common.DefaultSubscriber :  recibido: 2
16:22:51.430 INFO  [     parallel-3] d.m.a.common.DefaultSubscriber :  recibido: 3
16:22:51.433 INFO  [     parallel-3] d.m.a.s.Lec04ConcatDelayError  : Subscribiendo al producer2
16:22:51.446 INFO  [     parallel-4] d.m.a.common.DefaultSubscriber :  recibido: 40
16:22:51.462 INFO  [     parallel-5] d.m.a.common.DefaultSubscriber :  recibido: 50
16:22:51.478 INFO  [     parallel-6] d.m.a.common.DefaultSubscriber :  recibido: 60
16:22:51.478 ERROR [     parallel-6] d.m.a.common.DefaultSubscriber :  error: Error en el producer3
````

## Merge

El operador `merge` combina m√∫ltiples `publishers` en un √∫nico flujo (`Flux`), emitiendo los elementos a medida que son
producidos. Esto permite el procesamiento en paralelo de los datos emitidos por cada `publisher`.

Imaginemos que tenemos tres productores: `producer1`, `producer2` y `producer3`. En lugar de que el `subscriber` se
suscriba a cada uno por separado, podemos utilizar `merge` para fusionarlos en un solo `publisher`. As√≠, el `subscriber`
se suscribe a todos los productores al mismo tiempo, como si fueran uno solo.

El orden en que los elementos se emiten depender√° del momento en que cada productor los genere. Por ejemplo, si
`producer3` emite un valor antes que los dem√°s, ese ser√° el primer valor recibido por el `subscriber`. Luego, si
`producer1` emite otro valor, este ser√° el siguiente en ser procesado, y as√≠ sucesivamente.

> En resumen: `no hay un orden garantizado`. Dado que todos los publishers est√°n activos simult√°neamente, el orden de
> los elementos ser√° el que resulte del momento en que se produzcan. Adem√°s, si se cancela la suscripci√≥n, se cancelan
> todos los publishers de manera conjunta.

![03.png](assets/section-09/03.png)

En el siguiente ejemplo usamos `Flux.merge(...)` para fusionar los tres `publishers`. Es importante notar que el orden
en que se pasan como par√°metros (`Flux.merge(producer1(), producer2(), producer3())`) no influye en el orden de emisi√≥n,
ya que todos se suscriben simult√°neamente:

````java

public class Lec05Merge {

    private static final Logger log = LoggerFactory.getLogger(Lec05Merge.class);

    public static void main(String[] args) {
        Flux.merge(producer1(), producer2(), producer3())
                .subscribe(Util.subscriber());

        Util.sleepSeconds(3);
    }

    private static Flux<Integer> producer1() {
        return Flux.just(1, 2, 3)
                .doOnSubscribe(subscription -> log.info("Subscribiendo al producer1"))
                .delayElements(Duration.ofMillis(10));
    }

    private static Flux<Integer> producer2() {
        return Flux.just(40, 50, 60)
                .doOnSubscribe(subscription -> log.info("Subscribiendo al producer2"))
                .delayElements(Duration.ofMillis(10));
    }

    private static Flux<Integer> producer3() {
        return Flux.just(100, 101, 102)
                .doOnSubscribe(subscription -> log.info("Subscribiendo al producer3"))
                .delayElements(Duration.ofMillis(10));
    }
}
````

Si ejecutamos la aplicaci√≥n vemos c√≥mo el subscriber est√° recibiendo los valores sin un orden en espec√≠fico.

````bash
20:54:33.736 INFO  [           main] d.m.app.sec09.Lec05Merge       : Subscribiendo al producer1
20:54:33.742 INFO  [           main] d.m.app.sec09.Lec05Merge       : Subscribiendo al producer2
20:54:33.742 INFO  [           main] d.m.app.sec09.Lec05Merge       : Subscribiendo al producer3
20:54:33.761 INFO  [     parallel-1] d.m.a.common.DefaultSubscriber :  recibido: 1
20:54:33.764 INFO  [     parallel-3] d.m.a.common.DefaultSubscriber :  recibido: 40
20:54:33.764 INFO  [     parallel-3] d.m.a.common.DefaultSubscriber :  recibido: 100
20:54:33.776 INFO  [     parallel-5] d.m.a.common.DefaultSubscriber :  recibido: 50
20:54:33.776 INFO  [     parallel-5] d.m.a.common.DefaultSubscriber :  recibido: 2
20:54:33.776 INFO  [     parallel-5] d.m.a.common.DefaultSubscriber :  recibido: 101
20:54:33.792 INFO  [     parallel-1] d.m.a.common.DefaultSubscriber :  recibido: 60
20:54:33.792 INFO  [     parallel-1] d.m.a.common.DefaultSubscriber :  recibido: 3
20:54:33.792 INFO  [     parallel-1] d.m.a.common.DefaultSubscriber :  recibido: 102
20:54:33.795 INFO  [     parallel-1] d.m.a.common.DefaultSubscriber :  ¬°completado!
````

Si volvemos a ejecutar la aplicaci√≥n se puede observar que `el orden de los elementos var√≠a en cada ejecuci√≥n`,
dependiendo de c√≥mo y cu√°ndo cada productor emite sus elementos.

````bash
20:57:25.747 INFO  [           main] d.m.app.sec09.Lec05Merge       : Subscribiendo al producer1
20:57:25.755 INFO  [           main] d.m.app.sec09.Lec05Merge       : Subscribiendo al producer2
20:57:25.756 INFO  [           main] d.m.app.sec09.Lec05Merge       : Subscribiendo al producer3
20:57:25.777 INFO  [     parallel-3] d.m.a.common.DefaultSubscriber :  recibido: 100
20:57:25.779 INFO  [     parallel-1] d.m.a.common.DefaultSubscriber :  recibido: 1
20:57:25.779 INFO  [     parallel-1] d.m.a.common.DefaultSubscriber :  recibido: 40
20:57:25.792 INFO  [     parallel-5] d.m.a.common.DefaultSubscriber :  recibido: 50
20:57:25.792 INFO  [     parallel-5] d.m.a.common.DefaultSubscriber :  recibido: 2
20:57:25.792 INFO  [     parallel-5] d.m.a.common.DefaultSubscriber :  recibido: 101
20:57:25.808 INFO  [     parallel-7] d.m.a.common.DefaultSubscriber :  recibido: 3
20:57:25.808 INFO  [     parallel-7] d.m.a.common.DefaultSubscriber :  recibido: 60
20:57:25.808 INFO  [     parallel-7] d.m.a.common.DefaultSubscriber :  recibido: 102
20:57:25.810 INFO  [     parallel-7] d.m.a.common.DefaultSubscriber :  ¬°completado!
````

### Reutilizaci√≥n de l√≥gica con `UnaryOperator<Flux<T>>` y `transform()`

Antes de continuar con m√°s ejemplos del operador `merge`, vamos a refactorizar el c√≥digo para evitar repeticiones
innecesarias. Crearemos un m√©todo gen√©rico que nos permita aplicar de forma reutilizable operadores como `.doOn...`,
que son √∫tiles para observar el ciclo de vida de un `Flux`.

### ¬øQu√© es UnaryOperator<Flux<T>>?

`UnaryOperator<Flux<T>>` es una especializaci√≥n de `Function<T, T>` cuando el tipo de entrada y de salida es el
mismo (en este caso, `Flux<T>`). Representa una operaci√≥n sobre un √∫nico operando que produce un resultado del
mismo tipo. Es una `interfaz funcional` cuyo m√©todo principal es `apply(Object)`.

### Implementaci√≥n del m√©todo gen√©rico

En nuestra clase `Util`, ubicada en el paquete `common`, agregamos el siguiente m√©todo:

````java
public class Util {
    private static final Logger log = LoggerFactory.getLogger(Util.class);

    /* other code */
    public static <T> UnaryOperator<Flux<T>> fluxLogger(String name) {
        return flux -> flux
                .doOnSubscribe(subscription -> log.info("Subscribiendo al {}", name))
                .doOnCancel(() -> log.info("Cancelando {}", name))
                .doOnComplete(() -> log.info("{} completado", name));
    }
}
````

### Aplicaci√≥n con transform()

El operador `transform()` nos permite aplicar funciones de transformaci√≥n a un `Flux`. Si necesitamos aplicar una misma
cadena de operadores en varios lugares, podemos encapsular dicha l√≥gica en una funci√≥n (como `fluxLogger`) y
reutilizarla f√°cilmente.

````java
public class Lec05Merge {

    private static final Logger log = LoggerFactory.getLogger(Lec05Merge.class);

    public static void main(String[] args) {
        Flux.merge(producer1(), producer2(), producer3()) // Como nos subscribimos a todos estos publishers al mismo tiempo, el orden en el que se coloca no importa
                .take(2)
                .subscribe(Util.subscriber());

        Util.sleepSeconds(3);
    }

    private static Flux<Integer> producer1() {
        return Flux.just(1, 2, 3)
                .transform(Util.fluxLogger("producer1"))    //<--- Se agreg√≥
                .delayElements(Duration.ofMillis(10));
    }

    private static Flux<Integer> producer2() {
        return Flux.just(40, 50, 60)
                .transform(Util.fluxLogger("producer2"))    //<--- Se agreg√≥
                .delayElements(Duration.ofMillis(10));
    }

    private static Flux<Integer> producer3() {
        return Flux.just(100, 101, 102)
                .transform(Util.fluxLogger("producer3"))    //<--- Se agreg√≥
                .delayElements(Duration.ofMillis(10));
    }
}
````

Como observamos en el resultado, todos los `producers` se han suscrito al mismo tiempo. Luego, el `subscriber` toma
dos elementos y se cancelan los flujos restantes simult√°neamente.

````bash
10:55:42.484 INFO  [           main] dev.magadiflo.app.common.Util  : Subscribiendo al producer1
10:55:42.492 INFO  [           main] dev.magadiflo.app.common.Util  : Subscribiendo al producer2
10:55:42.492 INFO  [           main] dev.magadiflo.app.common.Util  : Subscribiendo al producer3
10:55:42.511 INFO  [     parallel-2] d.m.a.common.DefaultSubscriber :  recibido: 40
10:55:42.513 INFO  [     parallel-3] d.m.a.common.DefaultSubscriber :  recibido: 1
10:55:42.516 INFO  [     parallel-3] d.m.a.common.DefaultSubscriber :  ¬°completado!
10:55:42.517 INFO  [     parallel-3] dev.magadiflo.app.common.Util  : Cancelando producer1
10:55:42.517 INFO  [     parallel-3] dev.magadiflo.app.common.Util  : Cancelando producer2
10:55:42.517 INFO  [     parallel-3] dev.magadiflo.app.common.Util  : Cancelando producer3
````

> `Nota:` Aqu√≠ es importante destacar que la reutilizaci√≥n del c√≥digo mediante `transform()` est√° funcionando
> correctamente.

A continuaci√≥n se muestra otra manera de poder usar el `merge` y es usando el `mergeWith(...)`.

````java

public class Lec05Merge {

    private static final Logger log = LoggerFactory.getLogger(Lec05Merge.class);

    public static void main(String[] args) {
        demo2();
        Util.sleepSeconds(3);
    }

    private static void demo2() {
        producer1()
                .mergeWith(producer2())
                .mergeWith(producer3())
                .take(2)
                .subscribe(Util.subscriber());
    }

    private static Flux<Integer> producer1() {
        return Flux.just(1, 2, 3)
                .transform(Util.fluxLogger("producer1"))
                .delayElements(Duration.ofMillis(10));
    }

    private static Flux<Integer> producer2() {
        return Flux.just(40, 50, 60)
                .transform(Util.fluxLogger("producer2"))
                .delayElements(Duration.ofMillis(10));
    }

    private static Flux<Integer> producer3() {
        return Flux.just(100, 101, 102)
                .transform(Util.fluxLogger("producer3"))
                .delayElements(Duration.ofMillis(10));
    }
}
````

Con el resultado obtenido demostramos que `Flux.merge(...)` y `.mergeWith(...)` logran el mismo comportamiento
de suscripci√≥n simult√°nea a m√∫ltiples fuentes, es decir, ambos hacen exactamente lo mismo.

````bash
11:10:37.109 INFO  [           main] dev.magadiflo.app.common.Util  : Subscribiendo al producer1
11:10:37.118 INFO  [           main] dev.magadiflo.app.common.Util  : Subscribiendo al producer2
11:10:37.118 INFO  [           main] dev.magadiflo.app.common.Util  : Subscribiendo al producer3
11:10:37.136 INFO  [     parallel-2] d.m.a.common.DefaultSubscriber :  recibido: 40
11:10:37.139 INFO  [     parallel-3] d.m.a.common.DefaultSubscriber :  recibido: 1
11:10:37.142 INFO  [     parallel-3] d.m.a.common.DefaultSubscriber :  ¬°completado!
11:10:37.142 INFO  [     parallel-3] dev.magadiflo.app.common.Util  : Cancelando producer1
11:10:37.142 INFO  [     parallel-3] dev.magadiflo.app.common.Util  : Cancelando producer2
11:10:37.142 INFO  [     parallel-3] dev.magadiflo.app.common.Util  : Cancelando producer3
````

- `.mergeWith()` es √∫til cuando vamos encadenando productores de manera fluida.
- `Flux.merge(...)` es preferido si ya tenemos todos los flujos disponibles.

## Merge - Casos de uso

El siguiente ejemplo nos permitir√° simular una consulta de vuelos en m√∫ltiples aerol√≠neas, donde cada aerol√≠nea responde
de forma as√≠ncrona y en tiempos variables. El uso de `merge` permite `combinar los flujos de datos concurrentes` en una
sola secuencia.

Iniciamos creando el siguiente record.

````java
public record Flight(String airline,
                     Integer price) {
}
````

Ahora creamos las clases que representan clientes para llamar a un servicio remoto. Cada clase (`AmericanAirlines`,
`Emirates`, `Qatar`) emite un flujo de `Flight`, con retrasos simulados para representar la latencia real de llamadas a
servicios externos.

````java
public class AmericanAirlines {
    private static final String AIRLINE = "American Airlines";

    public static Flux<Flight> getFlights() {
        return Flux.range(1, Util.faker().random().nextInt(5, 10))
                .delayElements(Duration.ofMillis(Util.faker().random().nextInt(200, 1200)))
                .map(value -> new Flight(AIRLINE, Util.faker().random().nextInt(300, 1200)))
                .transform(Util.fluxLogger(AIRLINE));
    }
}
````

````java
public class Emirates {
    private static final String AIRLINE = "Emirates";

    public static Flux<Flight> getFlights() {
        return Flux.range(1, Util.faker().random().nextInt(2, 10))
                .delayElements(Duration.ofMillis(Util.faker().random().nextInt(200, 1000)))
                .map(value -> new Flight(AIRLINE, Util.faker().random().nextInt(300, 1000)))
                .transform(Util.fluxLogger(AIRLINE));
    }
}
````

````java
public class Qatar {
    private static final String AIRLINE = "Qatar";

    public static Flux<Flight> getFlights() {
        return Flux.range(1, Util.faker().random().nextInt(3, 5))
                .delayElements(Duration.ofMillis(Util.faker().random().nextInt(300, 800)))
                .map(value -> new Flight(AIRLINE, Util.faker().random().nextInt(400, 900)))
                .transform(Util.fluxLogger(AIRLINE));
    }
}
````

A continuaci√≥n creamos la clase que har√° el merge de las 3 clases cliente anteriores. `Flux.merge(...)` permite que los
elementos se emitan a medida que est√©n disponibles, sin importar el orden, lo que lo hace ideal para llamadas en
paralelo.

El `take(Duration.ofSeconds(2))` es muy √∫til cuando no queremos esperar indefinidamente a todos los proveedores, sino
trabajar con la informaci√≥n disponible en un tiempo l√≠mite. Este patr√≥n es com√∫n en sistemas que deben ofrecer
respuestas r√°pidas, como sistemas de reservas, agregadores de informaci√≥n, cotizadores, etc.

Una vez alcanzado el l√≠mite de tiempo (2 segundos), el `Subscriber` cancela autom√°ticamente los `Publisher` restantes,
lo que es importante para liberar recursos y evitar trabajo innecesario.

````java
public class FlightSearch {
    public static Flux<Flight> getFlights() {
        return Flux.merge(
                AmericanAirlines.getFlights(),
                Emirates.getFlights(),
                Qatar.getFlights()
        ).take(Duration.ofSeconds(2)); // Retransmite valores de este Flujo hasta que transcurra la Duraci√≥n especificada.
    }
}
````

Finalmente, en la clase principal iniciamos el flujo.

````java
public class Lec06MergeUseCase {
    public static void main(String[] args) {
        FlightSearch.getFlights()
                .subscribe(Util.subscriber());

        Util.sleepSeconds(3);
    }
}
````

El resultado muestra la simulaci√≥n donde solicitamos informaci√≥n de los vuelos. Esta informaci√≥n nos la retorna dentro
de los 2 segundos establecidos.

````bash
11:44:06.782 INFO  [           main] dev.magadiflo.app.common.Util  : Subscribiendo al American Airlines
11:44:06.786 INFO  [           main] dev.magadiflo.app.common.Util  : Subscribiendo al Emirates
11:44:06.786 INFO  [           main] dev.magadiflo.app.common.Util  : Subscribiendo al Qatar
11:44:07.393 INFO  [     parallel-4] d.m.a.common.DefaultSubscriber :  recibido: Flight[airline=Qatar, price=839]
11:44:07.593 INFO  [     parallel-3] d.m.a.common.DefaultSubscriber :  recibido: Flight[airline=Emirates, price=785]
11:44:07.997 INFO  [     parallel-2] d.m.a.common.DefaultSubscriber :  recibido: Flight[airline=American Airlines, price=525]
11:44:08.028 INFO  [     parallel-5] d.m.a.common.DefaultSubscriber :  recibido: Flight[airline=Qatar, price=562]
11:44:08.400 INFO  [     parallel-6] d.m.a.common.DefaultSubscriber :  recibido: Flight[airline=Emirates, price=372]
11:44:08.632 INFO  [     parallel-8] d.m.a.common.DefaultSubscriber :  recibido: Flight[airline=Qatar, price=850]
11:44:08.632 INFO  [     parallel-8] dev.magadiflo.app.common.Util  : Qatar completado
11:44:08.785 INFO  [     parallel-1] dev.magadiflo.app.common.Util  : Cancelando American Airlines
11:44:08.787 INFO  [     parallel-1] dev.magadiflo.app.common.Util  : Cancelando Emirates
11:44:08.788 INFO  [     parallel-1] d.m.a.common.DefaultSubscriber :  ¬°completado!
````

## Zip

El operador `zip` combina elementos de varios `publishers` seg√∫n su √≠ndice. Espera a que todos los `publishers` emitan
un elemento antes de combinarlos en una √∫nica salida. En otras palabras, sincroniza las emisiones de los `publishers`
involucrados para producir una nueva emisi√≥n conjunta.

### Analog√≠a: Construcci√≥n de un carro

Imaginemos una cadena de ensamblaje de carros. Nuestro `subscriber` quiere recibir un carro completo, pero ning√∫n
productor individual lo proporciona por s√≠ solo. En cambio, tenemos:

- `producer1`: emite el armaz√≥n del carro.
- `producer2`: emite el motor.
- `producer3`: emite los neum√°ticos.

Podemos usar `zip` para combinar las emisiones de estos productores. Cuando cada uno haya emitido un elemento, se
ensamblar√° un carro y se enviar√° al `subscriber`.

![04.png](assets/section-09/04.png)

Ahora bien, si los tres `publishers` emiten a velocidades distintas, eso no es problema. `zip` esperar√° a que todos
hayan emitido un nuevo elemento antes de avanzar. Sin embargo, si alguno de los publishers no emite m√°s elementos, el
flujo se detendr√°, ya que no es posible completar la combinaci√≥n.

En pocas palabras, `zip` funciona bajo el principio de `‚Äútodo o nada‚Äù`:

> *Un nuevo valor combinado se emitir√° solo cuando cada fuente haya emitido su correspondiente valor.*

### Ejemplo pr√°ctico

En el siguiente ejemplo, el `subscriber` recibe un carro completo (`Car`) solo cuando los tres `Flux` han emitido un
elemento:

````java
public class Lec07Zip {

    public static void main(String[] args) {
        Flux.zip(getBody(), getEngine(), getTires())
                .map(t -> new Car(t.getT1(), t.getT2(), t.getT3()))
                .subscribe(Util.subscriber());

        Util.sleepSeconds(5);
    }

    private static Flux<String> getBody() {
        return Flux.range(1, 5)
                .map(value -> "body-" + value)
                .delayElements(Duration.ofMillis(100));
    }

    private static Flux<String> getEngine() {
        return Flux.range(1, 3)
                .map(value -> "engine-" + value)
                .delayElements(Duration.ofMillis(200));
    }

    private static Flux<String> getTires() {
        return Flux.range(1, 10)
                .map(value -> "tires-" + value)
                .delayElements(Duration.ofMillis(75));
    }

    record Car(String body, String engine, String tires) {

    }
}
````

### ¬øPor qu√© solo se arman 3 carros?

Porque el `Flux` que representa el motor (`getEngine()`) solo emite `3 elementos`. Aunque los otros dos publishers
tengan m√°s elementos disponibles, `zip` detiene el flujo una vez que uno de ellos se agota.

````bash
13:08:32.882 INFO  [     parallel-2] d.m.a.common.DefaultSubscriber :  recibido: Car[body=body-1, engine=engine-1, tires=tires-1]
13:08:33.100 INFO  [     parallel-8] d.m.a.common.DefaultSubscriber :  recibido: Car[body=body-2, engine=engine-2, tires=tires-2]
13:08:33.301 INFO  [     parallel-5] d.m.a.common.DefaultSubscriber :  recibido: Car[body=body-3, engine=engine-3, tires=tires-3]
13:08:33.309 INFO  [     parallel-5] d.m.a.common.DefaultSubscriber :  ¬°completado!
````

### Resumen de caracter√≠sticas del operador zip:

- ‚úÖ Sincroniza emisiones por posici√≥n/index
- ‚úÖ Espera a que todos los publishers involucrados emitan
- ‚úÖ Combina los valores en una √∫nica salida (usualmente con `Tuple`, `map()` o una funci√≥n combinadora)
- ‚úÖ Se completa cuando el primer publisher se agota
- ‚úÖ Es determinista: combina los n primeros valores de todos los publishers

