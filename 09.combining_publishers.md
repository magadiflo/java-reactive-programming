# Secci√≥n 9: Combinando Publicadores

---

## Introducci√≥n

La `Programaci√≥n Reactiva` en Java implica trabajar con flujos de datos de forma as√≠ncrona. A menudo, es necesario
combinar datos de m√∫ltiples fuentes o `publishers` para lograr el resultado deseado. Comprender c√≥mo integrar estos
`publishers` eficientemente puede mejorar la flexibilidad y la escalabilidad de la aplicaci√≥n.

Exploremos los operadores utilizados para combinar `publishers`, sus casos de uso y ejemplos.

- startWith
- concat
- merge
- zip
- flatMap
- concatMap

## StartWith

El operador `startWith` permite anteponer uno o m√°s elementos o incluso otro `Publisher` al inicio de un flujo (`Flux`
o `Mono`). Es √∫til cuando queremos que el flujo comience con ciertos valores antes de emitir los elementos principales
provenientes de otra fuente.

Imaginemos que tenemos dos `Publisher`, ambos emiten elementos del mismo tipo `T` (por ejemplo, un `Flux<Integer>`, un
`Flux<Client>,` etc.). Al usar el operador `startWith`, podemos combinar estos dos `publishers` en un √∫nico flujo
reactivo, de modo que, desde la perspectiva del `Subscriber`, parecer√° que se ha suscrito a un solo `Publisher<T>`.

El comportamiento clave de `startWith` es que los elementos pasados como argumento (ya sean valores individuales o un
`Publisher`) `se emitir√°n antes` que los elementos `del flujo original`.

El operador `startWith` se utiliza para anteponer elementos al inicio de una secuencia. Esto resulta √∫til cuando
se desea garantizar que algunos `datos iniciales se emitan antes del flujo de datos principal`.

![01.png](assets/section-09/01.png)

### Ejemplo conceptual

Imagine que tiene un flujo de lecturas de temperatura diarias, pero desea anteponer un mensaje de
`Inicio de lecturas de temperatura` al flujo:

````java
public static void main(String[] args) {
    Flux<String> flujoPrincipal = Flux.just("28¬∞C", "30¬∞C", "31¬∞C");
    Flux<String> flujoFinal = flujoPrincipal.startWith("Temperature Readings Start");

    flujoFinal.subscribe(System.out::println);
}
````

La salida ser√≠a.

````bash
Temperature Readings Start
28¬∞C
30¬∞C
31¬∞C
````

### Consideraciones

- `startWith` no es un operador de fallback (es decir, no entra en acci√≥n cuando el primer flujo no tiene suficientes
  elementos, como podr√≠a malinterpretarse).
- Su funci√≥n principal es `anteponer datos`, no completarlos.
- Si necesitas manejar situaciones donde el primer `Publisher` no emite suficientes elementos, deber√≠as considerar
  operadores como `concatWith`, `switchIfEmpty`, etc.

### Ejemplo

Veamos un ejemplo pr√°ctico del operador `startWith`:

````java
public class Lec01StartWith {

    private static final Logger log = LoggerFactory.getLogger(Lec01StartWith.class);

    public static void main(String[] args) {
        producer1()
                .startWith(0, 1, 2, 3)
                .subscribe(Util.subscriber());

        Util.sleepSeconds(3);
    }

    private static Flux<Integer> producer1() {
        return Flux.just(4, 5, 6)
                .doOnSubscribe(subscription -> log.info("Subscribiendo al producer1"))
                .delayElements(Duration.ofMillis(10));
    }
}
````

### Explicaci√≥n

1. Se define un `Flux<Integer>` en el m√©todo `producer1()` que emite los valores `4, 5 y 6`.
2. Luego, usamos el operador `.startWith(0, 1, 2, 3)` para anteponer los valores `0, 1, 2, y 3` al inicio del flujo.
3. El `Subscriber` recibir√° todos los elementos en el siguiente orden: `0, 1, 2, 3, 4, 5, 6`.

El operador `doOnSubscribe` se ejecuta cuando se produce la suscripci√≥n al `Flux original (producer1())`, lo cual
ocurre despu√©s de que se emiten los elementos pasados a `startWith`.

````bash
12:28:13.911 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 0
12:28:13.913 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 1
12:28:13.913 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 2
12:28:13.913 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 3
12:28:13.915 INFO  [           main] d.m.app.sec09.Lec01StartWith   : Subscribiendo al producer1
12:28:13.939 INFO  [     parallel-1] d.m.a.common.DefaultSubscriber :  recibido: 4
12:28:13.954 INFO  [     parallel-2] d.m.a.common.DefaultSubscriber :  recibido: 5
12:28:13.970 INFO  [     parallel-3] d.m.a.common.DefaultSubscriber :  recibido: 6
12:28:13.972 INFO  [     parallel-3] d.m.a.common.DefaultSubscriber :  ¬°completado!
````

### Observaciones

- El `startWith` emite sus valores antes de que se realice la suscripci√≥n al `Flux original`.
- La l√≠nea `Subscribiendo al producer1` aparece despu√©s de la emisi√≥n de `0 a 3`, lo que demuestra que el `producer1()`
  a√∫n no hab√≠a comenzado a emitir.
- Los elementos 4, 5, y 6 son emitidos con un peque√±o retardo simulado, cada uno en un hilo diferente del Scheduler por
  defecto (debido al delayElements).

## StartWith - Casos de uso

En aplicaciones reales, es com√∫n realizar c√°lculos costosos que deseamos evitar repetir constantemente. Para mejorar el
rendimiento, almacenamos los resultados en cach√© y los reutilizamos cuando sea posible. En este tipo de escenarios, el
operador `startWith` resulta √∫til para emitir primero los valores almacenados en cach√© antes de realizar c√°lculos
adicionales o acceder a una fuente de datos m√°s costosa.

> ‚ö†Ô∏è En este ejemplo usamos una lista local como cach√©, pero en una aplicaci√≥n real, una tecnolog√≠a como `Redis` ser√≠a
> una mejor opci√≥n para gestionar cach√© de forma eficiente.

### Ejemplo: Generador de nombres con cach√©

````java
public class NameGenerator {

    private static final Logger log = LoggerFactory.getLogger(NameGenerator.class);
    private final List<String> redis = new ArrayList<>();

    public Flux<String> generateNames() {
        return Flux.generate(synchronousSink -> {
                    log.info("generando nombre");
                    Util.sleepSeconds(1);

                    String name = Util.faker().name().firstName();
                    this.redis.add("[cach√©] " + name);
                    synchronousSink.next(name);
                })
                .startWith(this.redis)
                .cast(String.class);
    }
}
````

La clase `NameGenerator` simula un flujo que genera nombres aleatorios usando `Flux.generate()`. Cada vez que se genera
un nuevo nombre, se agrega a una lista que act√∫a como `cach√© simulada` (`redis`).

El punto clave est√° en esta l√≠nea: `.startWith(this.redis)`.

Con `startWith`, antes de emitir los nuevos nombres generados, el `Flux` primero emite los valores que ya est√°n en
cach√© (es decir, los elementos de la lista redis). Esto permite que los suscriptores reciban primero los datos
almacenados, y luego los nuevos si son necesarios.

> üí° `Ventaja`: cuando un nuevo suscriptor se conecta, puede acceder r√°pidamente a datos previos sin esperar a que se
> generen de nuevo, lo cual simula el comportamiento t√≠pico de una cach√©.

````java
public class Lec02StartWithUseCase {

    private static final Logger log = LoggerFactory.getLogger(Lec02StartWithUseCase.class);

    public static void main(String[] args) {
        NameGenerator nameGenerator = new NameGenerator();

        nameGenerator.generateNames()
                .take(2)
                .subscribe(Util.subscriber("sam"));

        nameGenerator.generateNames()
                .take(2)
                .subscribe(Util.subscriber("mike"));

        nameGenerator.generateNames()
                .take(3)
                .subscribe(Util.subscriber("jake"));
    }
}
````

1. En la primera llamada (`sam`), no hay elementos en cach√©, por lo tanto, se generan nuevos nombres y se agregan a la
   lista `redis`.
2. En la segunda llamada (`mike`), el operador `startWith` emite primero los nombres almacenados en cach√©.
3. En la tercera llamada (`jake`), se emiten primero los datos en cach√© y luego se genera un nuevo nombre adicional.

Este patr√≥n es √∫til cuando deseamos `precargar datos almacenados` antes de acceder a una fuente din√°mica o costosa.

````bash
13:08:52.450 INFO  [           main] d.m.a.s.helper.NameGenerator   : generando nombre
13:08:53.581 INFO  [           main] d.m.a.common.DefaultSubscriber : sam recibido: Sun
13:08:53.581 INFO  [           main] d.m.a.s.helper.NameGenerator   : generando nombre
13:08:54.585 INFO  [           main] d.m.a.common.DefaultSubscriber : sam recibido: Bert
13:08:54.585 INFO  [           main] d.m.a.common.DefaultSubscriber : sam ¬°completado!

13:08:54.585 INFO  [           main] d.m.a.common.DefaultSubscriber : mike recibido: [cach√©] Sun
13:08:54.585 INFO  [           main] d.m.a.common.DefaultSubscriber : mike recibido: [cach√©] Bert
13:08:54.585 INFO  [           main] d.m.a.common.DefaultSubscriber : mike ¬°completado!

13:08:54.585 INFO  [           main] d.m.a.common.DefaultSubscriber : jake recibido: [cach√©] Sun
13:08:54.585 INFO  [           main] d.m.a.common.DefaultSubscriber : jake recibido: [cach√©] Bert
13:08:54.585 INFO  [           main] d.m.a.s.helper.NameGenerator   : generando nombre
13:08:55.595 INFO  [           main] d.m.a.common.DefaultSubscriber : jake recibido: Joel
13:08:55.595 INFO  [           main] d.m.a.common.DefaultSubscriber : jake ¬°completado!
````
