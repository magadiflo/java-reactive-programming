# Secci√≥n 9: Combinando Publicadores

---

## Introducci√≥n

La `Programaci√≥n Reactiva` en Java implica trabajar con flujos de datos de forma as√≠ncrona. A menudo, es necesario
combinar datos de m√∫ltiples fuentes o `publishers` para lograr el resultado deseado. Comprender c√≥mo integrar estos
`publishers` eficientemente puede mejorar la flexibilidad y la escalabilidad de la aplicaci√≥n.

Exploremos los operadores utilizados para combinar `publishers`, sus casos de uso y ejemplos.

- startWith
- concat
- merge
- zip
- flatMap
- concatMap

## StartWith

El operador `startWith` permite anteponer uno o m√°s elementos o incluso otro `Publisher` al inicio de un flujo (`Flux`
o `Mono`). Es √∫til cuando queremos que el flujo comience con ciertos valores antes de emitir los elementos principales
provenientes de otra fuente.

Imaginemos que tenemos dos `Publisher`, ambos emiten elementos del mismo tipo `T` (por ejemplo, un `Flux<Integer>`, un
`Flux<Client>,` etc.). Al usar el operador `startWith`, podemos combinar estos dos `publishers` en un √∫nico flujo
reactivo, de modo que, desde la perspectiva del `Subscriber`, parecer√° que se ha suscrito a un solo `Publisher<T>`.

El comportamiento clave de `startWith` es que los elementos pasados como argumento (ya sean valores individuales o un
`Publisher`) `se emitir√°n antes` que los elementos `del flujo original`.

El operador `startWith` se utiliza para anteponer elementos al inicio de una secuencia. Esto resulta √∫til cuando
se desea garantizar que algunos `datos iniciales se emitan antes del flujo de datos principal`.

![01.png](assets/section-09/01.png)

### Ejemplo conceptual

Imagine que tiene un flujo de lecturas de temperatura diarias, pero desea anteponer un mensaje de
`Inicio de lecturas de temperatura` al flujo:

````java
public static void main(String[] args) {
    Flux<String> flujoPrincipal = Flux.just("28¬∞C", "30¬∞C", "31¬∞C");
    Flux<String> flujoFinal = flujoPrincipal.startWith("Temperature Readings Start");

    flujoFinal.subscribe(System.out::println);
}
````

La salida ser√≠a.

````bash
Temperature Readings Start
28¬∞C
30¬∞C
31¬∞C
````

### Consideraciones

- `startWith` no es un operador de fallback (es decir, no entra en acci√≥n cuando el primer flujo no tiene suficientes
  elementos, como podr√≠a malinterpretarse).
- Su funci√≥n principal es `anteponer datos`, no completarlos.
- Si necesitas manejar situaciones donde el primer `Publisher` no emite suficientes elementos, deber√≠as considerar
  operadores como `concatWith`, `switchIfEmpty`, etc.

### Ejemplo

Veamos un ejemplo pr√°ctico del operador `startWith`:

````java
public class Lec01StartWith {

    private static final Logger log = LoggerFactory.getLogger(Lec01StartWith.class);

    public static void main(String[] args) {
        producer1()
                .startWith(0, 1, 2, 3)
                .subscribe(Util.subscriber());

        Util.sleepSeconds(3);
    }

    private static Flux<Integer> producer1() {
        return Flux.just(4, 5, 6)
                .doOnSubscribe(subscription -> log.info("Subscribiendo al producer1"))
                .delayElements(Duration.ofMillis(10));
    }
}
````

### Explicaci√≥n

1. Se define un `Flux<Integer>` en el m√©todo `producer1()` que emite los valores `4, 5 y 6`.
2. Luego, usamos el operador `.startWith(0, 1, 2, 3)` para anteponer los valores `0, 1, 2, y 3` al inicio del flujo.
3. El `Subscriber` recibir√° todos los elementos en el siguiente orden: `0, 1, 2, 3, 4, 5, 6`.

El operador `doOnSubscribe` se ejecuta cuando se produce la suscripci√≥n al `Flux original (producer1())`, lo cual
ocurre despu√©s de que se emiten los elementos pasados a `startWith`.

````bash
12:28:13.911 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 0
12:28:13.913 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 1
12:28:13.913 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 2
12:28:13.913 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 3
12:28:13.915 INFO  [           main] d.m.app.sec09.Lec01StartWith   : Subscribiendo al producer1
12:28:13.939 INFO  [     parallel-1] d.m.a.common.DefaultSubscriber :  recibido: 4
12:28:13.954 INFO  [     parallel-2] d.m.a.common.DefaultSubscriber :  recibido: 5
12:28:13.970 INFO  [     parallel-3] d.m.a.common.DefaultSubscriber :  recibido: 6
12:28:13.972 INFO  [     parallel-3] d.m.a.common.DefaultSubscriber :  ¬°completado!
````

### Observaciones

- El `startWith` emite sus valores antes de que se realice la suscripci√≥n al `Flux original`.
- La l√≠nea `Subscribiendo al producer1` aparece despu√©s de la emisi√≥n de `0 a 3`, lo que demuestra que el `producer1()`
  a√∫n no hab√≠a comenzado a emitir.
- Los elementos 4, 5, y 6 son emitidos con un peque√±o retardo simulado, cada uno en un hilo diferente del Scheduler por
  defecto (debido al delayElements).

## StartWith - Casos de uso

En aplicaciones reales, es com√∫n realizar c√°lculos costosos que deseamos evitar repetir constantemente. Para mejorar el
rendimiento, almacenamos los resultados en cach√© y los reutilizamos cuando sea posible. En este tipo de escenarios, el
operador `startWith` resulta √∫til para emitir primero los valores almacenados en cach√© antes de realizar c√°lculos
adicionales o acceder a una fuente de datos m√°s costosa.

> ‚ö†Ô∏è En este ejemplo usamos una lista local como cach√©, pero en una aplicaci√≥n real, una tecnolog√≠a como `Redis` ser√≠a
> una mejor opci√≥n para gestionar cach√© de forma eficiente.

### Ejemplo: Generador de nombres con cach√©

````java
public class NameGenerator {

    private static final Logger log = LoggerFactory.getLogger(NameGenerator.class);
    private final List<String> redis = new ArrayList<>();

    public Flux<String> generateNames() {
        return Flux.generate(synchronousSink -> {
                    log.info("generando nombre");
                    Util.sleepSeconds(1);

                    String name = Util.faker().name().firstName();
                    this.redis.add("[cach√©] " + name);
                    synchronousSink.next(name);
                })
                .startWith(this.redis)
                .cast(String.class);
    }
}
````

La clase `NameGenerator` simula un flujo que genera nombres aleatorios usando `Flux.generate()`. Cada vez que se genera
un nuevo nombre, se agrega a una lista que act√∫a como `cach√© simulada` (`redis`).

El punto clave est√° en esta l√≠nea: `.startWith(this.redis)`.

Con `startWith`, antes de emitir los nuevos nombres generados, el `Flux` primero emite los valores que ya est√°n en
cach√© (es decir, los elementos de la lista redis). Esto permite que los suscriptores reciban primero los datos
almacenados, y luego los nuevos si son necesarios.

> üí° `Ventaja`: cuando un nuevo suscriptor se conecta, puede acceder r√°pidamente a datos previos sin esperar a que se
> generen de nuevo, lo cual simula el comportamiento t√≠pico de una cach√©.

````java
public class Lec02StartWithUseCase {

    private static final Logger log = LoggerFactory.getLogger(Lec02StartWithUseCase.class);

    public static void main(String[] args) {
        NameGenerator nameGenerator = new NameGenerator();

        nameGenerator.generateNames()
                .take(2)
                .subscribe(Util.subscriber("sam"));

        nameGenerator.generateNames()
                .take(2)
                .subscribe(Util.subscriber("mike"));

        nameGenerator.generateNames()
                .take(3)
                .subscribe(Util.subscriber("jake"));
    }
}
````

1. En la primera llamada (`sam`), no hay elementos en cach√©, por lo tanto, se generan nuevos nombres y se agregan a la
   lista `redis`.
2. En la segunda llamada (`mike`), el operador `startWith` emite primero los nombres almacenados en cach√©.
3. En la tercera llamada (`jake`), se emiten primero los datos en cach√© y luego se genera un nuevo nombre adicional.

Este patr√≥n es √∫til cuando deseamos `precargar datos almacenados` antes de acceder a una fuente din√°mica o costosa.

````bash
13:08:52.450 INFO  [           main] d.m.a.s.helper.NameGenerator   : generando nombre
13:08:53.581 INFO  [           main] d.m.a.common.DefaultSubscriber : sam recibido: Sun
13:08:53.581 INFO  [           main] d.m.a.s.helper.NameGenerator   : generando nombre
13:08:54.585 INFO  [           main] d.m.a.common.DefaultSubscriber : sam recibido: Bert
13:08:54.585 INFO  [           main] d.m.a.common.DefaultSubscriber : sam ¬°completado!

13:08:54.585 INFO  [           main] d.m.a.common.DefaultSubscriber : mike recibido: [cach√©] Sun
13:08:54.585 INFO  [           main] d.m.a.common.DefaultSubscriber : mike recibido: [cach√©] Bert
13:08:54.585 INFO  [           main] d.m.a.common.DefaultSubscriber : mike ¬°completado!

13:08:54.585 INFO  [           main] d.m.a.common.DefaultSubscriber : jake recibido: [cach√©] Sun
13:08:54.585 INFO  [           main] d.m.a.common.DefaultSubscriber : jake recibido: [cach√©] Bert
13:08:54.585 INFO  [           main] d.m.a.s.helper.NameGenerator   : generando nombre
13:08:55.595 INFO  [           main] d.m.a.common.DefaultSubscriber : jake recibido: Joel
13:08:55.595 INFO  [           main] d.m.a.common.DefaultSubscriber : jake ¬°completado!
````

## ConcatWith

El operador `concatWith` funciona como el opuesto del operador `startWith`. Su comportamiento consiste en emitir primero
todos los elementos del `publisher original`, y una vez que este se completa, pasa a emitir los elementos del
`publisher que se le concatena`.

Esto significa que `concatWith` `combina dos publishers de forma secuencial`, respetando el orden de emisi√≥n:
primero uno, luego el otro. Es importante destacar que el segundo publisher no se suscribir√° hasta que el primero
haya enviado la se√±al de `completado`. Esto garantiza un flujo de datos estrictamente ordenado.

> üìå Este comportamiento es √∫til cuando queremos asegurar que los elementos de un flujo se procesen completamente antes
> de continuar con otro conjunto de datos.

![02.png](assets/section-09/02.png)

### Ejemplo 1

En este ejemplo se usa el m√©todo `.concatWithValues(...)`, que permite concatenar un `Flux` con valores individuales
directamente.

````java
public class Lec03ConcatWith {

    private static final Logger log = LoggerFactory.getLogger(Lec03ConcatWith.class);

    public static void main(String[] args) {
        demo1();
        Util.sleepSeconds(3);
    }

    private static void demo1() {
        producer1()
                .concatWithValues(6, 8, 10)
                .subscribe(Util.subscriber());
    }

    private static Flux<Integer> producer1() {
        return Flux.just(1, 2, 3)
                .doOnSubscribe(subscription -> log.info("Subscribiendo al producer1"))
                .delayElements(Duration.ofMillis(10));
    }
}
````

Como se observa en la salida, primero se emiten los elementos del `producer1()`, y una vez que este flujo se completa,
se emiten los valores adicionales definidos en `.concatWithValues(6, 8, 10)`.

````bash
15:28:20.442 INFO  [           main] d.m.app.sec09.Lec03ConcatWith  : Subscribiendo al producer1
15:28:20.467 INFO  [     parallel-1] d.m.a.common.DefaultSubscriber :  recibido: 1
15:28:20.483 INFO  [     parallel-2] d.m.a.common.DefaultSubscriber :  recibido: 2
15:28:20.499 INFO  [     parallel-3] d.m.a.common.DefaultSubscriber :  recibido: 3
15:28:20.499 INFO  [     parallel-3] d.m.a.common.DefaultSubscriber :  recibido: 6
15:28:20.499 INFO  [     parallel-3] d.m.a.common.DefaultSubscriber :  recibido: 8
15:28:20.499 INFO  [     parallel-3] d.m.a.common.DefaultSubscriber :  recibido: 10
15:28:20.502 INFO  [     parallel-3] d.m.a.common.DefaultSubscriber :  ¬°completado!
````

### Ejemplo 2

En este segundo ejemplo usamos el operador `concatWith(...)` para concatenar un `Flux` con otro `Flux`, es decir,
dos publishers completos. A diferencia del primer ejemplo donde se usaban valores individuales, aqu√≠ ambos flujos
tienen su propia l√≥gica de producci√≥n y suscripciones.

````java
public class Lec03ConcatWith {

    private static final Logger log = LoggerFactory.getLogger(Lec03ConcatWith.class);

    public static void main(String[] args) {
        demo2();
        Util.sleepSeconds(3);
    }

    private static void demo2() {
        producer1()
                .concatWith(producer2())
                .subscribe(Util.subscriber());
    }

    private static Flux<Integer> producer1() {
        return Flux.just(1, 2, 3)
                .doOnSubscribe(subscription -> log.info("Subscribiendo al producer1"))
                .delayElements(Duration.ofMillis(10));
    }

    private static Flux<Integer> producer2() {
        return Flux.just(40, 50, 60)
                .doOnSubscribe(subscription -> log.info("Subscribiendo al producer2"))
                .delayElements(Duration.ofMillis(10));
    }
}
````

La clave del comportamiento est√° en que `concatWith` espera a que el primer flujo (`producer1`) se complete antes de
suscribirse al segundo (`producer2`). Esto garantiza que los datos se emitan en el orden correcto sin entrelazarse,
incluso si ambos flujos introducen demoras (`delayElements`).

````bash
15:30:39.925 INFO  [           main] d.m.app.sec09.Lec03ConcatWith  : Subscribiendo al producer1
15:30:39.948 INFO  [     parallel-1] d.m.a.common.DefaultSubscriber :  recibido: 1
15:30:39.964 INFO  [     parallel-2] d.m.a.common.DefaultSubscriber :  recibido: 2
15:30:39.980 INFO  [     parallel-3] d.m.a.common.DefaultSubscriber :  recibido: 3
15:30:39.980 INFO  [     parallel-3] d.m.app.sec09.Lec03ConcatWith  : Subscribiendo al producer2
15:30:39.995 INFO  [     parallel-4] d.m.a.common.DefaultSubscriber :  recibido: 40
15:30:40.011 INFO  [     parallel-5] d.m.a.common.DefaultSubscriber :  recibido: 50
15:30:40.026 INFO  [     parallel-6] d.m.a.common.DefaultSubscriber :  recibido: 60
15:30:40.029 INFO  [     parallel-6] d.m.a.common.DefaultSubscriber :  ¬°completado!
````

### Ejemplo 3

En este ejemplo se usa el operador de f√°brica `Flux.concat(...)` para concatenar dos publishers, estos se ejecutar√°n
de manera secuencial, tal cual fueron definidos. En nuestro ejemplo, primero se emitir√°n los elementos del `producer1()`
y a continuaci√≥n los elementos del `producer2()`.

````java
public class Lec03ConcatWith {

    private static final Logger log = LoggerFactory.getLogger(Lec03ConcatWith.class);

    public static void main(String[] args) {
        demo3();
        Util.sleepSeconds(3);
    }

    private static void demo3() {
        Flux.concat(producer1(), producer2())
                .subscribe(Util.subscriber());
    }

    private static Flux<Integer> producer1() {
        return Flux.just(1, 2, 3)
                .doOnSubscribe(subscription -> log.info("Subscribiendo al producer1"))
                .delayElements(Duration.ofMillis(10));
    }

    private static Flux<Integer> producer2() {
        return Flux.just(40, 50, 60)
                .doOnSubscribe(subscription -> log.info("Subscribiendo al producer2"))
                .delayElements(Duration.ofMillis(10));
    }
}

````

El resultado es similar a lo que hemos visto anteriormente.

````bash
15:33:01.034 INFO  [           main] d.m.app.sec09.Lec03ConcatWith  : Subscribiendo al producer1
15:33:01.066 INFO  [     parallel-1] d.m.a.common.DefaultSubscriber :  recibido: 1
15:33:01.081 INFO  [     parallel-2] d.m.a.common.DefaultSubscriber :  recibido: 2
15:33:01.097 INFO  [     parallel-3] d.m.a.common.DefaultSubscriber :  recibido: 3
15:33:01.097 INFO  [     parallel-3] d.m.app.sec09.Lec03ConcatWith  : Subscribiendo al producer2
15:33:01.113 INFO  [     parallel-4] d.m.a.common.DefaultSubscriber :  recibido: 40
15:33:01.129 INFO  [     parallel-5] d.m.a.common.DefaultSubscriber :  recibido: 50
15:33:01.144 INFO  [     parallel-6] d.m.a.common.DefaultSubscriber :  recibido: 60
15:33:01.147 INFO  [     parallel-6] d.m.a.common.DefaultSubscriber :  ¬°completado!
````

> üí° Todos estos enfoques garantizan un flujo ordenado, en el cual no se mezcla la emisi√≥n de elementos de los
> publishers involucrados.

Esto es √∫til cuando:

- Necesitas mantener un orden espec√≠fico en la emisi√≥n.
- El segundo flujo depende de la finalizaci√≥n del primero.
- Est√°s combinando datos que deben procesarse en secuencia, como pasos en un pipeline.

## ConcatDelayError

El operador `concatDelayError` es similar a `concatWith` o `Flux.concat`, con una diferencia clave: *retrasa la emisi√≥n
de errores hasta que todos los publishers hayan sido procesados.* Es √∫til cuando se desea garantizar que todos los
flujos de datos sean evaluados, incluso si uno o m√°s fallan.

````java
public class Lec04ConcatDelayError {

    private static final Logger log = LoggerFactory.getLogger(Lec04ConcatDelayError.class);

    public static void main(String[] args) {
        demo1();
        Util.sleepSeconds(3);
    }

    private static void demo1() {
        Flux.concatDelayError(producer1(), producer3(), producer2())
                .subscribe(Util.subscriber());

    }

    private static Flux<Integer> producer1() {
        return Flux.just(1, 2, 3)
                .doOnSubscribe(subscription -> log.info("Subscribiendo al producer1"))
                .delayElements(Duration.ofMillis(10));
    }

    private static Flux<Integer> producer2() {
        return Flux.just(40, 50, 60)
                .doOnSubscribe(subscription -> log.info("Subscribiendo al producer2"))
                .delayElements(Duration.ofMillis(10));
    }

    private static Flux<Integer> producer3() {
        return Flux.error(new RuntimeException("Error en el producer3"));
    }
}
````

Aunque el error se produce en `producer3()`, su emisi√≥n se retrasa hasta que los dem√°s publishers (`producer1()` y
`producer2()`) hayan completado su flujo. Solo entonces se lanza el error al suscriptor.

````bash
16:22:51.367 INFO  [           main] d.m.a.s.Lec04ConcatDelayError  : Subscribiendo al producer1
16:22:51.398 INFO  [     parallel-1] d.m.a.common.DefaultSubscriber :  recibido: 1
16:22:51.414 INFO  [     parallel-2] d.m.a.common.DefaultSubscriber :  recibido: 2
16:22:51.430 INFO  [     parallel-3] d.m.a.common.DefaultSubscriber :  recibido: 3
16:22:51.433 INFO  [     parallel-3] d.m.a.s.Lec04ConcatDelayError  : Subscribiendo al producer2
16:22:51.446 INFO  [     parallel-4] d.m.a.common.DefaultSubscriber :  recibido: 40
16:22:51.462 INFO  [     parallel-5] d.m.a.common.DefaultSubscriber :  recibido: 50
16:22:51.478 INFO  [     parallel-6] d.m.a.common.DefaultSubscriber :  recibido: 60
16:22:51.478 ERROR [     parallel-6] d.m.a.common.DefaultSubscriber :  error: Error en el producer3
````
