# Secci√≥n 10: [Opcional] - Batching / Windowing / Grouping

---

## Introducci√≥n

En entornos donde trabajamos con flujos continuos de datos, como los provenientes de sistemas de mensajer√≠a (`Kafka`,
`RabbitMQ`, `Pulsar`, etc.), es com√∫n encontrarnos con un `Flux<T>`, es decir, un flujo reactivo que emite datos de
forma constante o indefinida.

Para manejar este tipo de flujos de manera eficiente, especialmente cuando queremos agrupar, dividir o procesar
elementos en lotes, `Reactor` nos ofrece una serie de operadores √∫tiles:

- `buffer`: Agrupa elementos emitidos por el flujo en colecciones (listas).
- `window`: Divide el flujo en subflujos (`Flux<Flux<T>>`), cada uno con un conjunto de elementos.
- `groupBy`: Agrupa los elementos del flujo seg√∫n una clave, generando subflujos por cada grupo.

Estos operadores nos permiten aplicar t√©cnicas como `batching`, `windowing` y `grouping`, fundamentales para procesar
datos de forma eficiente y organizada.

## Buffer

Consideremos un `publisher` que emite √≠tems a un ritmo muy r√°pido; por ejemplo, eventos de clic de los usuarios,
visualizaciones de productos, entre otros. Nos interesa saber en qu√© hacen clic los usuarios, qu√© productos visitan,
etc. Aunque no lo parezca, esta informaci√≥n es muy valiosa para las empresas, ya que les permite tomar decisiones para
mejorar sus servicios o estrategias de negocio.

Todos estos eventos suelen enviarse a un `topic` en `Kafka`, y desde all√≠ pueden ser procesados por diferentes sistemas.

Ahora bien, supongamos que nuestro objetivo es insertar cada uno de esos eventos en una base de datos. Si los eventos
llegan a una velocidad muy alta, insertar uno por uno no es eficiente ni escalable. En su lugar, lo que podemos hacer
es agrupar esos eventos en lotes (`batching`) basados en un intervalo de tiempo, como por ejemplo cada 5 segundos.

La idea es la siguiente:

- Recolectar todos los eventos emitidos durante un intervalo de 5 segundos.
- Al finalizar el intervalo, agruparlos en una lista.
- Insertar todos los eventos del lote en la base de datos de una sola vez.

Luego, esperamos otros 5 segundos, recolectamos los nuevos eventos, los agrupamos, y repetimos el proceso.

Esta t√©cnica nos permite mejorar la eficiencia y reducir la sobrecarga de operaciones individuales contra la base de
datos.

![01.png](assets/section-10/01.png)

### Ejemplo 01 - buffer()

Veamos un ejemplo donde se utiliza el operador `buffer()` con su comportamiento por defecto:

````java
// Recopilar items en funci√≥n del valor interno / tama√±o dado
public class Lec01Buffer {
    public static void main(String[] args) {
        demo1();

        Util.sleepSeconds(60);
    }

    private static void demo1() {
        eventStream() //Flux<String>
                .buffer()//Flux<List<String>>: intenta recopilar todos los elementos antes de emitir
                .subscribe(Util.subscriber());
    }

    // Simulando flujo de eventos
    private static Flux<String> eventStream() {
        return Flux.interval(Duration.ofMillis(200))
                .map(value -> "evento-" + (value + 1));
    }
}
````

El operador `buffer()` sin argumentos recopila todos los elementos emitidos por el `Flux` original en una sola lista, y
emite esa lista √∫nicamente cuando el `Flux` fuente se completa.

En este ejemplo, estamos simulando un flujo de eventos continuo (infinito), donde se emite un evento cada 200
milisegundos. Como el `Flux` nunca se completa (es infinito), el `buffer()` nunca emite nada. Por eso, al ejecutar este
c√≥digo no veremos ninguna salida en la consola, a pesar de que los eventos se est√°n generando.

> üîç Importante: `buffer()` sin par√°metros no es adecuado para flujos infinitos si esperamos recibir resultados durante
> la ejecuci√≥n. Para esos casos, se recomienda usar variantes de `buffer` con condiciones de `tiempo` o `cantidad`,
> como `buffer(Duration)` o `buffer(int)`.

### Ejemplo 02 - buffer(int)

Veamos otro ejemplo donde usamos `buffer(int)` para recolectar elementos en grupos de 3:

````java
public class Lec01Buffer {
    public static void main(String[] args) {
        demo2();

        Util.sleepSeconds(60);
    }

    private static void demo2() {
        eventStream()
                .buffer(3)// Agrupa cada 3 elementos emitidos en una lista
                .subscribe(Util.subscriber());
    }

    private static Flux<String> eventStream() {
        return Flux.interval(Duration.ofMillis(200))
                .map(value -> "evento-" + (value + 1));
    }
}
````

En este caso, el operador `buffer(3)` agrupa cada 3 elementos emitidos por el `Flux` fuente en una lista, y luego
emite esa lista como un nuevo √≠tem en el flujo resultante (`Flux<List<String>>`).

Como resultado, obtendremos salidas similares a las siguientes:

````bash
10:30:05.423 INFO  [     parallel-1] d.m.a.common.DefaultSubscriber :  recibido: [evento-1, evento-2, evento-3]
10:30:06.029 INFO  [     parallel-1] d.m.a.common.DefaultSubscriber :  recibido: [evento-4, evento-5, evento-6]
10:30:06.619 INFO  [     parallel-1] d.m.a.common.DefaultSubscriber :  recibido: [evento-7, evento-8, evento-9]
10:30:07.226 INFO  [     parallel-1] d.m.a.common.DefaultSubscriber :  recibido: [evento-10, evento-11, evento-12]
10:30:07.834 INFO  [     parallel-1] d.m.a.common.DefaultSubscriber :  recibido: [evento-13, evento-14, evento-15]
...
````

Como puedes ver, el `Flux` original emite un evento cada 200 milisegundos, y `buffer(3)` recolecta esos eventos en
bloques de 3 antes de pasarlos al subscriber.

> üìå `Nota`: Esta forma de `batching` es √∫til cuando queremos procesar m√∫ltiples elementos juntos por cantidad,
> en lugar de tiempo. Es eficiente para reducir la cantidad de operaciones repetitivas, como llamadas a bases de datos
> o servicios externos.

### Ejemplo 03 - buffer(Duration)

Ahora veamos un caso en el que usamos el operador `buffer(Duration)` para recolectar elementos en funci√≥n del tiempo.

````java
public class Lec01Buffer {
    public static void main(String[] args) {
        demo3();

        Util.sleepSeconds(60);
    }

    private static void demo3() {
        eventStream()
                .buffer(Duration.ofMillis(500))//Le decimos que recoja items dentro de 500 milisegundos
                .subscribe(Util.subscriber());
    }

    private static Flux<String> eventStream() {
        return Flux.interval(Duration.ofMillis(200))
                .map(value -> "evento-" + (value + 1));
    }
}
````

En este ejemplo, `buffer(Duration.ofMillis(500))` agrupa todos los elementos que llegan dentro de una ventana de 500
milisegundos. A diferencia de `buffer(int)`, aqu√≠ la agrupaci√≥n se basa en el tiempo y no en la cantidad de elementos.

Esto implica que la cantidad de elementos en cada lista puede variar, dependiendo de cu√°ntos eventos lleguen dentro del
intervalo de 500 ms.

````bash
10:34:59.745 INFO  [     parallel-1] d.m.a.common.DefaultSubscriber :  recibido: [evento-1, evento-2]
10:35:00.237 INFO  [     parallel-1] d.m.a.common.DefaultSubscriber :  recibido: [evento-3, evento-4]
10:35:00.738 INFO  [     parallel-1] d.m.a.common.DefaultSubscriber :  recibido: [evento-5, evento-6, evento-7]
10:35:01.237 INFO  [     parallel-1] d.m.a.common.DefaultSubscriber :  recibido: [evento-8, evento-9]
10:35:01.733 INFO  [     parallel-1] d.m.a.common.DefaultSubscriber :  recibido: [evento-10, evento-11, evento-12]
...
````

> üß† `Observaci√≥n`: Como los eventos se generan cada 200 ms, en teor√≠a podr√≠amos recibir 2 o 3 eventos por cada ventana
> de 500 ms, dependiendo de la alineaci√≥n temporal entre la generaci√≥n de eventos y la apertura de cada ventana de
> tiempo.

### Ejemplo 04 - bufferTimeout(int, Duration)

Como √∫ltimo ejemplo, utilizaremos el operador `bufferTimeout(int, Duration)`, el cual permite agrupar elementos seg√∫n
dos condiciones: un `n√∫mero m√°ximo de items` o un `tiempo m√°ximo de espera`, lo que ocurra primero.

````java
public class Lec01Buffer {
    public static void main(String[] args) {
        demo4();

        Util.sleepSeconds(60);
    }

    private static void demo4() {
        eventStream()
                .bufferTimeout(3, Duration.ofSeconds(1))// Agrupa cada 3 elementos o espera 1 segundo m√°ximo
                .subscribe(Util.subscriber());
    }

    private static Flux<String> eventStream() {
        return Flux.interval(Duration.ofMillis(200))
                .take(10)                   // Emitimos solo 10 eventos
                .concatWith(Flux.never())   // Evita la finalizaci√≥n del flujo para ver el comportamiento del √∫ltimo buffer
                .map(value -> "evento-" + (value + 1));
    }
}
````

En este ejemplo:

- `bufferTimeout(3, Duration.ofSeconds(1))` intenta recolectar 3 elementos.
- Si no los obtiene en 1 segundo, `emite lo que tenga disponible hasta ese momento`.
- Luego del d√©cimo elemento, no se emiten m√°s valores, ni error, ni evento de finalizaci√≥n (onComplete), ya que usamos
  `Flux.never()` para mantener el flujo `abierto`.

````bash
10:46:52.126 INFO  [     parallel-1] d.m.a.common.DefaultSubscriber :  recibido: [evento-1, evento-2, evento-3]
10:46:52.713 INFO  [     parallel-1] d.m.a.common.DefaultSubscriber :  recibido: [evento-4, evento-5, evento-6]
10:46:53.321 INFO  [     parallel-1] d.m.a.common.DefaultSubscriber :  recibido: [evento-7, evento-8, evento-9]
10:46:54.528 INFO  [     parallel-2] d.m.a.common.DefaultSubscriber :  recibido: [evento-10]
````

> üß† `Observaci√≥n`: Si hubi√©ramos utilizado solo `buffer(3)`, el √∫ltimo elemento (`evento-10`) no se habr√≠a emitido, ya
> que el operador esperar√≠a por dos elementos m√°s para completar el grupo. Con `bufferTimeout`, logramos emitir incluso
> los grupos incompletos tras un tiempo l√≠mite.

## Buffer - Tarea asignada

### üéØ Objetivo

Emitir un reporte cada 5 segundos con los ingresos generados por √≥rdenes de libros pertenecientes a los g√©neros:

- Science fiction
- Fantasy
- Suspense/Thriller

### üß± Estructura del c√≥digo

1. üìò`BookOrder`, modelo de orden de libro. Se define un record llamado `BookOrder` con los campos `genre`, `title` y
   `price`. El m√©todo est√°tico `create()` genera una instancia con valores aleatorios usando la librer√≠a `faker()`.

````java
public record BookOrder(String genre, String title, Integer price) {
    public static BookOrder create() {
        return new BookOrder(
                Util.faker().book().genre(),
                Util.faker().book().title(),
                Util.faker().random().nextInt(10, 100)
        );
    }
}
````

2. üìä`RevenueReport`, modelo del reporte generado. Este record representa el reporte de ingresos por g√©nero, acompa√±ado
   de la hora de generaci√≥n.

````java
// Reporte de ingresos
public record RevenueReport(LocalTime time,
                            Map<String, Integer> revenue) {
}
````

3. üß™`L√≥gica principal en Lec02BufferAssignment`, aqu√≠ se genera un flujo continuo de √≥rdenes de libros cada 200ms. Se
   aplican los siguientes pasos:
    - Filtrar las √≥rdenes por las categor√≠as requeridas.
    - Agrupar cada 5 segundos usando `buffer(Duration.ofSeconds(5))`.
    - Procesar el listado acumulado con el m√©todo `generateReport`.
    - Emitir el reporte usando `subscribe`.

````java
public class Lec02BufferAssignment {

    public static void main(String[] args) {
        Set<String> allowedCategories = Set.of("Science fiction", "Fantasy", "Suspense/Thriller");
        orderStream()
                .filter(bookOrder -> allowedCategories.contains(bookOrder.genre()))
                .buffer(Duration.ofSeconds(5))
                .map(Lec02BufferAssignment::generateReport)
                .subscribe(Util.subscriber());

        Util.sleepSeconds(60);
    }

    private static Flux<BookOrder> orderStream() {
        return Flux.interval(Duration.ofMillis(200))
                .map(value -> BookOrder.create());
    }

    private static RevenueReport generateReport(List<BookOrder> bookOrders) {
        Map<String, Integer> revenue = bookOrders.stream()
                .collect(Collectors.groupingBy(
                        BookOrder::genre,
                        Collectors.summingInt(BookOrder::price)
                ));
        return new RevenueReport(LocalTime.now().truncatedTo(ChronoUnit.SECONDS), revenue);
    }
}
````

Cada 5 segundos se imprime un reporte de ingresos por g√©nero, como se muestra a continuaci√≥n.

````bash
12:08:34.905 INFO  [     parallel-1] d.m.a.common.DefaultSubscriber :  recibido: RevenueReport[time=12:08:34, revenue={Science fiction=47, Fantasy=96, Suspense/Thriller=83}]
12:08:39.911 INFO  [     parallel-1] d.m.a.common.DefaultSubscriber :  recibido: RevenueReport[time=12:08:39, revenue={Fantasy=48}]
12:08:44.909 INFO  [     parallel-1] d.m.a.common.DefaultSubscriber :  recibido: RevenueReport[time=12:08:44, revenue={Science fiction=160, Fantasy=48}]
12:08:49.907 INFO  [     parallel-1] d.m.a.common.DefaultSubscriber :  recibido: RevenueReport[time=12:08:49, revenue={Science fiction=39, Fantasy=25, Suspense/Thriller=138}]
12:08:54.900 INFO  [     parallel-1] d.m.a.common.DefaultSubscriber :  recibido: RevenueReport[time=12:08:54, revenue={Science fiction=151}]
12:08:59.900 INFO  [     parallel-1] d.m.a.common.DefaultSubscriber :  recibido: RevenueReport[time=12:08:59, revenue={Fantasy=45, Suspense/Thriller=60}]
...
````

### ‚úÖ Conclusi√≥n

Este ejemplo demuestra c√≥mo usar el operador `buffer(Duration)` para agrupar eventos por intervalos de tiempo,
permitiendo generar reportes peri√≥dicos. Es ideal para casos donde no sabemos la cantidad exacta de eventos a recibir,
pero queremos emitir informaci√≥n regularmente (cada N segundos).

## Windowing

El operador `window` en `Project Reactor` funciona de manera similar al operador `buffer`, pero con una diferencia clave
en su comportamiento: `en lugar de recopilar los elementos en una lista y entregarlos al Subscriber`, el operador
`window` crea un nuevo `Flux` (una `sub-secuencia` o `ventana`) para agrupar elementos en funci√≥n del tiempo o la
cantidad, permitiendo procesarlos a medida que llegan.

### Diferencia entre buffer y window

- `buffer`: Agrupa los elementos recibidos en una lista y entrega esa lista al Subscriber cuando se cumple una
  condici√≥n (por cantidad o tiempo). El `Subscriber` recibe la `lista` completa de elementos.


- `window`: Agrupa los elementos en un nuevo `Flux`, el cual contiene los elementos que caen dentro de cierta condici√≥n
  (por cantidad o tiempo). El `Subscriber` recibe un `Flux<Flux<T>>`, es decir, un flujo de ventanas, y cada ventana es
  un `Flux` que se puede suscribir y procesar independientemente.

### Analog√≠a para entender window

Imaginemos una aplicaci√≥n que est√° escribiendo registros de eventos (logs). En lugar de escribir todos los logs en un
√∫nico archivo gigante, lo com√∫n es dividir los logs en archivos separados por per√≠odos de tiempo, por ejemplo, uno por
d√≠a o por hora.

- Cada archivo de log representa una ventana.
- Todos los eventos que ocurren durante esa ventana de tiempo se escriben directamente en ese archivo (no se acumulan
  primero en memoria como har√≠a buffer).
- Cuando se termina el tiempo asignado a una ventana, se abre una nueva ventana (un nuevo archivo de log), y los eventos
  posteriores van a ese nuevo archivo.

Del mismo modo, en Reactor:

- Cada ventana (`Flux`) se abre bajo una condici√≥n (tiempo o cantidad).
- Los elementos se env√≠an en tiempo real a la ventana mientras esta est√° activa.
- Al terminar la ventana, se cierra y se abre una nueva.

![02.png](assets/section-10/02.png)

En este gr√°fico (referencia visual), podemos ver c√≥mo los datos se agrupan en ventanas, no como listas completas, sino
como flujos independientes que pueden procesarse por separado.

## Windowing - window(int)

El operador `window(int)` en `Project Reactor` divide una secuencia de un `Flux<T>` en m√∫ltiples ventanas, donde cada
ventana es a su vez un `Flux<T>`. Cada una de estas ventanas emitir√° hasta un n√∫mero m√°ximo de elementos especificado
(en este caso, 5). A diferencia del operador `buffer`, que recolecta los elementos en una lista, `window` conserva el
comportamiento reactivo emitiendo los elementos a medida que llegan, sin agruparlos en una colecci√≥n.

En este ejemplo, se simula una secuencia de eventos con el m√©todo `eventStream()`, que emite un nuevo evento cada 500
milisegundos. Luego, se aplica el operador `window(5)` para dividir el flujo en ventanas de 5 elementos cada una, es
decir, se crea un nuevo `Flux<String>` cada vez que se alcanzan 5 eventos.

Cada una de estas ventanas se pasa al m√©todo `processEvents`, que procesa los eventos imprimiendo un asterisco `(*)`
por cada uno. Al completar la ventana, se imprime una nueva l√≠nea. El m√©todo retorna un `Mono<Void>` que se utiliza con
`flatMap` para suscribirse a cada `sub-flux` de forma no bloqueante.

````java
public class Lec03Window {

    public static void main(String[] args) {
        demo1();
        Util.sleepSeconds(60);
    }

    private static void demo1() {
        eventStream()
                .window(5) // Flux<Flux<String>>, divide el flujo original en ventanas (flux) de 5 elementos
                .flatMap(Lec03Window::processEvents) // Procesa cada ventana    
                .subscribe();
    }

    private static Flux<String> eventStream() {
        return Flux.interval(Duration.ofMillis(500))
                .map(value -> "evento-" + (value + 1));
    }

    private static Mono<Void> processEvents(Flux<String> flux) {
        return flux.doOnNext(value -> System.out.print("*")) // Imprime un * por cada elemento
                .doOnComplete(System.out::println)           // Imprime salto de l√≠nea al terminar la ventana
                .then();                                     // Retorna un Mono<Void> para encadenar en flatMap
    }
}
````

En el resultado vemos una manera de evidenciar el trabajo del operador `window`.

````bash
*****
*****
*****
...
````

## Windowing - window(Duration)

A diferencia de `window(int)`, que divide el flujo en ventanas de un n√∫mero fijo de elementos, el operador
`window(Duration)` divide el `Flux` en ventanas temporales. Cada ventana agrupa los elementos que llegan dentro del
intervalo de tiempo especificado, y luego se cierra autom√°ticamente al terminar ese tiempo, sin importar cu√°ntos
elementos contenga.

En el siguiente ejemplo, se crea un flujo simulado de eventos que emite un elemento cada 500 milisegundos. Luego, se
agrupan estos eventos utilizando `window(Duration.ofMillis(1800))`, lo que significa que cada ventana recoger√°
los eventos emitidos en un periodo de 1.8 segundos (1800 milisegundos).

Cada ventana es procesada por el m√©todo `processEvents`, el cual imprime un asterisco `*` por cada evento recibido,
y un salto de l√≠nea cuando la ventana se completa.

````java
public class Lec03Window {

    public static void main(String[] args) {
        demo2();
        Util.sleepSeconds(60);
    }

    private static void demo2() {
        eventStream()
                .window(Duration.ofMillis(1800))        // Crea una nueva ventana cada 1.8 segundos
                .flatMap(Lec03Window::processEvents)    // Procesa cada ventana
                .subscribe();
    }

    private static Flux<String> eventStream() {
        return Flux.interval(Duration.ofMillis(500))
                .map(value -> "evento-" + (value + 1));
    }

    private static Mono<Void> processEvents(Flux<String> flux) {
        return flux.doOnNext(value -> System.out.print("*"))
                .doOnComplete(System.out::println)
                .then();
    }
}
````

El n√∫mero de asteriscos por ventana puede variar seg√∫n el momento en que los eventos caen dentro del intervalo de
tiempo. Por ejemplo, si un evento llega justo al final de una ventana, podr√≠a pasar a la siguiente.

````bash
***
****
***
****
***
...
````
