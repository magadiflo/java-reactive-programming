# Secci√≥n 10: [Opcional] - Batching / Windowing / Grouping

---

## Introducci√≥n

En entornos donde trabajamos con flujos continuos de datos, como los provenientes de sistemas de mensajer√≠a (`Kafka`,
`RabbitMQ`, `Pulsar`, etc.), es com√∫n encontrarnos con un `Flux<T>`, es decir, un flujo reactivo que emite datos de
forma constante o indefinida.

Para manejar este tipo de flujos de manera eficiente, especialmente cuando queremos agrupar, dividir o procesar
elementos en lotes, `Reactor` nos ofrece una serie de operadores √∫tiles:

- `buffer`: Agrupa elementos emitidos por el flujo en colecciones (listas).
- `window`: Divide el flujo en subflujos (`Flux<Flux<T>>`), cada uno con un conjunto de elementos.
- `groupBy`: Agrupa los elementos del flujo seg√∫n una clave, generando subflujos por cada grupo.

Estos operadores nos permiten aplicar t√©cnicas como `batching`, `windowing` y `grouping`, fundamentales para procesar
datos de forma eficiente y organizada.

## Buffer

Consideremos un `publisher` que emite √≠tems a un ritmo muy r√°pido; por ejemplo, eventos de clic de los usuarios,
visualizaciones de productos, entre otros. Nos interesa saber en qu√© hacen clic los usuarios, qu√© productos visitan,
etc. Aunque no lo parezca, esta informaci√≥n es muy valiosa para las empresas, ya que les permite tomar decisiones para
mejorar sus servicios o estrategias de negocio.

Todos estos eventos suelen enviarse a un `topic` en `Kafka`, y desde all√≠ pueden ser procesados por diferentes sistemas.

Ahora bien, supongamos que nuestro objetivo es insertar cada uno de esos eventos en una base de datos. Si los eventos
llegan a una velocidad muy alta, insertar uno por uno no es eficiente ni escalable. En su lugar, lo que podemos hacer
es agrupar esos eventos en lotes (`batching`) basados en un intervalo de tiempo, como por ejemplo cada 5 segundos.

La idea es la siguiente:

- Recolectar todos los eventos emitidos durante un intervalo de 5 segundos.
- Al finalizar el intervalo, agruparlos en una lista.
- Insertar todos los eventos del lote en la base de datos de una sola vez.

Luego, esperamos otros 5 segundos, recolectamos los nuevos eventos, los agrupamos, y repetimos el proceso.

Esta t√©cnica nos permite mejorar la eficiencia y reducir la sobrecarga de operaciones individuales contra la base de
datos.

![01.png](assets/section-10/01.png)

### Ejemplo 01 - buffer()

Veamos un ejemplo donde se utiliza el operador `buffer()` con su comportamiento por defecto:

````java
// Recopilar items en funci√≥n del valor interno / tama√±o dado
public class Lec01Buffer {
    public static void main(String[] args) {
        demo1();

        Util.sleepSeconds(60);
    }

    private static void demo1() {
        eventStream() //Flux<String>
                .buffer()//Flux<List<String>>: intenta recopilar todos los elementos antes de emitir
                .subscribe(Util.subscriber());
    }

    // Simulando flujo de eventos
    private static Flux<String> eventStream() {
        return Flux.interval(Duration.ofMillis(200))
                .map(value -> "evento-" + (value + 1));
    }
}
````

El operador `buffer()` sin argumentos recopila todos los elementos emitidos por el `Flux` original en una sola lista, y
emite esa lista √∫nicamente cuando el `Flux` fuente se completa.

En este ejemplo, estamos simulando un flujo de eventos continuo (infinito), donde se emite un evento cada 200
milisegundos. Como el `Flux` nunca se completa (es infinito), el `buffer()` nunca emite nada. Por eso, al ejecutar este
c√≥digo no veremos ninguna salida en la consola, a pesar de que los eventos se est√°n generando.

> üîç Importante: `buffer()` sin par√°metros no es adecuado para flujos infinitos si esperamos recibir resultados durante
> la ejecuci√≥n. Para esos casos, se recomienda usar variantes de `buffer` con condiciones de `tiempo` o `cantidad`,
> como `buffer(Duration)` o `buffer(int)`.

### Ejemplo 02 - buffer(int)

Veamos otro ejemplo donde usamos `buffer(int)` para recolectar elementos en grupos de 3:

````java
public class Lec01Buffer {
    public static void main(String[] args) {
        demo2();

        Util.sleepSeconds(60);
    }

    private static void demo2() {
        eventStream()
                .buffer(3)// Agrupa cada 3 elementos emitidos en una lista
                .subscribe(Util.subscriber());
    }

    private static Flux<String> eventStream() {
        return Flux.interval(Duration.ofMillis(200))
                .map(value -> "evento-" + (value + 1));
    }
}
````

En este caso, el operador `buffer(3)` agrupa cada 3 elementos emitidos por el `Flux` fuente en una lista, y luego
emite esa lista como un nuevo √≠tem en el flujo resultante (`Flux<List<String>>`).

Como resultado, obtendremos salidas similares a las siguientes:

````bash
10:30:05.423 INFO  [     parallel-1] d.m.a.common.DefaultSubscriber :  recibido: [evento-1, evento-2, evento-3]
10:30:06.029 INFO  [     parallel-1] d.m.a.common.DefaultSubscriber :  recibido: [evento-4, evento-5, evento-6]
10:30:06.619 INFO  [     parallel-1] d.m.a.common.DefaultSubscriber :  recibido: [evento-7, evento-8, evento-9]
10:30:07.226 INFO  [     parallel-1] d.m.a.common.DefaultSubscriber :  recibido: [evento-10, evento-11, evento-12]
10:30:07.834 INFO  [     parallel-1] d.m.a.common.DefaultSubscriber :  recibido: [evento-13, evento-14, evento-15]
...
````

Como puedes ver, el `Flux` original emite un evento cada 200 milisegundos, y `buffer(3)` recolecta esos eventos en
bloques de 3 antes de pasarlos al subscriber.

> üìå `Nota`: Esta forma de `batching` es √∫til cuando queremos procesar m√∫ltiples elementos juntos por cantidad,
> en lugar de tiempo. Es eficiente para reducir la cantidad de operaciones repetitivas, como llamadas a bases de datos
> o servicios externos.

### Ejemplo 03 - buffer(Duration)

Ahora veamos un caso en el que usamos el operador `buffer(Duration)` para recolectar elementos en funci√≥n del tiempo.

````java
public class Lec01Buffer {
    public static void main(String[] args) {
        demo3();

        Util.sleepSeconds(60);
    }

    private static void demo3() {
        eventStream()
                .buffer(Duration.ofMillis(500))//Le decimos que recoja items dentro de 500 milisegundos
                .subscribe(Util.subscriber());
    }

    private static Flux<String> eventStream() {
        return Flux.interval(Duration.ofMillis(200))
                .map(value -> "evento-" + (value + 1));
    }
}
````

En este ejemplo, `buffer(Duration.ofMillis(500))` agrupa todos los elementos que llegan dentro de una ventana de 500
milisegundos. A diferencia de `buffer(int)`, aqu√≠ la agrupaci√≥n se basa en el tiempo y no en la cantidad de elementos.

Esto implica que la cantidad de elementos en cada lista puede variar, dependiendo de cu√°ntos eventos lleguen dentro del
intervalo de 500 ms.

````bash
10:34:59.745 INFO  [     parallel-1] d.m.a.common.DefaultSubscriber :  recibido: [evento-1, evento-2]
10:35:00.237 INFO  [     parallel-1] d.m.a.common.DefaultSubscriber :  recibido: [evento-3, evento-4]
10:35:00.738 INFO  [     parallel-1] d.m.a.common.DefaultSubscriber :  recibido: [evento-5, evento-6, evento-7]
10:35:01.237 INFO  [     parallel-1] d.m.a.common.DefaultSubscriber :  recibido: [evento-8, evento-9]
10:35:01.733 INFO  [     parallel-1] d.m.a.common.DefaultSubscriber :  recibido: [evento-10, evento-11, evento-12]
...
````

> üß† `Observaci√≥n`: Como los eventos se generan cada 200 ms, en teor√≠a podr√≠amos recibir 2 o 3 eventos por cada ventana
> de 500 ms, dependiendo de la alineaci√≥n temporal entre la generaci√≥n de eventos y la apertura de cada ventana de
> tiempo.

### Ejemplo 04 - bufferTimeout(int, Duration)

Como √∫ltimo ejemplo, utilizaremos el operador `bufferTimeout(int, Duration)`, el cual permite agrupar elementos seg√∫n
dos condiciones: un `n√∫mero m√°ximo de items` o un `tiempo m√°ximo de espera`, lo que ocurra primero.

````java
public class Lec01Buffer {
    public static void main(String[] args) {
        demo4();

        Util.sleepSeconds(60);
    }

    private static void demo4() {
        eventStream()
                .bufferTimeout(3, Duration.ofSeconds(1))// Agrupa cada 3 elementos o espera 1 segundo m√°ximo
                .subscribe(Util.subscriber());
    }

    private static Flux<String> eventStream() {
        return Flux.interval(Duration.ofMillis(200))
                .take(10)                   // Emitimos solo 10 eventos
                .concatWith(Flux.never())   // Evita la finalizaci√≥n del flujo para ver el comportamiento del √∫ltimo buffer
                .map(value -> "evento-" + (value + 1));
    }
}
````

En este ejemplo:

- `bufferTimeout(3, Duration.ofSeconds(1))` intenta recolectar 3 elementos.
- Si no los obtiene en 1 segundo, `emite lo que tenga disponible hasta ese momento`.
- Luego del d√©cimo elemento, no se emiten m√°s valores, ni error, ni evento de finalizaci√≥n (onComplete), ya que usamos
  `Flux.never()` para mantener el flujo `abierto`.

````bash
10:46:52.126 INFO  [     parallel-1] d.m.a.common.DefaultSubscriber :  recibido: [evento-1, evento-2, evento-3]
10:46:52.713 INFO  [     parallel-1] d.m.a.common.DefaultSubscriber :  recibido: [evento-4, evento-5, evento-6]
10:46:53.321 INFO  [     parallel-1] d.m.a.common.DefaultSubscriber :  recibido: [evento-7, evento-8, evento-9]
10:46:54.528 INFO  [     parallel-2] d.m.a.common.DefaultSubscriber :  recibido: [evento-10]
````

> üß† `Observaci√≥n`: Si hubi√©ramos utilizado solo `buffer(3)`, el √∫ltimo elemento (`evento-10`) no se habr√≠a emitido, ya
> que el operador esperar√≠a por dos elementos m√°s para completar el grupo. Con `bufferTimeout`, logramos emitir incluso
> los grupos incompletos tras un tiempo l√≠mite.
