# Secci√≥n 8: [Opcional] - Backpressure / Estrategia de desbordamiento

---

## Introducci√≥n

Sabemos que los flujos reactivos se centran en el procesamiento as√≠ncrono y no bloqueante de datos, con soporte para el
manejo de contrapresi√≥n (`backpressure`).

En algunos casos, el `subscriber` puede decir: `‚Äú¬°Dame todo!‚Äù`. Como resultado, el `publisher` empezar√° a emitir los
elementos muy r√°pidamente. Sin embargo, el `subscriber` podr√≠a no ser capaz de procesarlos con la misma velocidad, lo
que provoca un desbalance.

Aqu√≠ es donde entra en juego el manejo de la `contrapresi√≥n (backpressure)`: el `productor` deber√≠a ser capaz de
`ajustar autom√°ticamente la velocidad de emisi√≥n` en funci√≥n de la capacidad de consumo del subscriber.

![01.png](assets/section-08/01.png)

En `programaci√≥n reactiva`, especialmente con `Project Reactor`, el manejo de `backpressure` es esencial para evitar que
un `subscriber` se vea desbordado por la velocidad con la que el publisher emite datos. El objetivo es que el sistema
sea resiliente bajo distintas cargas y que funcione de manera reactiva y adaptable.

## Manejo autom√°tico de la contrapresi√≥n

Para que quede muy claro, *la contrapresi√≥n es un problema que ocurre cuando el productor genera elementos m√°s r√°pido
de lo que el consumidor puede procesarlos*.

### Sin contrapresi√≥n visible

Si ejecutamos el siguiente c√≥digo, `no veremos ning√∫n problema de contrapresi√≥n`.

````java
public class Lec01BackPressureHandling {

    private static final Logger log = LoggerFactory.getLogger(Lec01BackPressureHandling.class);

    public static void main(String[] args) {
        Flux<Integer> producer = Flux.generate(
                () -> 1,
                (state, synchronousSink) -> {
                    log.info("Generando: {}", state);
                    synchronousSink.next(state);
                    return ++state;
                }
        );

        producer
                .map(state -> timeConsumingTask(state))
                .subscribe(Util.subscriber());
    }

    private static final int timeConsumingTask(int i) {
        Util.sleepSeconds(1);
        return i;
    }
}
````

En este ejemplo, `no se produce contrapresi√≥n` porque el `Flux.generate(...)` y el `.subscribe(...)` operan en el mismo
hilo (`main`). Eso significa que el `productor` no puede generar un nuevo valor hasta que el `consumidor` haya
terminado de procesar el actual. Es decir, `el procesamiento es sincr√≥nico y secuencial`, lo cual previene cualquier
desbordamiento o acumulaci√≥n.

````bash
13:10:32.451 INFO  [           main] .a.s.Lec01BackPressureHandling : Generando: 1
13:10:33.464 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 1
13:10:33.464 INFO  [           main] .a.s.Lec01BackPressureHandling : Generando: 2
13:10:34.479 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 2
13:10:34.479 INFO  [           main] .a.s.Lec01BackPressureHandling : Generando: 3
13:10:35.482 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 3
...
...
````

### Manejo autom√°tico de contrapresi√≥n en Reactor

Ahora, con el fin de recrear el problema, de ver la contrapresi√≥n y c√≥mo es que reactor lo maneja autom√°ticamente vamos
a modificar el c√≥digo anterior.

````java
public class Lec01BackPressureHandling {

    private static final Logger log = LoggerFactory.getLogger(Lec01BackPressureHandling.class);

    public static void main(String[] args) {
        Flux<Integer> producer = Flux.generate(
                () -> 1,
                (state, synchronousSink) -> {
                    log.info("Generando: {}", state);
                    synchronousSink.next(state);
                    return ++state;
                }
        );

        producer
                .publishOn(Schedulers.boundedElastic()) //<----- Se agreg√≥ este Scheduler
                .map(state -> timeConsumingTask(state))
                .subscribe(Util.subscriber());

        Util.sleepSeconds(60);
    }

    private static int timeConsumingTask(int i) {
        Util.sleepSeconds(1);
        return i;
    }
}
````

‚úÖ Lo que hicimos:

- Usamos `Flux.generate()` para generar datos de forma secuencial desde un solo hilo (el hilo `main`).
- Agregamos el `publishOn(Schedulers.boundedElastic())` para mover el procesamiento posterior a otro hilo (uno de tipo
  `boundedElastic`, pensado para tareas bloqueantes o pesadas).
- En el `map()`, simulamos una tarea costosa con `sleepSeconds(1)`, es decir, cada elemento toma 1 segundo en
  procesarse.
- Nos subscribimos a ese flujo usando `Util.subscriber()` y dimos tiempo suficiente para ver el comportamiento
  (`Util.sleepSeconds(60)`).

‚ö†Ô∏è Qu√© se observa:

- El productor genera r√°pidamente los elementos desde el hilo `main`.
- El consumidor va lento, ya que est√° simulando una tarea costosa.
- El productor `llega hasta 256 elementos` y luego `se detiene temporalmente`, aunque el consumidor a√∫n no termina de
  consumir.

ü§ñ C√≥mo lo maneja Reactor:

- Reactor utiliza una `cola interna` con `capacidad limitada` (por defecto, `256 elementos` para `publishOn`), lo que
  act√∫a como un `buffer`. Cuando este buffer se llena:
- El publisher `deja de emitir temporalmente`.
- Espera a que el consumidor consuma elementos y libere espacio.
- Luego contin√∫a generando nuevos elementos.

Eso es `backpressure autom√°tica`: el sistema se regula sin que t√∫ tengas que escribir c√≥digo manual de control.

El productor procesar√° hasta 256 (el hilo principal se detuvo autom√°ticamente en ese valor) y esperar√° a que el
consumidor se ponga al d√≠a poco a poco. As√≠ es como reactor maneja autom√°ticamente la contrapresi√≥n.

````bash
15:59:23.005 INFO  [           main] .a.s.Lec01BackPressureHandling : Generando: 1
15:59:23.008 INFO  [           main] .a.s.Lec01BackPressureHandling : Generando: 2
15:59:23.008 INFO  [           main] .a.s.Lec01BackPressureHandling : Generando: 3
15:59:23.008 INFO  [           main] .a.s.Lec01BackPressureHandling : Generando: 4
15:59:23.008 INFO  [           main] .a.s.Lec01BackPressureHandling : Generando: 5
15:59:23.008 INFO  [           main] .a.s.Lec01BackPressureHandling : Generando: 6
15:59:23.008 INFO  [           main] .a.s.Lec01BackPressureHandling : Generando: 7
15:59:23.008 INFO  [           main] .a.s.Lec01BackPressureHandling : Generando: 8
...
16:01:27.812 INFO  [           main] .a.s.Lec01BackPressureHandling : Generando: 254
16:01:27.812 INFO  [           main] .a.s.Lec01BackPressureHandling : Generando: 255
16:01:27.812 INFO  [           main] .a.s.Lec01BackPressureHandling : Generando: 256
16:01:28.800 INFO  [oundedElastic-1] d.m.a.common.DefaultSubscriber :  recibido: 1
16:01:29.813 INFO  [oundedElastic-1] d.m.a.common.DefaultSubscriber :  recibido: 2
16:01:30.822 INFO  [oundedElastic-1] d.m.a.common.DefaultSubscriber :  recibido: 3
16:01:31.832 INFO  [oundedElastic-1] d.m.a.common.DefaultSubscriber :  recibido: 4
...
````

‚úÖ Conclusi√≥n:

El ejemplo `demuestra la contrapresi√≥n autom√°tica` en acci√≥n: el productor es mucho m√°s r√°pido, pero no desborda al
consumidor porque Reactor `detiene la emisi√≥n al llegar al l√≠mite del buffer (256 elementos)`, y solo reanuda cuando se
ha liberado al menos el `75% del buffer`, es decir, cuando hay suficiente espacio disponible
(aproximadamente 192 elementos procesados).

### Contrapresi√≥n autom√°tica con productor en hilo paralelo

Este ejemplo es, muy similar al anterior que analizamos, con una diferencia clave: *ahora el productor no est√° en el
hilo principal, sino en un hilo del* `Schedulers.parallel()`. Aun as√≠, se sigue aplicando contrapresi√≥n autom√°tica,
igual que en el ejemplo anterior.

````java
public class Lec01BackPressureHandling {

    private static final Logger log = LoggerFactory.getLogger(Lec01BackPressureHandling.class);

    public static void main(String[] args) {
        Flux<Integer> producer = Flux.generate(
                        () -> 1,
                        (state, synchronousSink) -> {
                            log.info("Generando: {}", state);
                            synchronousSink.next(state);
                            return ++state;
                        }
                ).cast(Integer.class)
                .subscribeOn(Schedulers.parallel());        //<--------- Scheduler

        producer
                .publishOn(Schedulers.boundedElastic())     //<--------- Scheduler
                .map(state -> timeConsumingTask(state))
                .subscribe(Util.subscriber());

        Util.sleepSeconds(60);
    }

    private static int timeConsumingTask(int i) {
        Util.sleepSeconds(1);
        return i;
    }
}
````

Este ejemplo muestra que `no es necesario estar en el hilo principal` para que `Reactor` limite la producci√≥n:
incluso si el `Flux.generate` corre en otro hilo (`parallel`), la contrapresi√≥n sigue funcionando correctamente.

````bash
16:22:33.135 INFO  [     parallel-1] .a.s.Lec01BackPressureHandling : Generando: 1
16:22:33.138 INFO  [     parallel-1] .a.s.Lec01BackPressureHandling : Generando: 2
16:22:33.138 INFO  [     parallel-1] .a.s.Lec01BackPressureHandling : Generando: 3
16:22:33.138 INFO  [     parallel-1] .a.s.Lec01BackPressureHandling : Generando: 4
...
16:22:33.152 INFO  [     parallel-1] .a.s.Lec01BackPressureHandling : Generando: 254
16:22:33.152 INFO  [     parallel-1] .a.s.Lec01BackPressureHandling : Generando: 255
16:22:33.152 INFO  [     parallel-1] .a.s.Lec01BackPressureHandling : Generando: 256
16:22:34.146 INFO  [oundedElastic-1] d.m.a.common.DefaultSubscriber :  recibido: 1
16:22:35.162 INFO  [oundedElastic-1] d.m.a.common.DefaultSubscriber :  recibido: 2
16:22:36.168 INFO  [oundedElastic-1] d.m.a.common.DefaultSubscriber :  recibido: 3
````

### Contrapresi√≥n con B√∫fer Limitado: Control del Ritmo del Productor

En el ejemplo anterior, como no se estableci√≥ un l√≠mite al tama√±o del b√∫fer, el productor gener√≥ exactamente
`256 elementos` de forma inmediata, muy por delante del consumidor. Aun as√≠, Reactor aplic√≥ contrapresi√≥n autom√°tica
en segundo plano gracias al uso de los Schedulers.

En este nuevo ejemplo, al ajustar el tama√±o del b√∫fer con `System.setProperty("reactor.bufferSize.small", "16")`
se fuerza a detener al productor despu√©s de emitir `16 elementos`, hasta que el consumidor procese algunos y libere
espacio. Esto da una demostraci√≥n clara del control de flujo y c√≥mo `Reactor` evita el desbordamiento de memoria o
saturaci√≥n del consumidor.

````java
public class Lec01BackPressureHandling {
    private static final Logger log = LoggerFactory.getLogger(Lec01BackPressureHandling.class);

    public static void main(String[] args) {
        System.setProperty("reactor.bufferSize.small", "16"); //<---- Ajustamos el tama√±o de la cola, solo fines demostrativos

        Flux<Integer> producer = Flux.generate(
                        () -> 1,
                        (state, synchronousSink) -> {
                            log.info("Generando: {}", state);
                            synchronousSink.next(state);
                            return ++state;
                        }
                ).cast(Integer.class)
                .subscribeOn(Schedulers.parallel());

        producer
                .publishOn(Schedulers.boundedElastic())
                .map(state -> timeConsumingTask(state))
                .subscribe(Util.subscriber());

        Util.sleepSeconds(60);
    }

    private static int timeConsumingTask(int i) {
        Util.sleepSeconds(1);
        return i;
    }
}
````

Este ejemplo hace visible el comportamiento de contrapresi√≥n en tiempo real, gracias al `b√∫fer limitado`. Es clave para
comprender:

- C√≥mo el productor se detiene autom√°ticamente al llenarse el b√∫fer (por ejemplo, con el l√≠mite de 16 elementos si se
  establece `reactor.bufferSize.small=16`).
- Cu√°ndo se reanuda: no inmediatamente, sino `cuando el consumidor ha liberado al menos el 75% del b√∫fer`, es decir,
  cuando hay suficiente espacio disponible.
- Que todo este control ocurre de forma autom√°tica, sin necesidad de escribir c√≥digo adicional por parte del
  desarrollador.

````bash
16:56:59.883 INFO  [     parallel-1] .a.s.Lec01BackPressureHandling : Generando: 1
16:56:59.886 INFO  [     parallel-1] .a.s.Lec01BackPressureHandling : Generando: 2
16:56:59.886 INFO  [     parallel-1] .a.s.Lec01BackPressureHandling : Generando: 3
16:56:59.886 INFO  [     parallel-1] .a.s.Lec01BackPressureHandling : Generando: 4
...
16:56:59.887 INFO  [     parallel-1] .a.s.Lec01BackPressureHandling : Generando: 13
16:56:59.887 INFO  [     parallel-1] .a.s.Lec01BackPressureHandling : Generando: 14
16:56:59.887 INFO  [     parallel-1] .a.s.Lec01BackPressureHandling : Generando: 15
16:56:59.887 INFO  [     parallel-1] .a.s.Lec01BackPressureHandling : Generando: 16
16:57:00.894 INFO  [oundedElastic-1] d.m.a.common.DefaultSubscriber :  recibido: 1
16:57:01.905 INFO  [oundedElastic-1] d.m.a.common.DefaultSubscriber :  recibido: 2
16:57:02.920 INFO  [oundedElastic-1] d.m.a.common.DefaultSubscriber :  recibido: 3
16:57:03.926 INFO  [oundedElastic-1] d.m.a.common.DefaultSubscriber :  recibido: 4
16:57:04.935 INFO  [oundedElastic-1] d.m.a.common.DefaultSubscriber :  recibido: 5
16:57:05.946 INFO  [oundedElastic-1] d.m.a.common.DefaultSubscriber :  recibido: 6
16:57:06.959 INFO  [oundedElastic-1] d.m.a.common.DefaultSubscriber :  recibido: 7
16:57:07.970 INFO  [oundedElastic-1] d.m.a.common.DefaultSubscriber :  recibido: 8
16:57:08.980 INFO  [oundedElastic-1] d.m.a.common.DefaultSubscriber :  recibido: 9
16:57:09.992 INFO  [oundedElastic-1] d.m.a.common.DefaultSubscriber :  recibido: 10
16:57:10.998 INFO  [oundedElastic-1] d.m.a.common.DefaultSubscriber :  recibido: 11
16:57:12.011 INFO  [oundedElastic-1] d.m.a.common.DefaultSubscriber :  recibido: 12
16:57:12.012 INFO  [     parallel-1] .a.s.Lec01BackPressureHandling : Generando: 17
16:57:12.012 INFO  [     parallel-1] .a.s.Lec01BackPressureHandling : Generando: 18
...
````

## Limit Rate

En la lecci√≥n anterior vimos c√≥mo Reactor gestiona la contrapresi√≥n autom√°ticamente, y c√≥mo es posible ajustar el tama√±o
del buffer interno con la propiedad `System.setProperty("reactor.bufferSize.small", "16")`. Sin embargo, en aplicaciones
reales no es recomendable manipular directamente ese buffer; ese ajuste solo se us√≥ aqu√≠ con fines demostrativos.

Para indicarle al productor que el consumidor tiene una capacidad limitada y evitar que se env√≠en m√°s elementos de los
que puede manejar, `Reactor` ofrece el operador `.limitRate(...)`.

Por ejemplo, `.limitRate(5)` indica que el `consumidor solicitar√° como m√°ximo 5 elementos a la vez`, lo que regula el
ritmo al que el `productor` env√≠a los datos y ayuda a evitar la sobrecarga del sistema.

````java

public class Lec02LimitRate {

    private static final Logger log = LoggerFactory.getLogger(Lec02LimitRate.class);

    public static void main(String[] args) {

        Flux<Integer> producer = Flux.generate(
                        () -> 1,
                        (state, synchronousSink) -> {
                            log.info("Generando: {}", state);
                            synchronousSink.next(state);
                            return ++state;
                        }
                ).cast(Integer.class)
                .subscribeOn(Schedulers.parallel());

        producer
                .limitRate(5)                           //<-- Indica que el productor solo produzca 5 elementos
                .publishOn(Schedulers.boundedElastic())
                .map(state -> timeConsumingTask(state))
                .subscribe(Util.subscriber());

        Util.sleepSeconds(60);
    }

    private static int timeConsumingTask(int i) {
        Util.sleepSeconds(1);
        return i;
    }
}
````

En la pr√°ctica, lo que hace `limitRate(5)` es pedir inicialmente 5 elementos del productor. Conforme el consumidor
procesa elementos y libera espacio en el buffer interno, `Reactor` solicita m√°s elementos al productor, pero no en lotes
individuales, sino cuando la `cantidad consumida` alcanza un umbral del `75% de los elementos` solicitados. Esto
significa que:

- Se solicitan 5 elementos al inicio.
- Cuando se han consumido alrededor de 3 o 4 elementos (`75% de 5`), Reactor solicita m√°s elementos al productor.
- Esto evita solicitar elemento por elemento y reduce el overhead de solicitud, optimizando el flujo.

As√≠, `limitRate` ayuda a controlar el ritmo del productor para que no sobrecargue al consumidor ni al `buffer`,
sin que el desarrollador tenga que manejar esto manualmente.

Ejemplo de salida:

````bash
17:34:01.771 INFO  [     parallel-1] d.m.app.sec08.Lec02LimitRate   : Generando: 1
17:34:01.774 INFO  [     parallel-1] d.m.app.sec08.Lec02LimitRate   : Generando: 2
17:34:01.774 INFO  [     parallel-1] d.m.app.sec08.Lec02LimitRate   : Generando: 3
17:34:01.774 INFO  [     parallel-1] d.m.app.sec08.Lec02LimitRate   : Generando: 4
17:34:01.774 INFO  [     parallel-1] d.m.app.sec08.Lec02LimitRate   : Generando: 5
17:34:02.787 INFO  [oundedElastic-1] d.m.a.common.DefaultSubscriber :  recibido: 1
17:34:03.797 INFO  [oundedElastic-1] d.m.a.common.DefaultSubscriber :  recibido: 2
17:34:04.810 INFO  [oundedElastic-1] d.m.a.common.DefaultSubscriber :  recibido: 3
17:34:04.811 INFO  [     parallel-1] d.m.app.sec08.Lec02LimitRate   : Generando: 6
17:34:04.811 INFO  [     parallel-1] d.m.app.sec08.Lec02LimitRate   : Generando: 7
17:34:04.811 INFO  [     parallel-1] d.m.app.sec08.Lec02LimitRate   : Generando: 8
17:34:04.811 INFO  [     parallel-1] d.m.app.sec08.Lec02LimitRate   : Generando: 9
17:34:05.820 INFO  [oundedElastic-1] d.m.a.common.DefaultSubscriber :  recibido: 4
17:34:06.833 INFO  [oundedElastic-1] d.m.a.common.DefaultSubscriber :  recibido: 5
...
````

En resumen, `limitRate` es una forma sencilla y eficiente de comunicar al productor un l√≠mite razonable de producci√≥n
acorde con la capacidad del consumidor, evitando saturaciones y optimizando el flujo sin complicar la l√≥gica con c√≥digo
extra.
