# Sección 14: Unit Testing With Step Verifier

---

## Introducción

Las pruebas unitarias permiten verificar el comportamiento de pequeñas unidades de código (como métodos o funciones) de
forma aislada, asegurando que produzcan los resultados esperados.

En `programación reactiva` con `Reactor`, los publishers como `Mono` y `Flux` se comportan de forma asíncrona y
perezosa, por lo que su verificación requiere herramientas especializadas. Ahí es donde entra `StepVerifier`.

`StepVerifier` es una utilidad de pruebas provista por `Reactor` que permite simular suscripciones y verificar de
manera declarativa los eventos emitidos por un `Flux` o `Mono` (como `elementos`, `errores` o `finalización`).

Esto facilita escribir pruebas precisas, legibles y controladas para flujos reactivos.

## Unit Testing Mono

En este ejemplo se realiza una prueba unitaria sobre un `Mono` utilizando `StepVerifier`, que actúa como un suscriptor
simulado.

### ¿Qué es StepVerifier?

`StepVerifier` es una herramienta de pruebas incluida en Reactor que nos permite verificar el comportamiento de un
`Mono` o `Flux` paso a paso. Funciona como un `suscriptor controlado`, que `simula la suscripción al publisher` y
valida los eventos que este emite.

En este caso:

- `StepVerifier.create(...)`, prepara un verificador que se comportará como un suscriptor simulado. Pero aún no se ha
  suscrito al `publisher`. Es como preparar un plan de pruebas, pero no ejecutarlo.
- `.expectNext("product-1")`, indica que se espera ese valor como el siguiente emitido.
- `.expectComplete()`, indica que se espera que el flujo finalice correctamente (sin errores).
- `.verify()`, **es el momento en que realmente se activa la suscripción.** Antes de este punto, el `Mono` no ejecuta
  nada, debido a su naturaleza perezosa (`lazy`). Entonces, la suscripción real sucede cuando se llama al `.verify()`.
  Es en ese momento que el `Mono` comienza a ejecutarse.

````java
// StepVerifier actúa como un suscriptor
class Lec01MonoTest {
    private static final Logger log = LoggerFactory.getLogger(Lec01MonoTest.class);

    private Mono<String> getProduct(int id) {
        return Mono.fromSupplier(() -> "product-" + id)
                .doFirst(() -> log.info("invocado"));
    }

    @Test
    void productTest() {
        // given
        int id = 1;

        // when
        Mono<String> product = getProduct(id);

        // then
        StepVerifier.create(product)
                .expectNext("product-1")
                .expectComplete()
                .verify(); // Subscribe, aquí es donde se activa la suscripción
    }
}
````

Esto se confirma en el log:

````bash
11:13:56.176 INFO  [           main] d.magadiflo.app.Lec01MonoTest  : invocado
````

La línea `invocado` aparece solo cuando se llama a `.verify()`, lo que demuestra que es ahí cuando el `Mono` se ejecuta.
`StepVerifier` permite entonces probar flujos reactivos de forma precisa, declarativa y sincrónica dentro de pruebas
unitarias.

## Empty / Error - Validation

Esta clase `Lec02EmptyErrorTest` contiene varios tests para validar el comportamiento de un método que devuelve un
`Mono<String>` según el `userId`.

El método bajo prueba es el `getusername(...)` que dependiendo del `userId` devuelve un valor distinto:

- `1` devuelve un `Mono` con un valor `Marti`.
- `2` devuelve un `Mono` `vacío` (sin elementos).
- Cualquier otro valor devuelve un `error` de tipo `RuntimeException` con mensaje `Entrada inválida`.

````java

class Lec02EmptyErrorTest {
    private static final Logger log = LoggerFactory.getLogger(Lec02EmptyErrorTest.class);

    private Mono<String> getUsername(int userId) {
        return switch (userId) {
            case 1 -> Mono.just("Marti");
            case 2 -> Mono.empty();
            default -> Mono.error(new RuntimeException("Entrada inválida"));
        };
    }

    @Test
    void userTestSuccess() {
        // given
        int id = 1;

        // when
        Mono<String> user = getUsername(id);

        // then
        StepVerifier.create(user)
                .expectNext("Marti")
                .expectComplete()
                .verify();
    }

    @Test
    void userTestEmpty() {
        // given
        int id = 2;

        // when
        Mono<String> user = getUsername(id);

        // then
        StepVerifier.create(user)
                .expectComplete()
                .verify();
    }

    @Test
    void userTestError1() {
        // given
        int id = 3;

        // when
        Mono<String> user = getUsername(id);

        // then
        StepVerifier.create(user)
                .expectError()
                .verify();
    }

    @Test
    void userTestError2() {
        // given
        int id = 3;

        // when
        Mono<String> user = getUsername(id);

        // then
        StepVerifier.create(user)
                .expectError(RuntimeException.class)
                .verify();
    }

    @Test
    void userTestError3() {
        // given
        int id = 3;

        // when
        Mono<String> user = getUsername(id);

        // then
        StepVerifier.create(user)
                .expectErrorMessage("Entrada inválida")
                .verify();
    }

    @Test
    void userTestError4() {
        // given
        int id = 3;

        // when
        Mono<String> user = getUsername(id);

        // then
        StepVerifier.create(user)
                .expectErrorSatisfies(throwable -> {
                    Assertions.assertEquals(RuntimeException.class, throwable.getClass());
                    Assertions.assertEquals("Entrada inválida", throwable.getMessage());
                })
                .verify();
    }

    @Test
    void userTestError5() {
        // given
        int id = 3;

        // when
        Mono<String> user = getUsername(id);

        // then
        StepVerifier.create(user)
                .consumeErrorWith(throwable -> {
                    Assertions.assertEquals(RuntimeException.class, throwable.getClass());
                    Assertions.assertEquals("Entrada inválida", throwable.getMessage());
                })
                .verify();
    }
}
````

Descripción de cada método test

1. `userTestSuccess()`, verifica que para `userId = 1`, el `Mono` emite el valor `Marti` y `completa` correctamente.
2. `userTestEmpty()`, verifica que para `userId = 2`, el `Mono` emite ningún valor y completa correctamente (es un
   `Mono.empty()`).
3. `userTestError1()`, verifica que para `userId = 3`, el `Mono` emite un error, sin importar su tipo.
4. `userTestError2()`, verifica que el error emitido sea específicamente de tipo `RuntimeException`.
5. `userTestError3()`, verifica que el error emitido tenga el mensaje exacto `Entrada inválida`.
6. `userTestError4()`, verifica el error usando una función que recibe el `Throwable`, permitiendo hacer múltiples
   aserciones personalizadas sobre el tipo y el mensaje del error.
7. `userTestError5()`, similar a `userTestError4()`, consume el error para hacer aserciones personalizadas, pero usando
   el método `consumeErrorWith`.

Resumen

- Los tests cubren casos de emisión de valores, emisión vacía y emisión de errores.
- Hay varias formas de validar errores en Reactor con `StepVerifier`, desde simplemente esperar un error, hasta hacer
  validaciones más detalladas con lambdas personalizadas.
