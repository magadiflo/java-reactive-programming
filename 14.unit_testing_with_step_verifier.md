# Sección 14: Unit Testing With Step Verifier

---

## Introducción

Las pruebas unitarias permiten verificar el comportamiento de pequeñas unidades de código (como métodos o funciones) de
forma aislada, asegurando que produzcan los resultados esperados.

En `programación reactiva` con `Reactor`, los publishers como `Mono` y `Flux` se comportan de forma asíncrona y
perezosa, por lo que su verificación requiere herramientas especializadas. Ahí es donde entra `StepVerifier`.

`StepVerifier` es una utilidad de pruebas provista por `Reactor` que permite simular suscripciones y verificar de
manera declarativa los eventos emitidos por un `Flux` o `Mono` (como `elementos`, `errores` o `finalización`).

Esto facilita escribir pruebas precisas, legibles y controladas para flujos reactivos.

## Unit Testing Mono

En este ejemplo se realiza una prueba unitaria sobre un `Mono` utilizando `StepVerifier`, que actúa como un suscriptor
simulado.

### ¿Qué es StepVerifier?

`StepVerifier` es una herramienta de pruebas incluida en Reactor que nos permite verificar el comportamiento de un
`Mono` o `Flux` paso a paso. Funciona como un `suscriptor controlado`, que `simula la suscripción al publisher` y
valida los eventos que este emite.

En este caso:

- `StepVerifier.create(...)`, prepara un verificador que se comportará como un suscriptor simulado. Pero aún no se ha
  suscrito al `publisher`. Es como preparar un plan de pruebas, pero no ejecutarlo.
- `.expectNext("product-1")`, indica que se espera ese valor como el siguiente emitido.
- `.expectComplete()`, indica que se espera que el flujo finalice correctamente (sin errores).
- `.verify()`, **es el momento en que realmente se activa la suscripción.** Antes de este punto, el `Mono` no ejecuta
  nada, debido a su naturaleza perezosa (`lazy`). Entonces, la suscripción real sucede cuando se llama al `.verify()`.
  Es en ese momento que el `Mono` comienza a ejecutarse.

````java
// StepVerifier actúa como un suscriptor
class Lec01MonoTest {
    private static final Logger log = LoggerFactory.getLogger(Lec01MonoTest.class);

    private Mono<String> getProduct(int id) {
        return Mono.fromSupplier(() -> "product-" + id)
                .doFirst(() -> log.info("invocado"));
    }

    @Test
    void productTest() {
        // given
        int id = 1;

        // when
        Mono<String> product = getProduct(id);

        // then
        StepVerifier.create(product)
                .expectNext("product-1")
                .expectComplete()
                .verify(); // Subscribe, aquí es donde se activa la suscripción
    }
}
````

Esto se confirma en el log:

````bash
11:13:56.176 INFO  [           main] d.magadiflo.app.Lec01MonoTest  : invocado
````

La línea `invocado` aparece solo cuando se llama a `.verify()`, lo que demuestra que es ahí cuando el `Mono` se ejecuta.
`StepVerifier` permite entonces probar flujos reactivos de forma precisa, declarativa y sincrónica dentro de pruebas
unitarias.

## Empty / Error - Validation

Esta clase `Lec02EmptyErrorTest` contiene varios tests para validar el comportamiento de un método que devuelve un
`Mono<String>` según el `userId`.

El método bajo prueba es el `getusername(...)` que dependiendo del `userId` devuelve un valor distinto:

- `1` devuelve un `Mono` con un valor `Marti`.
- `2` devuelve un `Mono` `vacío` (sin elementos).
- Cualquier otro valor devuelve un `error` de tipo `RuntimeException` con mensaje `Entrada inválida`.

````java

class Lec02EmptyErrorTest {
    private static final Logger log = LoggerFactory.getLogger(Lec02EmptyErrorTest.class);

    private Mono<String> getUsername(int userId) {
        return switch (userId) {
            case 1 -> Mono.just("Marti");
            case 2 -> Mono.empty();
            default -> Mono.error(new RuntimeException("Entrada inválida"));
        };
    }

    @Test
    void userTestSuccess() {
        // given
        int id = 1;

        // when
        Mono<String> user = getUsername(id);

        // then
        StepVerifier.create(user)
                .expectNext("Marti")
                .expectComplete()
                .verify();
    }

    @Test
    void userTestEmpty() {
        // given
        int id = 2;

        // when
        Mono<String> user = getUsername(id);

        // then
        StepVerifier.create(user)
                .expectComplete()
                .verify();
    }

    @Test
    void userTestError1() {
        // given
        int id = 3;

        // when
        Mono<String> user = getUsername(id);

        // then
        StepVerifier.create(user)
                .expectError()
                .verify();
    }

    @Test
    void userTestError2() {
        // given
        int id = 3;

        // when
        Mono<String> user = getUsername(id);

        // then
        StepVerifier.create(user)
                .expectError(RuntimeException.class)
                .verify();
    }

    @Test
    void userTestError3() {
        // given
        int id = 3;

        // when
        Mono<String> user = getUsername(id);

        // then
        StepVerifier.create(user)
                .expectErrorMessage("Entrada inválida")
                .verify();
    }

    @Test
    void userTestError4() {
        // given
        int id = 3;

        // when
        Mono<String> user = getUsername(id);

        // then
        StepVerifier.create(user)
                .expectErrorSatisfies(throwable -> {
                    Assertions.assertEquals(RuntimeException.class, throwable.getClass());
                    Assertions.assertEquals("Entrada inválida", throwable.getMessage());
                })
                .verify();
    }

    @Test
    void userTestError5() {
        // given
        int id = 3;

        // when
        Mono<String> user = getUsername(id);

        // then
        StepVerifier.create(user)
                .consumeErrorWith(throwable -> {
                    Assertions.assertEquals(RuntimeException.class, throwable.getClass());
                    Assertions.assertEquals("Entrada inválida", throwable.getMessage());
                })
                .verify();
    }
}
````

Descripción de cada método test

1. `userTestSuccess()`, verifica que para `userId = 1`, el `Mono` emite el valor `Marti` y `completa` correctamente.
2. `userTestEmpty()`, verifica que para `userId = 2`, el `Mono` emite ningún valor y completa correctamente (es un
   `Mono.empty()`).
3. `userTestError1()`, verifica que para `userId = 3`, el `Mono` emite un error, sin importar su tipo.
4. `userTestError2()`, verifica que el error emitido sea específicamente de tipo `RuntimeException`.
5. `userTestError3()`, verifica que el error emitido tenga el mensaje exacto `Entrada inválida`.
6. `userTestError4()`, verifica el error usando una función que recibe el `Throwable`, permitiendo hacer múltiples
   aserciones personalizadas sobre el tipo y el mensaje del error.
7. `userTestError5()`, similar a `userTestError4()`, consume el error para hacer aserciones personalizadas, pero usando
   el método `consumeErrorWith`.

Resumen

- Los tests cubren casos de emisión de valores, emisión vacía y emisión de errores.
- Hay varias formas de validar errores en Reactor con `StepVerifier`, desde simplemente esperar un error, hasta hacer
  validaciones más detalladas con lambdas personalizadas.

## Verify vs Expect

- El método `verifyError()` es equivalente a llamar `expectError().verify()`.
- El método `verifyComplete()` es equivalente a llamar `expectComplete().verify()`.

Ambos métodos son atajos que combinan la expectativa y la verificación en una sola llamada para simplificar el código en
pruebas unitarias con Reactor.

## Unit Testing Flux

### Ejemplo 01

Este test verifica que el `Flux` emita exactamente 6 elementos, sin importar cuáles sean.

- `expectNextCount(6)` espera 6 elementos consecutivos.
- `verifyComplete()` asegura que el `Flux` finalice correctamente (`onComplete`).

````java

class Lec03FluxTest {
    private Flux<Integer> getItems() {
        return Flux.just(1, 2, 3, 4, 5, 6)
                .log();
    }

    @Test
    void fluxTest1() {
        // given
        // when
        Flux<Integer> items = getItems();

        // then
        StepVerifier.create(items)
                .expectNextCount(6)
                .verifyComplete();
    }
}
````

### Ejemplo 02

Aquí se verifica que los primeros dos elementos sean 1 y 2, y luego que se emitan 4 elementos más (sin especificar sus
valores).

- `expectNext(1)` y `expectNext(2)` comprueban los dos primeros valores.
- `expectNextCount(4)` espera 4 elementos adicionales.
- `verifyComplete()` espera que el `Flux` termine sin errores.

````java

class Lec03FluxTest {
    private Flux<Integer> getItems() {
        return Flux.just(1, 2, 3, 4, 5, 6)
                .log();
    }

    @Test
    void fluxTest2() {
        // given
        // when
        Flux<Integer> items = getItems();

        // then
        StepVerifier.create(items)
                .expectNext(1)
                .expectNext(2)
                .expectNextCount(4)
                .verifyComplete();
    }
}
````

### Ejemplo 03

Este test espera que los primeros 4 elementos sean exactamente 1, 2, 3, 4, y que luego vengan 2 elementos más (sin
verificar su valor).

- `expectNext(1, 2, 3, 4)` verifica los primeros cuatro valores específicos.
- `expectNextCount(2)` espera 2 valores más.
- `verifyComplete()` valida que el flujo haya terminado correctamente.

````java

class Lec03FluxTest {
    private Flux<Integer> getItems() {
        return Flux.just(1, 2, 3, 4, 5, 6)
                .log();
    }

    @Test
    void fluxTest3() {
        // given
        // when
        Flux<Integer> items = getItems();

        // then
        StepVerifier.create(items)
                .expectNext(1, 2, 3, 4)
                .expectNextCount(2)
                .verifyComplete();
    }
}
````

### Ejemplo 04

Este test demuestra el uso del parámetro de demanda (`request`) al suscribirse con una demanda inicial de 2 elementos.

- `StepVerifier.create(items, 2)` indica que inicialmente se solicitan 2 elementos.
- `expectNext(1)` y `expectNext(2)` valida que se recibieron esos dos.
- `thenCancel()` simula una cancelación de la suscripción después de esos 2 elementos.
- `verify()` comprueba que la secuencia se comportó como se esperaba hasta ese punto.

````java

class Lec03FluxTest {
    private Flux<Integer> getItems() {
        return Flux.just(1, 2, 3, 4, 5, 6)
                .log();
    }

    @Test
    void fluxTest4() {
        // given
        // when
        Flux<Integer> items = getItems();

        // then
        StepVerifier.create(items, 2)
                .expectNext(1)
                .expectNext(2)
                .thenCancel()
                .verify();
    }
}
````

## StepVerifier - ExpectNextCount/Matches

Este test verifica que el `Flux` generado por `getRandomItems()`:

- `expectNextMatches(...)`:
    - Verifica que el `primer número` emitido cumpla con la condición: `i > 0 && i < 101`, es decir, esté entre
      `1 y 100 (inclusive)`.
    - Si no se cumple, el test falla de inmediato.
- `expectNextCount(49)`: Espera que después del primer número, se emitan 49 números más (totalizando 50).
- `verifyComplete()`: Verifica que el flujo se complete correctamente, sin errores.

````java
class Lec04RangeTest {
    private Flux<Integer> getRandomItems() {
        return Flux.range(1, 50)
                .map(i -> Util.faker().random().nextInt(1, 100));
    }

    @Test
    void rangeTest1() {
        // given
        // when
        Flux<Integer> items = getRandomItems();

        // then
        StepVerifier.create(items)
                .expectNextMatches(i -> i > 0 && i < 101)
                .expectNextCount(49)
                .verifyComplete();
    }
}
````

## StepVerifier - ThenConsumeWhile

Este test utiliza `StepVerifier` para validar que todos los elementos emitidos cumplan una condición:

- `thenConsumeWhile(i -> i > 0 && i < 101)`:
    - Consume todos los elementos mientras se cumpla la condición de que cada número esté en el rango `[1, 100]`.
    - Se detiene apenas encuentre un valor fuera de ese rango.
    - Todos los elementos que se consumen con esta función ya no se verifican de manera individual, sino por condición.

- `verifyComplete()`:
    - Verifica que el Flux haya terminado correctamente (es decir, que haya enviado una señal `onComplete` al final).
    - Si ocurre un error o se emiten más elementos luego de romper la condición, el test falla.

````java
class Lec04RangeTest {
    private Flux<Integer> getRandomItems() {
        return Flux.range(1, 50)
                .map(i -> Util.faker().random().nextInt(1, 100));
    }

    @Test
    void rangeTest2() {
        // given
        // when
        Flux<Integer> items = getRandomItems();

        // then
        StepVerifier.create(items)
                .thenConsumeWhile(i -> i > 0 && i < 101)
                .verifyComplete();
    }
}
````
