# Secci√≥n 14: Unit Testing With Step Verifier

---

## Introducci√≥n

Las pruebas unitarias permiten verificar el comportamiento de peque√±as unidades de c√≥digo (como m√©todos o funciones) de
forma aislada, asegurando que produzcan los resultados esperados.

En `programaci√≥n reactiva` con `Reactor`, los publishers como `Mono` y `Flux` se comportan de forma as√≠ncrona y
perezosa, por lo que su verificaci√≥n requiere herramientas especializadas. Ah√≠ es donde entra `StepVerifier`.

`StepVerifier` es una utilidad de pruebas provista por `Reactor` que permite simular suscripciones y verificar de
manera declarativa los eventos emitidos por un `Flux` o `Mono` (como `elementos`, `errores` o `finalizaci√≥n`).

Esto facilita escribir pruebas precisas, legibles y controladas para flujos reactivos.

## Unit Testing Mono

En este ejemplo se realiza una prueba unitaria sobre un `Mono` utilizando `StepVerifier`, que act√∫a como un suscriptor
simulado.

### ¬øQu√© es StepVerifier?

`StepVerifier` es una herramienta de pruebas incluida en Reactor que nos permite verificar el comportamiento de un
`Mono` o `Flux` paso a paso. Funciona como un `suscriptor controlado`, que `simula la suscripci√≥n al publisher` y
valida los eventos que este emite.

En este caso:

- `StepVerifier.create(...)`, prepara un verificador que se comportar√° como un suscriptor simulado. Pero a√∫n no se ha
  suscrito al `publisher`. Es como preparar un plan de pruebas, pero no ejecutarlo.
- `.expectNext("product-1")`, indica que se espera ese valor como el siguiente emitido.
- `.expectComplete()`, indica que se espera que el flujo finalice correctamente (sin errores).
- `.verify()`, **es el momento en que realmente se activa la suscripci√≥n.** Antes de este punto, el `Mono` no ejecuta
  nada, debido a su naturaleza perezosa (`lazy`). Entonces, la suscripci√≥n real sucede cuando se llama al `.verify()`.
  Es en ese momento que el `Mono` comienza a ejecutarse.

````java
// StepVerifier act√∫a como un suscriptor
class Lec01MonoTest {
    private static final Logger log = LoggerFactory.getLogger(Lec01MonoTest.class);

    private Mono<String> getProduct(int id) {
        return Mono.fromSupplier(() -> "product-" + id)
                .doFirst(() -> log.info("invocado"));
    }

    @Test
    void productTest() {
        // given
        int id = 1;

        // when
        Mono<String> product = getProduct(id);

        // then
        StepVerifier.create(product)
                .expectNext("product-1")
                .expectComplete()
                .verify(); // Subscribe, aqu√≠ es donde se activa la suscripci√≥n
    }
}
````

Esto se confirma en el log:

````bash
11:13:56.176 INFO  [           main] d.magadiflo.app.Lec01MonoTest  : invocado
````

La l√≠nea `invocado` aparece solo cuando se llama a `.verify()`, lo que demuestra que es ah√≠ cuando el `Mono` se ejecuta.
`StepVerifier` permite entonces probar flujos reactivos de forma precisa, declarativa y sincr√≥nica dentro de pruebas
unitarias.

## Empty / Error - Validation

Esta clase `Lec02EmptyErrorTest` contiene varios tests para validar el comportamiento de un m√©todo que devuelve un
`Mono<String>` seg√∫n el `userId`.

El m√©todo bajo prueba es el `getusername(...)` que dependiendo del `userId` devuelve un valor distinto:

- `1` devuelve un `Mono` con un valor `Marti`.
- `2` devuelve un `Mono` `vac√≠o` (sin elementos).
- Cualquier otro valor devuelve un `error` de tipo `RuntimeException` con mensaje `Entrada inv√°lida`.

````java

class Lec02EmptyErrorTest {
    private static final Logger log = LoggerFactory.getLogger(Lec02EmptyErrorTest.class);

    private Mono<String> getUsername(int userId) {
        return switch (userId) {
            case 1 -> Mono.just("Marti");
            case 2 -> Mono.empty();
            default -> Mono.error(new RuntimeException("Entrada inv√°lida"));
        };
    }

    @Test
    void userTestSuccess() {
        // given
        int id = 1;

        // when
        Mono<String> user = getUsername(id);

        // then
        StepVerifier.create(user)
                .expectNext("Marti")
                .expectComplete()
                .verify();
    }

    @Test
    void userTestEmpty() {
        // given
        int id = 2;

        // when
        Mono<String> user = getUsername(id);

        // then
        StepVerifier.create(user)
                .expectComplete()
                .verify();
    }

    @Test
    void userTestError1() {
        // given
        int id = 3;

        // when
        Mono<String> user = getUsername(id);

        // then
        StepVerifier.create(user)
                .expectError()
                .verify();
    }

    @Test
    void userTestError2() {
        // given
        int id = 3;

        // when
        Mono<String> user = getUsername(id);

        // then
        StepVerifier.create(user)
                .expectError(RuntimeException.class)
                .verify();
    }

    @Test
    void userTestError3() {
        // given
        int id = 3;

        // when
        Mono<String> user = getUsername(id);

        // then
        StepVerifier.create(user)
                .expectErrorMessage("Entrada inv√°lida")
                .verify();
    }

    @Test
    void userTestError4() {
        // given
        int id = 3;

        // when
        Mono<String> user = getUsername(id);

        // then
        StepVerifier.create(user)
                .expectErrorSatisfies(throwable -> {
                    Assertions.assertEquals(RuntimeException.class, throwable.getClass());
                    Assertions.assertEquals("Entrada inv√°lida", throwable.getMessage());
                })
                .verify();
    }

    @Test
    void userTestError5() {
        // given
        int id = 3;

        // when
        Mono<String> user = getUsername(id);

        // then
        StepVerifier.create(user)
                .consumeErrorWith(throwable -> {
                    Assertions.assertEquals(RuntimeException.class, throwable.getClass());
                    Assertions.assertEquals("Entrada inv√°lida", throwable.getMessage());
                })
                .verify();
    }
}
````

Descripci√≥n de cada m√©todo test

1. `userTestSuccess()`, verifica que para `userId = 1`, el `Mono` emite el valor `Marti` y `completa` correctamente.
2. `userTestEmpty()`, verifica que para `userId = 2`, el `Mono` emite ning√∫n valor y completa correctamente (es un
   `Mono.empty()`).
3. `userTestError1()`, verifica que para `userId = 3`, el `Mono` emite un error, sin importar su tipo.
4. `userTestError2()`, verifica que el error emitido sea espec√≠ficamente de tipo `RuntimeException`.
5. `userTestError3()`, verifica que el error emitido tenga el mensaje exacto `Entrada inv√°lida`.
6. `userTestError4()`, verifica el error usando una funci√≥n que recibe el `Throwable`, permitiendo hacer m√∫ltiples
   aserciones personalizadas sobre el tipo y el mensaje del error.
7. `userTestError5()`, similar a `userTestError4()`, consume el error para hacer aserciones personalizadas, pero usando
   el m√©todo `consumeErrorWith`.

Resumen

- Los tests cubren casos de emisi√≥n de valores, emisi√≥n vac√≠a y emisi√≥n de errores.
- Hay varias formas de validar errores en Reactor con `StepVerifier`, desde simplemente esperar un error, hasta hacer
  validaciones m√°s detalladas con lambdas personalizadas.

## Verify vs Expect

- El m√©todo `verifyError()` es equivalente a llamar `expectError().verify()`.
- El m√©todo `verifyComplete()` es equivalente a llamar `expectComplete().verify()`.

Ambos m√©todos son atajos que combinan la expectativa y la verificaci√≥n en una sola llamada para simplificar el c√≥digo en
pruebas unitarias con Reactor.

## Unit Testing Flux

### Ejemplo 01

Este test verifica que el `Flux` emita exactamente 6 elementos, sin importar cu√°les sean.

- `expectNextCount(6)` espera 6 elementos consecutivos.
- `verifyComplete()` asegura que el `Flux` finalice correctamente (`onComplete`).

````java

class Lec03FluxTest {
    private Flux<Integer> getItems() {
        return Flux.just(1, 2, 3, 4, 5, 6)
                .log();
    }

    @Test
    void fluxTest1() {
        // given
        // when
        Flux<Integer> items = getItems();

        // then
        StepVerifier.create(items)
                .expectNextCount(6)
                .verifyComplete();
    }
}
````

### Ejemplo 02

Aqu√≠ se verifica que los primeros dos elementos sean 1 y 2, y luego que se emitan 4 elementos m√°s (sin especificar sus
valores).

- `expectNext(1)` y `expectNext(2)` comprueban los dos primeros valores.
- `expectNextCount(4)` espera 4 elementos adicionales.
- `verifyComplete()` espera que el `Flux` termine sin errores.

````java

class Lec03FluxTest {
    private Flux<Integer> getItems() {
        return Flux.just(1, 2, 3, 4, 5, 6)
                .log();
    }

    @Test
    void fluxTest2() {
        // given
        // when
        Flux<Integer> items = getItems();

        // then
        StepVerifier.create(items)
                .expectNext(1)
                .expectNext(2)
                .expectNextCount(4)
                .verifyComplete();
    }
}
````

### Ejemplo 03

Este test espera que los primeros 4 elementos sean exactamente 1, 2, 3, 4, y que luego vengan 2 elementos m√°s (sin
verificar su valor).

- `expectNext(1, 2, 3, 4)` verifica los primeros cuatro valores espec√≠ficos.
- `expectNextCount(2)` espera 2 valores m√°s.
- `verifyComplete()` valida que el flujo haya terminado correctamente.

````java

class Lec03FluxTest {
    private Flux<Integer> getItems() {
        return Flux.just(1, 2, 3, 4, 5, 6)
                .log();
    }

    @Test
    void fluxTest3() {
        // given
        // when
        Flux<Integer> items = getItems();

        // then
        StepVerifier.create(items)
                .expectNext(1, 2, 3, 4)
                .expectNextCount(2)
                .verifyComplete();
    }
}
````

### Ejemplo 04

Este test demuestra el uso del par√°metro de demanda (`request`) al suscribirse con una demanda inicial de 2 elementos.

- `StepVerifier.create(items, 2)` indica que inicialmente se solicitan 2 elementos.
- `expectNext(1)` y `expectNext(2)` valida que se recibieron esos dos.
- `thenCancel()` simula una cancelaci√≥n de la suscripci√≥n despu√©s de esos 2 elementos.
- `verify()` comprueba que la secuencia se comport√≥ como se esperaba hasta ese punto.

````java

class Lec03FluxTest {
    private Flux<Integer> getItems() {
        return Flux.just(1, 2, 3, 4, 5, 6)
                .log();
    }

    @Test
    void fluxTest4() {
        // given
        // when
        Flux<Integer> items = getItems();

        // then
        StepVerifier.create(items, 2)
                .expectNext(1)
                .expectNext(2)
                .thenCancel()
                .verify();
    }
}
````

## StepVerifier - ExpectNextCount/Matches

Este test verifica que el `Flux` generado por `getRandomItems()`:

- `expectNextMatches(...)`:
    - Verifica que el `primer n√∫mero` emitido cumpla con la condici√≥n: `i > 0 && i < 101`, es decir, est√© entre
      `1 y 100 (inclusive)`.
    - Si no se cumple, el test falla de inmediato.
- `expectNextCount(49)`: Espera que despu√©s del primer n√∫mero, se emitan 49 n√∫meros m√°s (totalizando 50).
- `verifyComplete()`: Verifica que el flujo se complete correctamente, sin errores.

````java
class Lec04RangeTest {
    private Flux<Integer> getRandomItems() {
        return Flux.range(1, 50)
                .map(i -> Util.faker().random().nextInt(1, 100));
    }

    @Test
    void rangeTest1() {
        // given
        // when
        Flux<Integer> items = getRandomItems();

        // then
        StepVerifier.create(items)
                .expectNextMatches(i -> i > 0 && i < 101)
                .expectNextCount(49)
                .verifyComplete();
    }
}
````

## StepVerifier - ThenConsumeWhile

Este test utiliza `StepVerifier` para validar que todos los elementos emitidos cumplan una condici√≥n:

- `thenConsumeWhile(i -> i > 0 && i < 101)`:
    - Consume todos los elementos mientras se cumpla la condici√≥n de que cada n√∫mero est√© en el rango `[1, 100]`.
    - Se detiene apenas encuentre un valor fuera de ese rango.
    - Todos los elementos que se consumen con esta funci√≥n ya no se verifican de manera individual, sino por condici√≥n.

- `verifyComplete()`:
    - Verifica que el Flux haya terminado correctamente (es decir, que haya enviado una se√±al `onComplete` al final).
    - Si ocurre un error o se emiten m√°s elementos luego de romper la condici√≥n, el test falla.

````java
class Lec04RangeTest {
    private Flux<Integer> getRandomItems() {
        return Flux.range(1, 50)
                .map(i -> Util.faker().random().nextInt(1, 100));
    }

    @Test
    void rangeTest2() {
        // given
        // when
        Flux<Integer> items = getRandomItems();

        // then
        StepVerifier.create(items)
                .thenConsumeWhile(i -> i > 0 && i < 101)
                .verifyComplete();
    }
}
````

## StepVerifier - AssertNext

Verificar que los primeros dos libros generados cumplen ciertas condiciones, y luego continuar verificando los elementos
restantes mientras tengan un t√≠tulo no nulo.

- Se usa `assertNext(...)` para verificar el primer libro:
    - No es nulo.
    - Su ID es 1.
    - Tiene autor y t√≠tulo no nulos.
- Se usa `assertNext(...)` para verificar el segundo libro:
    - Su ID es 2.
    - No se hacen m√°s validaciones sobre este libro.
- Luego se usa `thenConsumeWhile(...)` para consumir el resto de los libros (IDs 3, 4 y 5), siempre que tengan
  un t√≠tulo no nulo.
- Finalmente, se espera que el `Flux` termine exitosamente con `verifyComplete()`.

````java
class Lec05AssertNextTest {
    record Book(int id, String author, String title) {
    }

    private Flux<Book> getBooks() {
        return Flux.range(1, 5)
                .map(i -> new Book(i, Util.faker().book().author(), Util.faker().book().title()));
    }

    @Test
    void assertNextTest() {
        // given
        // when
        Flux<Book> books = getBooks();

        // then
        StepVerifier.create(books)
                .assertNext(book -> {
                    Assertions.assertNotNull(book);
                    Assertions.assertEquals(1, book.id());
                    Assertions.assertNotNull(book.author());
                    Assertions.assertNotNull(book.title());
                })
                .assertNext(book -> Assertions.assertEquals(2, book.id()))
                .thenConsumeWhile(book -> Objects.nonNull(book.title()))
                .verifyComplete();

    }
}
````

## StepVerifier - CollectAll

Verificar que se emiten exactamente 5 libros en total.

- El `Flux<Book>` se transforma en un `Mono<List<Book>>` con `collectList()`, que recoge todos los elementos emitidos y
  los agrupa en una lista.
- Se usa `assertNext(...)` para validar que esa lista tiene exactamente 5 elementos.
- Se finaliza con `verifyComplete()` para asegurar que el flujo se complet√≥ normalmente.

````java
class Lec05AssertNextTest {
    record Book(int id, String author, String title) {
    }

    private Flux<Book> getBooks() {
        return Flux.range(1, 5)
                .map(i -> new Book(i, Util.faker().book().author(), Util.faker().book().title()));
    }

    @Test
    void collectAllAndTest() {
        // given
        // when
        Flux<Book> books = getBooks();

        // then
        StepVerifier.create(books.collectList())
                .assertNext(bookList -> Assertions.assertEquals(5, bookList.size()))
                .verifyComplete();

    }
}
````

## Virtual Time Scheduler

### Entendiendo el problema

El m√©todo `getItems()` devuelve un `Flux` que emitir√° los n√∫meros del `1 al 5`, pero cada elemento ser√° emitido con un
retraso de `10 segundos`.

El problema es que cuando ejecutamos el test `fluxTest()`, reactor usar√° el reloj real del sistema, es decir:

- Emitir√° 1 a los 10 segundos.
- Luego 2 a los 20 segundos.
- Luego 3 a los 30 segundos.
- Luego 4 a los 40 segundos.
- Finalmente 5 a los 50 segundos.

`Total: 50 segundos` de espera real para completar el test. Esto lo hace muy ineficiente para pruebas automatizadas o
cuando tienes muchos tests.

````java
class Lec06VirtualTimeTest {

    private Flux<Integer> getItems() {
        return Flux.range(1, 5)
                .delayElements(Duration.ofSeconds(10));
    }

    // Nosotros no podemos correr asi, es decir, esperar√° a 50 segundos para ejecutar el test
    @Test
    void fluxTest() {
        StepVerifier.create(getItems())
                .expectNext(1, 2, 3, 4, 5)
                .verifyComplete();
    }
}
````

### Soluci√≥n: withVirtualTime

La forma correcta de probar este tipo de l√≥gica basada en tiempo sin esperar realmente 50 segundos es usar
`StepVerifier.withVirtualTime`.

Este m√©todo simula el paso del tiempo, permiti√©ndote avanzar el `reloj virtual` con `thenAwait(...)`, y as√≠ verificar
el comportamiento del flujo sin demoras reales.

### üìù Nota: Uso correcto de `withVirtualTime` en `StepVerifier`

> Cuando usamos `StepVerifier.withVirtualTime`, es fundamental que el `Flux` o `Mono` bajo prueba se construya dentro
> del `Supplier` que se le pasa a este m√©todo. Esto se debe a que el `VirtualTimeScheduler` necesita interceptar la
> creaci√≥n del flujo reactivo para reemplazar los `Schedulers` reales con uno `virtual`.

‚ùå No hagamos esto:

````java
void test() {
    Flux<Integer> items = getItems();           // el Flux ya se construy√≥ con el scheduler real
    StepVerifier.withVirtualTime(() -> items);  // no se intercepta correctamente
}
````

‚úÖ Haz esto:

````java
void test() {
    StepVerifier.withVirtualTime(() -> getItems()) // correcto: el Flux se construye en el contexto virtual
            .thenAwait(Duration.ofSeconds(51))
            .expectNext(1, 2, 3, 4, 5)
            .verifyComplete();
}
````

Si el `Flux` se construye fuera del `Supplier`, `el tiempo real se aplicar√°`, y el test se demorar√° lo que indique el
delay, anulando los beneficios del tiempo virtual.

Este requisito aplica solo cuando usamos `StepVerifier.withVirtualTime(...)`, ya que este m√©todo necesita control total
sobre la construcci√≥n del `Flux` o `Mono` para inyectar el `scheduler virtual`.

En cambio, cuando usamos `StepVerifier.create(...)`:

````java
void test() {
    Flux<Integer> items = getItems(); // aqu√≠ se puede construir el flujo normalmente

    StepVerifier.create(items)
            .expectNext(1, 2, 3, 4, 5)
            .verifyComplete();
}
````

No hay necesidad de preocuparse por eso, porque estamos trabajando con tiempo real y no se requiere interceptar la
creaci√≥n del flujo. As√≠ que podemos seguir construyendo tu flujo en una variable sin problema, como lo hemos hecho en
ocasiones pasadas.

### Ejemplo 01

Si prob√°ramos el flujo `getItems()` con un test normal, el test esperar√≠a realmente 50 segundos, lo cual es ineficiente
y poco pr√°ctico en entornos de prueba.

- `StepVerifier.withVirtualTime(this::getItems)`
    - Este m√©todo permite usar un `reloj virtual` que simula el paso del tiempo.
    - No espera f√≠sicamente el tiempo real (es decir, no te har√° esperar `50 segundos`), sino que avanza el tiempo
      simulado internamente.
- `.thenAwait(Duration.ofSeconds(51))`
    - Esto simula que han pasado 51 segundos en el reloj virtual.
    - Como cada elemento tiene un `delayElements(Duration.ofSeconds(10))`, este tiempo simulado permite que todos los
      elementos se emitan.
- `.expectNext(1, 2, 3, 4, 5).verifyComplete()`
    - Una vez que se simula el tiempo suficiente, se espera que se emitan los 5 elementos.
    - Finalmente, se verifica que el flujo se haya completado correctamente.

````java
class Lec06VirtualTimeTest {

    private Flux<Integer> getItems() {
        return Flux.range(1, 5)
                .delayElements(Duration.ofSeconds(10));
    }

    @Test
    void virtualTimeTest1() {
        StepVerifier.withVirtualTime(this::getItems)
                .thenAwait(Duration.ofSeconds(51))
                .expectNext(1, 2, 3, 4, 5)
                .verifyComplete();
    }
}
````

¬øPor qu√© es √∫til `withVirtualTime`?

- Evita que los tests sean lentos o se bloqueen por mucho tiempo.
- Simula flujos de datos retardados como si el tiempo hubiera pasado, lo que acelera la ejecuci√≥n de pruebas sin
  comprometer la l√≥gica de verificaci√≥n.

### Ejemplo 02

Este test usa `StepVerifier.withVirtualTime` para simular de forma precisa la emisi√≥n escalonada de eventos en un
`Flux` con retrasos.

Puntos clave del ejemplo:

- `getItems()` crea un Flux que emite n√∫meros del 1 al 5, con una espera de 10 segundos entre cada elemento.
- `expectSubscription()` asegura que el `Subscriber` se ha suscrito correctamente.
- `expectNoEvent(Duration.ofSeconds(9))` simula que no ocurre ning√∫n evento durante los primeros 9 segundos virtuales.
- `thenAwait(Duration.ofSeconds(1))` simula que pasa 1 segundo m√°s (completando los 10 segundos) y por eso se espera el
  primer valor `(1)`.
- Luego se avanza 40 segundos virtuales, lo que permite que los siguientes 4 valores `(2, 3, 4, 5)` sean emitidos.
- Finalmente, se verifica que el flujo se completa correctamente con `verifyComplete()`.

üü£ ¬øPor qu√© se debe usar `expectSubscription()` antes de `expectNoEvent(...)`?
> Usamos `expectSubscription()` para indicar que esperamos la suscripci√≥n al `Publisher`. Esto es importante cuando a
> continuaci√≥n usamos `expectNoEvent(...)`, ya que si no declaramos expl√≠citamente la suscripci√≥n, el test fallar√≠a.
> Esto se debe a que `expectNoEvent` exige que ning√∫n evento haya ocurrido en el intervalo dado, y la suscripci√≥n
> en s√≠ es un evento.
>
> En muchos casos no se necesita declarar `expectSubscription()` si los eventos de datos comienzan r√°pidamente. Sin
> embargo, cuando estamos controlando el tiempo (con `withVirtualTime`) y verificamos que no hay eventos a√∫n,
> s√≠ es necesario declararlo para mantener el orden correcto del flujo.

````java
class Lec06VirtualTimeTest {

    private Flux<Integer> getItems() {
        return Flux.range(1, 5)
                .delayElements(Duration.ofSeconds(10));
    }

    // El primer evento se emita a los 10 segundos
    @Test
    void virtualTimeTest2() {
        StepVerifier.withVirtualTime(this::getItems)
                .expectSubscription()
                .expectNoEvent(Duration.ofSeconds(9))
                .thenAwait(Duration.ofSeconds(1))
                .expectNext(1)
                .thenAwait(Duration.ofSeconds(40))
                .expectNext(2, 3, 4, 5)
                .verifyComplete();
    }
}
````

### üí° Importante

Este tipo de verificaci√≥n no ser√≠a eficiente sin `withVirtualTime`, ya que realmente esperar 50 segundos ralentizar√≠a
innecesariamente la ejecuci√≥n de los tests.

Gracias al uso de `VirtualTimeScheduler`, el test se ejecuta r√°pidamente, simulando el tiempo sin tener que esperar en
la realidad.

### üìù Suscripci√≥n en StepVerifier: comportamiento de create() vs withVirtualTime()

> En `StepVerifier.withVirtualTime(...)`, la suscripci√≥n al `Publisher` ocurre inmediatamente al construir el
> verificador. Por eso, si usas m√©todos como `expectNoEvent(...)`, es necesario declarar `expectSubscription()` primero,
> para evitar fallos debido a eventos inesperados.
>
> En cambio, en `StepVerifier.create(...)`, la suscripci√≥n ocurre reci√©n al llamar a `.verify()`, lo que permite definir
> todas las expectativas antes de que inicie el flujo.

## Scenario Name / Step Description

Este ejemplo muestra c√≥mo asignar un nombre al escenario de prueba y c√≥mo agregar descripciones espec√≠ficas a cada
expectativa dentro del test usando `StepVerifierOptions` y el m√©todo `as()`.

- `Scenario Name`: Al crear las opciones de `StepVerifier` con
  `StepVerifierOptions.create().scenarioName("Pruebas de items desde el 1 al 3")`, se asigna un nombre claro y
  descriptivo al conjunto de expectativas del test. Esto facilita identificar a qu√© caso o flujo corresponde la prueba
  cuando falla, especialmente en suites grandes.


- `Descripciones con as()`: Cada expectativa puede llevar una etiqueta descriptiva con `.as("Descripci√≥n")`. Esto hace
  que, si la prueba falla, el mensaje de error muestre la descripci√≥n espec√≠fica, indicando cu√°l fue la expectativa que
  no se cumpli√≥. Esto agiliza la comprensi√≥n del motivo del fallo.

````java
class Lec07ScenarioNameTest {

    private Flux<Integer> getItems() {
        return Flux.range(1, 3);
    }

    @Test
    void scenarioNameTest() {
        // given
        StepVerifierOptions stepVerifierOptions = StepVerifierOptions.create().scenarioName("Pruebas de items desde el 1 al 3");
        // when
        Flux<Integer> items = getItems();

        // then
        StepVerifier.create(items, stepVerifierOptions)
                .expectNext(11).as("El primer item deber√≠a ser 11")
                .expectNext(2, 3).as("Los siguientes n√∫meros deben ser 2 y 3")
                .verifyComplete();
    }
}
````

`Resultado de fallo claro y detallado`: En caso de que la expectativa no se cumpla, el mensaje de error incluye tanto
el nombre del escenario como la descripci√≥n de la expectativa fallida, mostrando el valor esperado y el valor real
recibido. Por ejemplo:

````bash
java.lang.AssertionError: [Pruebas de items desde el 1 al 3] expectation "El primer item deber√≠a ser 11" failed (expected value: 11; actual value: 1)
````

Esto permite diagnosticar r√°pidamente qu√© paso del test que no cumpli√≥ la condici√≥n esperada.

## Unit Testing Context

### Ejemplo 01: Uso de Contexto Reactivo en tests con StepVerifierOptions

Este test demuestra c√≥mo pasar datos al `Context` de Reactor en una prueba unitaria usando `StepVerifierOptions`. En
este caso, el contexto simula un usuario autenticado.

- `Mono.deferContextual(...)`: accede de forma perezosa al contexto actual. Si contiene la clave `user`, devuelve un
  saludo personalizado; de lo contrario, lanza un error.

- `StepVerifierOptions.withInitialContext(...)`: permite inicializar el contexto con datos simulados
  (por ejemplo, `"user" -> "sam"`).

- `StepVerifier.create(..., stepVerifierOptions)`: crea el `StepVerifier` usando el contexto definido, lo cual es
  esencial si tu flujo depende de dicho contexto.

````java
class Lec08ContextTest {

    private Mono<String> getWelcomeMessage() {
        return Mono.deferContextual(ctx -> {
            if (ctx.hasKey("user")) {
                return Mono.just("Bienvenido %s".formatted(ctx.get("user").toString()));
            }
            return Mono.error(new RuntimeException("No autenticado"));
        });
    }

    @Test
    void welcomeMessageTest() {
        // given
        StepVerifierOptions stepVerifierOptions = StepVerifierOptions.create()
                .withInitialContext(Context.of("user", "sam"));

        // when
        Mono<String> welcomeMessage = getWelcomeMessage();

        // then
        StepVerifier.create(welcomeMessage, stepVerifierOptions)
                .expectNext("Bienvenido sam")
                .verifyComplete();
    }
}
````

### Ejemplo 02:  Simulaci√≥n de Usuario No Autenticado en Contexto Reactivo

Este test valida el comportamiento de un `Mono` que depende de datos contextuales cuando no se encuentra la informaci√≥n
esperada en el `Context`.

- `Mono.deferContextual(...)`: intenta recuperar la clave `user` desde el contexto.
- Como el contexto est√° vac√≠o (`Context.empty()`), lanza una excepci√≥n personalizada con el mensaje `No autenticado`.
- `expectErrorMessage(...)`: permite verificar espec√≠ficamente el mensaje de error emitido.

````java
class Lec08ContextTest {

    private Mono<String> getWelcomeMessage() {
        return Mono.deferContextual(ctx -> {
            if (ctx.hasKey("user")) {
                return Mono.just("Bienvenido %s".formatted(ctx.get("user").toString()));
            }
            return Mono.error(new RuntimeException("No autenticado"));
        });
    }

    @Test
    void unauthenticatedTest() {
        // given
        StepVerifierOptions stepVerifierOptions = StepVerifierOptions.create()
                .withInitialContext(Context.empty());

        // when
        Mono<String> welcomeMessage = getWelcomeMessage();

        // then
        StepVerifier.create(welcomeMessage, stepVerifierOptions)
                .expectErrorMessage("No autenticado")
                .verify();
    }
}
````
