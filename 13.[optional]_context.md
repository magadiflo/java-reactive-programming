# Secci√≥n 13: [Opcional] - Context

---

## Introducci√≥n

### üìå ¬øQu√© es el Context?

En programaci√≥n reactiva con `Project Reactor`, el `Context` es un mecanismo dise√±ado para transportar informaci√≥n
adicional (`metadatos`) a lo largo del flujo reactivo, sin necesidad de modificar el flujo de datos principal.

Piensa en el `Context` como una especie de `mapa inmutable clave/valor` (similar a las cabeceras HTTP) que acompa√±a al
flujo reactivo, pero no forma parte del `Mono` o `Flux` que est√°s manipulando. Esta informaci√≥n se adjunta con
`contextWrite(...)` y se recupera dentro del flujo usando `deferContextual(...)`.

### üîÑ Comparaci√≥n con ThreadLocal

En la programaci√≥n imperativa tradicional, podr√≠as usar `ThreadLocal` para almacenar datos como el usuario autenticado
o un ID de seguimiento (trace ID). Sin embargo, en un entorno reactivo y no bloqueante, donde los hilos cambian
frecuentemente, `ThreadLocal` ya no es una opci√≥n viable.

El `Context` de Reactor `es una alternativa segura, inmutable y dise√±ada espec√≠ficamente para flujos as√≠ncronos`,
evitando los problemas de concurrencia y acoplamiento que genera `ThreadLocal`.

### üõ† ¬øPara qu√© sirve el Context?

El `Context` es especialmente √∫til para manejar preocupaciones transversales `(cross-cutting concerns)` como:

- üîê Autenticaci√≥n y autorizaci√≥n (pasar el usuario actual o un token)
- üìä Monitoreo y trazabilidad (trace ID, correlation ID)
- üìâ Limitaci√≥n de velocidad (rate limiting)
- üåê Localizaci√≥n o preferencias del usuario
- ‚öôÔ∏è Configuraci√≥n contextual sin modificar firmas de m√©todos

Esto permite propagar informaci√≥n importante `sin contaminar la l√≥gica del negocio`, ni modificar cada m√©todo para
aceptar nuevos par√°metros.

### üß† Ejemplo mental: Las cabeceras HTTP

Cuando haces una petici√≥n HTTP, puedes tener:

- Un cuerpo (`body`) con datos.
- Par√°metros en la URL.
- Y cabeceras (`headers`) con metadatos: autenticaci√≥n, idioma, tipo de cliente, etc.

Las cabeceras no forman parte del contenido principal, pero son esenciales. De manera similar, el `Context` acompa√±a al
flujo reactivo sin formar parte del valor emitido (`onNext`), pero sigue estando disponible si lo necesitas.

### ‚öôÔ∏è C√≥mo funciona

- `contextWrite(Context.of(...))`: Escribe informaci√≥n en el contexto reactivo (como si pusieras cabeceras).
- `Mono.deferContextual(...)` o `Flux.deferContextual(...)`: Permite leer el contexto desde dentro del flujo, justo
  cuando se necesita.

> üìå `El contexto es inmutable`: cada vez que escribes en el contexto (por ejemplo, con `contextWrite`), no se modifica
> el contexto existente, sino que se crea una nueva copia con los cambios. Es decir, no puedes cambiar el contexto
> original `‚Äúen el lugar‚Äù` (in-place) como lo har√≠as con un mapa mutable.
>
> Esta inmutabilidad garantiza que el contexto sea `seguro en entornos concurrentes y as√≠ncronos`, ya que no hay riesgo
> de que una parte del c√≥digo altere la informaci√≥n que otra parte necesita.

![01.png](assets/section-13/01.png)

### üåê Aplicaciones en flujos complejos

En flujos m√°s realistas, puedes tener m√∫ltiples productores, operadores (`map`, `filter`, `flatMap`, etc.),
combinaciones (`concat`, `merge`), y consumidores. Si necesitaras pasar datos adicionales a trav√©s de todo este
pipeline, hacerlo mediante par√°metros ser√≠a ca√≥tico.

El `Context` soluciona este problema permitiendo compartir informaci√≥n entre m√∫ltiples etapas sin acoplarlas
directamente, mejorando la `mantenibilidad y separaci√≥n de responsabilidades`.

### ‚úÖ Conclusi√≥n

El `Context` en Reactor es una herramienta poderosa para transportar metadatos de manera segura y reactiva. Aunque
opcional, puede ser clave para construir flujos m√°s limpios, desacoplados y preparados para manejar casos reales como
seguridad, logging y trazabilidad.

## Context - Demo

Imaginemos que tenemos un `publisher`, por ejemplo una `API remota`. El requisito de negocio nos dice que solo los
usuarios autenticados pueden invocarla. Entonces, en lugar de modificar la firma del m√©todo para recibir
par√°metros adicionales como un token de autenticaci√≥n, queremos una forma de pasar informaci√≥n contextual
(como si fuesen cabeceras HTTP) sin cambiar la definici√≥n del m√©todo.

Aqu√≠ es donde entra en juego el `Context` en `Project Reactor`.

````java
//El contexto sirve para proporcionar metadatos sobre el request (similar a los headers HTTP)
public class Lec01Context {
    private static final Logger log = LoggerFactory.getLogger(Lec01Context.class);

    public static void main(String[] args) {
        getWelcomeMessage()
                .contextWrite(Context.of("user", "magadiflo"))  // Agregamos el contexto aqu√≠
                .subscribe(Util.subscriber());
    }

    private static Mono<String> getWelcomeMessage() {
        return Mono.deferContextual(ctx -> {
            log.info("{}", ctx);                                // Mostramos el contenido del contexto
            if (ctx.hasKey("user")) {
                return Mono.just("Bienvenido %s".formatted(ctx.get("user").toString()));
            }
            return Mono.error(new RuntimeException("No autenticado"));
        });
    }
}
````

üîç Observaciones clave

- El m√©todo `contextWrite` agrega una entrada al contexto reactivo justo antes de la suscripci√≥n.
- `Mono.deferContextual(...)` permite acceder al contexto de forma perezosa (`lazy`), es decir, cuando se ejecute el
  flujo.
- Si no se encuentra la clave `user`, se lanza un error.
- El contexto `no se propaga autom√°ticamente` entre operadores. Hay que aplicar `contextWrite` antes de cualquier
  acceso.

````bash
10:40:03.439 INFO  [           main] d.m.app.sec13.Lec01Context     : Context1{user=magadiflo}
10:40:03.443 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Bienvenido magadiflo
10:40:03.445 INFO  [           main] d.m.a.common.DefaultSubscriber :  ¬°completado!
````

üí° Consejos adicionales

- Evita confundir el `Context` con los datos que fluyen en el `Mono` o `Flux`. Son dos canales distintos: uno para los
  datos (`onNext`) y otro para los metadatos (`Context`).
- Este enfoque es muy √∫til para implementar seguridad, trazabilidad, logging enriquecido, etc.
