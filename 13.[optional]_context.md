# Secci√≥n 13: [Opcional] - Context

---

## Introducci√≥n

### üìå ¬øQu√© es el Context?

En programaci√≥n reactiva con `Project Reactor`, el `Context` es un mecanismo dise√±ado para transportar informaci√≥n
adicional (`metadatos`) a lo largo del flujo reactivo, sin necesidad de modificar el flujo de datos principal.

Piensa en el `Context` como una especie de `mapa inmutable clave/valor` (similar a las cabeceras HTTP) que acompa√±a al
flujo reactivo, pero no forma parte del `Mono` o `Flux` que est√°s manipulando. Esta informaci√≥n se adjunta con
`contextWrite(...)` y se recupera dentro del flujo usando `deferContextual(...)`.

### üîÑ Comparaci√≥n con ThreadLocal

En la programaci√≥n imperativa tradicional, podr√≠as usar `ThreadLocal` para almacenar datos como el usuario autenticado
o un ID de seguimiento (trace ID). Sin embargo, en un entorno reactivo y no bloqueante, donde los hilos cambian
frecuentemente, `ThreadLocal` ya no es una opci√≥n viable.

El `Context` de Reactor `es una alternativa segura, inmutable y dise√±ada espec√≠ficamente para flujos as√≠ncronos`,
evitando los problemas de concurrencia y acoplamiento que genera `ThreadLocal`.

### üõ† ¬øPara qu√© sirve el Context?

El `Context` es especialmente √∫til para manejar preocupaciones transversales `(cross-cutting concerns)` como:

- üîê Autenticaci√≥n y autorizaci√≥n (pasar el usuario actual o un token)
- üìä Monitoreo y trazabilidad (trace ID, correlation ID)
- üìâ Limitaci√≥n de velocidad (rate limiting)
- üåê Localizaci√≥n o preferencias del usuario
- ‚öôÔ∏è Configuraci√≥n contextual sin modificar firmas de m√©todos

Esto permite propagar informaci√≥n importante `sin contaminar la l√≥gica del negocio`, ni modificar cada m√©todo para
aceptar nuevos par√°metros.

### üß† Ejemplo mental: Las cabeceras HTTP

Cuando haces una petici√≥n HTTP, puedes tener:

- Un cuerpo (`body`) con datos.
- Par√°metros en la URL.
- Y cabeceras (`headers`) con metadatos: autenticaci√≥n, idioma, tipo de cliente, etc.

Las cabeceras no forman parte del contenido principal, pero son esenciales. De manera similar, el `Context` acompa√±a al
flujo reactivo sin formar parte del valor emitido (`onNext`), pero sigue estando disponible si lo necesitas.

### ‚öôÔ∏è C√≥mo funciona

- `contextWrite(Context.of(...))`: Escribe informaci√≥n en el contexto reactivo (como si pusieras cabeceras).
- `Mono.deferContextual(...)` o `Flux.deferContextual(...)`: Permite leer el contexto desde dentro del flujo, justo
  cuando se necesita.

> üìå `El contexto es inmutable`: cada vez que escribes en el contexto (por ejemplo, con `contextWrite`), no se modifica
> el contexto existente, sino que se crea una nueva copia con los cambios. Es decir, no puedes cambiar el contexto
> original `‚Äúen el lugar‚Äù` (in-place) como lo har√≠as con un mapa mutable.
>
> Esta inmutabilidad garantiza que el contexto sea `seguro en entornos concurrentes y as√≠ncronos`, ya que no hay riesgo
> de que una parte del c√≥digo altere la informaci√≥n que otra parte necesita.

![01.png](assets/section-13/01.png)

### üåê Aplicaciones en flujos complejos

En flujos m√°s realistas, puedes tener m√∫ltiples productores, operadores (`map`, `filter`, `flatMap`, etc.),
combinaciones (`concat`, `merge`), y consumidores. Si necesitaras pasar datos adicionales a trav√©s de todo este
pipeline, hacerlo mediante par√°metros ser√≠a ca√≥tico.

El `Context` soluciona este problema permitiendo compartir informaci√≥n entre m√∫ltiples etapas sin acoplarlas
directamente, mejorando la `mantenibilidad y separaci√≥n de responsabilidades`.

### ‚úÖ Conclusi√≥n

El `Context` en Reactor es una herramienta poderosa para transportar metadatos de manera segura y reactiva. Aunque
opcional, puede ser clave para construir flujos m√°s limpios, desacoplados y preparados para manejar casos reales como
seguridad, logging y trazabilidad.

## Context - Demo

Imaginemos que tenemos un `publisher`, por ejemplo una `API remota`. El requisito de negocio nos dice que solo los
usuarios autenticados pueden invocarla. Entonces, en lugar de modificar la firma del m√©todo para recibir
par√°metros adicionales como un token de autenticaci√≥n, queremos una forma de pasar informaci√≥n contextual
(como si fuesen cabeceras HTTP) sin cambiar la definici√≥n del m√©todo.

Aqu√≠ es donde entra en juego el `Context` en `Project Reactor`.

````java
//El contexto sirve para proporcionar metadatos sobre el request (similar a los headers HTTP)
public class Lec01Context {
    private static final Logger log = LoggerFactory.getLogger(Lec01Context.class);

    public static void main(String[] args) {
        getWelcomeMessage()
                .contextWrite(Context.of("user", "magadiflo"))  // Agregamos el contexto aqu√≠
                .subscribe(Util.subscriber());
    }

    private static Mono<String> getWelcomeMessage() {
        return Mono.deferContextual(ctx -> {
            log.info("{}", ctx);                                // Mostramos el contenido del contexto
            if (ctx.hasKey("user")) {
                return Mono.just("Bienvenido %s".formatted(ctx.get("user").toString()));
            }
            return Mono.error(new RuntimeException("No autenticado"));
        });
    }
}
````

üîç Observaciones clave

- El m√©todo `contextWrite` agrega una entrada al contexto reactivo justo antes de la suscripci√≥n.
- `Mono.deferContextual(...)` permite acceder al contexto de forma perezosa (`lazy`), es decir, cuando se ejecute el
  flujo.
- Si no se encuentra la clave `user`, se lanza un error.
- El contexto `no se propaga autom√°ticamente` entre operadores. Hay que aplicar `contextWrite` antes de cualquier
  acceso.

````bash
10:40:03.439 INFO  [           main] d.m.app.sec13.Lec01Context     : Context1{user=magadiflo}
10:40:03.443 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Bienvenido magadiflo
10:40:03.445 INFO  [           main] d.m.a.common.DefaultSubscriber :  ¬°completado!
````

üí° Consejos adicionales

- Evita confundir el `Context` con los datos que fluyen en el `Mono` o `Flux`. Son dos canales distintos: uno para los
  datos (`onNext`) y otro para los metadatos (`Context`).
- Este enfoque es muy √∫til para implementar seguridad, trazabilidad, logging enriquecido, etc.

## Context - Append / Upate / Delete

Como ya mencionamos, el `Context` en Reactor `es un mapa inmutable`, lo cual significa que no se puede modificar
directamente. En su lugar, cada vez que hacemos una operaci√≥n como `put` (`agregar` o `actualizar`), se crea una nueva
instancia del `Context` con la informaci√≥n actualizada. Este comportamiento evita efectos secundarios y garantiza la
seguridad en entornos concurrentes.

### ¬øSe puede modificar el Context?

S√≠... pero no directamente. Las operaciones como agregar (`append`), actualizar (`update`) o eliminar (`delete`)
`no cambian el Context original`, sino que `crean una nueva copia modificada`, lo que sigue cumpliendo con el principio
de inmutabilidad.

üìå Importante:
> El `Context fluye de abajo hacia arriba en el pipeline`. Esto significa que el √∫ltimo `contextWrite` declarado es el
> primero que se aplica cuando el flujo llega al subscriber. Es decir, los `contextWrite(...)` se apilan y se aplican
> en orden inverso.

### Ejemplo 01: Append

````java
//El Context es un mapa inmutable. ¬°Podemos a√±adir informaci√≥n adicional!
public class Lec02ContextAppendUpdate {
    private static final Logger log = LoggerFactory.getLogger(Lec02ContextAppendUpdate.class);

    public static void main(String[] args) {
        append();
    }

    public static void append() {
        getWelcomeMessage()
                .contextWrite(Context.of("color", "red").put("country", "Peru").put("city", "Lima"))
                .contextWrite(Context.of("token", "12345"))
                .contextWrite(Context.of("user", "magadiflo"))
                .subscribe(Util.subscriber());
    }

    private static Mono<String> getWelcomeMessage() {
        return Mono.deferContextual(ctx -> {
            log.info("{}", ctx);
            if (ctx.hasKey("user")) {
                return Mono.just("Bienvenido %s".formatted(ctx.get("user").toString()));
            }
            return Mono.error(new RuntimeException("No autenticado"));
        });
    }
}
````

Explicaci√≥n

- Se agregan varios valores al contexto usando m√∫ltiples llamadas a `contextWrite(...)`.
- Cada llamada genera un nuevo `Context` y se coloca en la pila.
- Cuando se eval√∫a el flujo en `deferContextual`, todos los valores est√°n disponibles, ya que fueron agregados en
  distintos niveles del stack del contexto.
- El orden que se ve en el log refleja c√≥mo se aplicaron las capas del contexto desde el √∫ltimo `contextWrite` hacia el
  primero (`de abajo hacia arriba en el flujo`).

````bash
11:45:36.062 INFO  [           main] m.a.s.Lec02ContextAppendUpdate : Context5{user=magadiflo, token=12345, color=red, country=Peru, city=Lima}
11:45:36.066 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Bienvenido magadiflo
11:45:36.069 INFO  [           main] d.m.a.common.DefaultSubscriber :  ¬°completado!
````

### Ejemplo 02: "Update" (sobrescribir o eliminar el contexto)

````java
public class Lec02ContextAppendUpdate {
    private static final Logger log = LoggerFactory.getLogger(Lec02ContextAppendUpdate.class);

    public static void main(String[] args) {
        update1();
    }

    public static void update1() {
        getWelcomeMessage()
                .contextWrite(ctx -> Context.empty()) // Eliminamos todo el contexto actual
                .contextWrite(Context.of("color", "red").put("country", "Peru").put("city", "Lima"))
                .contextWrite(Context.of("token", "12345"))
                .contextWrite(Context.of("user", "magadiflo"))
                .subscribe(Util.subscriber());
    }

    private static Mono<String> getWelcomeMessage() {
        /* code */
    }
}
````

Explicaci√≥n:

- La clave est√° en la l√≠nea `.contextWrite(ctx -> Context.empty())`, esta instrucci√≥n reemplaza completamente el
  contexto anterior con uno nuevo y vac√≠o. Es como hacer un ‚Äúborr√≥n y cuenta nueva‚Äù.
- Aunque hayas agregado valores como "user", "token" o "color" en las l√≠neas siguientes, el
  `contextWrite(Context.empty())` est√° m√°s abajo en la cadena del flujo, por lo tanto, se aplica despu√©s, eliminando
  toda la informaci√≥n previa.
- El resultado es un `Context0{}` completamente vac√≠o cuando se eval√∫a el flujo en `deferContextual`.
- Como no hay clave "user" en el contexto, se lanza la excepci√≥n "No autenticado".

````bash
11:55:13.646 INFO  [           main] m.a.s.Lec02ContextAppendUpdate : Context0{}
11:55:13.652 ERROR [           main] d.m.a.common.DefaultSubscriber :  error: No autenticado
````

üìå Recordatorio
> `El contexto fluye de abajo hacia arriba`, por lo tanto, la primera llamada que se eval√∫a es la m√°s interna (la m√°s
> abajo en el c√≥digo). En este caso:
> 1. `.contextWrite(Context.of("user", ...))` ‚Üí se aplica primero.
> 2. Luego `.contextWrite(Context.of("token", ...))` agrega m√°s datos.
> 3. Luego `.contextWrite(Context.of(...))` agrega m√°s.
> 4. Pero luego: `.contextWrite(ctx -> Context.empty())` borra todo.

### Ejemplo 03: "Update" (sobrescribir una clave del contexto)

````java
public class Lec02ContextAppendUpdate {
    private static final Logger log = LoggerFactory.getLogger(Lec02ContextAppendUpdate.class);

    public static void main(String[] args) {
        update2();
    }

    public static void update2() {
        getWelcomeMessage()
                .contextWrite(Context.of("user", "nophy"))      // Sobrescribimos el valor de "user"
                .contextWrite(Context.of("color", "red").put("country", "Peru").put("city", "Lima"))
                .contextWrite(Context.of("token", "12345"))
                .contextWrite(Context.of("user", "magadiflo"))  // Este ser√° sobrescrito por el siguiente
                .subscribe(Util.subscriber());
    }

    private static Mono<String> getWelcomeMessage() {
        /* code */
    }
}
````

Explicaci√≥n

- En este flujo usamos varias llamadas a `contextWrite(...)` para agregar valores.
- En dos de ellas colocamos la clave `user`:
    1. Primero con valor `magadiflo`
    2. Luego con valor `nophy`

  üìå Como el contexto se eval√∫a de abajo hacia arriba, el valor de `user` que prevalece es el √∫ltimo que se insert√≥
  m√°s abajo en el c√≥digo, es decir: `nophy`.

- Es como si cada `contextWrite(...)` fuera creando una nueva capa sobre el mapa anterior, y al acceder a una clave, se
  toma la m√°s externa (m√°s arriba en la pila).

````bash
12:00:54.638 INFO  [           main] m.a.s.Lec02ContextAppendUpdate : Context5{user=nophy, token=12345, color=red, country=Peru, city=Lima}
12:00:54.638 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Bienvenido nophy
12:00:54.646 INFO  [           main] d.m.a.common.DefaultSubscriber :  ¬°completado!
````

### Ejemplo 04: Actualizar usando el propio contexto (ctx -> ctx.put(...))

````java
public class Lec02ContextAppendUpdate {
    private static final Logger log = LoggerFactory.getLogger(Lec02ContextAppendUpdate.class);

    public static void main(String[] args) {
        update3();
    }

    public static void update3() {
        getWelcomeMessage()
                .contextWrite(ctx -> ctx.put("user", ctx.get("user").toString().toUpperCase())) // Transformamos el valor actual de "user"
                .contextWrite(Context.of("color", "red").put("country", "Peru").put("city", "Lima"))
                .contextWrite(Context.of("token", "12345"))
                .contextWrite(Context.of("user", "magadiflo"))
                .subscribe(Util.subscriber());
    }

    private static Mono<String> getWelcomeMessage() {
        /* code */
    }
}
````

Explicaci√≥n

- En vez de sobrescribir directamente con un nuevo `Context.of(...)`, aqu√≠ usamos
  `.contextWrite(ctx -> ctx.put("user", ctx.get("user").toString().toUpperCase()))`.
- Esa l√≠nea de c√≥digo lo que hace es recuperar el valor actual asociado a `user`: `magadiflo`.
- Lo Transforma a may√∫scula: `MAGADIFLO`.
- Lo vuelve a insertar en el `Context`, pero como es inmutable, esto crea y devuelve una nueva copia del contexto con
  ese nuevo valor.

```bash
12:05:24.453 INFO  [           main] m.a.s.Lec02ContextAppendUpdate : Context5{user=MAGADIFLO, token=12345, color=red, country=Peru, city=Lima}
12:05:24.453 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Bienvenido MAGADIFLO
12:05:24.453 INFO  [           main] d.m.a.common.DefaultSubscriber :  ¬°completado!
````

> üìå `Punto clave`: cuando usamos `.contextWrite(Function<Context, Context>)`, podemos leer y modificar bas√°ndote en el
> contenido previo del contexto.

### Ejemplo 05: Eliminar claves del contexto

````java
public class Lec02ContextAppendUpdate {
    private static final Logger log = LoggerFactory.getLogger(Lec02ContextAppendUpdate.class);

    public static void main(String[] args) {
        delete();
    }

    public static void delete() {
        getWelcomeMessage()
                .contextWrite(ctx -> ctx.delete("country").delete("city").delete("color")) // Eliminamos claves espec√≠ficas
                .contextWrite(Context.of("color", "red").put("country", "Peru").put("city", "Lima"))
                .contextWrite(Context.of("token", "12345"))
                .contextWrite(Context.of("user", "magadiflo"))
                .subscribe(Util.subscriber());
    }

    private static Mono<String> getWelcomeMessage() {
        /* code */
    }
}
````

üîç `Explicaci√≥n`: El flujo del contexto va de abajo hacia arriba, es decir:

1. Se inserta "user", "token", "color", "country", "city".
2. Luego, justo antes de llegar a `getWelcomeMessage()`, el operador `.contextWrite(ctx -> ...)` elimina del `Context`
   las claves "country", "city" y "color".
3. Como `Context es inmutable`, cada `.delete(...)` retorna un nuevo objeto.

````bash
12:10:21.779 INFO  [           main] m.a.s.Lec02ContextAppendUpdate : Context2{user=magadiflo, token=12345}
12:10:21.782 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Bienvenido magadiflo
12:10:21.786 INFO  [           main] d.m.a.common.DefaultSubscriber :  ¬°completado!
````

## Context - Propagaci√≥n autom√°tica

En este apartado hablaremos de la propagaci√≥n autom√°tica del contexto.

### Ejemplo 01: Propagaci√≥n autom√°tica del contexto a m√∫ltiples productores

En escenarios del mundo real, una cadena reactiva puede estar compuesta por m√∫ltiples productores o fuentes de datos,
que podr√≠an ejecutarse incluso en distintos hilos. En este ejemplo, se demuestra c√≥mo el operador `contextWrite(...)`
en `Project Reactor` `propaga autom√°ticamente el contexto a todos los productores aguas arriba`, incluso cuando estos
utilizan diferentes `Schedulers` y, por tanto, se ejecutan en hilos distintos.

Gracias a la naturaleza inmutable y reactiva del `Context`, cada productor accede al contexto definido en el flujo, sin
necesidad de recurrir a mecanismos como `ThreadLocal`. Esto permite manejar informaci√≥n como usuarios autenticados,
tokens de sesi√≥n, configuraciones por entorno, entre otros, de manera segura, limpia y sin acoplamiento.

El siguiente ejemplo ilustra esta capacidad:

````java
public class Lec03ContextPropagation {
    private static final Logger log = LoggerFactory.getLogger(Lec03ContextPropagation.class);

    public static void main(String[] args) {
        demo1();
        Util.sleepSeconds(2);
    }

    // Todos los productores reciben el contexto
    public static void demo1() {
        getWelcomeMessage()
                .concatWith(Flux.merge(producer1(), producer2()))
                .contextWrite(Context.of("user", "magadiflo"))
                .subscribe(Util.subscriber());
    }

    private static Mono<String> getWelcomeMessage() {
        return Mono.deferContextual(ctx -> {
            log.info("{}", ctx);
            if (ctx.hasKey("user")) {
                return Mono.just("Bienvenido %s".formatted(ctx.get("user").toString()));
            }
            return Mono.error(new RuntimeException("No autenticado"));
        });
    }

    private static Mono<String> producer1() {
        return Mono.<String>deferContextual(ctx -> {
            log.info("producer1: {}", ctx);
            return Mono.empty();
        }).subscribeOn(Schedulers.boundedElastic()); // Hace uso de su propio pool de hilos
    }

    private static Mono<String> producer2() {
        return Mono.<String>deferContextual(ctx -> {
            log.info("producer2: {}", ctx);
            return Mono.empty();
        }).subscribeOn(Schedulers.parallel()); // Hace uso de su propio pool de hilos
    }
}
````

En la salida se observa c√≥mo el contexto con la clave `user` y valor `magadiflo` se propaga correctamente a todos los
productores, incluso cuando estos se ejecutan en diferentes hilos (como `parallel-1` y `boundedElastic-1`). Esto valida
que el operador `contextWrite(...)` aplica de forma autom√°tica y efectiva el contexto a todo el flujo reactivo,
incluyendo los productores que corren en pools de hilos distintos.

````bash
12:27:30.712 INFO  [           main] .m.a.s.Lec03ContextPropagation : Context1{user=magadiflo}
12:27:30.716 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Bienvenido magadiflo
12:27:30.721 INFO  [     parallel-1] .m.a.s.Lec03ContextPropagation : producer2: Context1{user=magadiflo}
12:27:30.721 INFO  [oundedElastic-1] .m.a.s.Lec03ContextPropagation : producer1: Context1{user=magadiflo}
12:27:30.725 INFO  [oundedElastic-1] d.m.a.common.DefaultSubscriber :  ¬°completado!
````

> üí° ¬°La clave!: Reactor mantiene el contexto a lo largo de la cadena reactiva, incluso con cambios de hilo gracias a
> `Scheduler`, algo que un `ThreadLocal` tradicional no lograr√≠a.

### Ejemplo 02: Exclusi√≥n del contexto en un productor espec√≠fico

En este ejemplo, se demuestra c√≥mo podemos evitar que un productor espec√≠fico reciba el contexto. Para ello, se utiliza
`contextWrite(context -> Context.empty())` aplicado exclusivamente a `producer2`. Esto simula un escenario donde
ciertos productores no deber√≠an tener acceso al contexto compartido (por ejemplo, por motivos de seguridad o separaci√≥n
de responsabilidades).

````java
public class Lec03ContextPropagation {
    private static final Logger log = LoggerFactory.getLogger(Lec03ContextPropagation.class);

    public static void main(String[] args) {
        demo2();
        Util.sleepSeconds(2);
    }

    // Supongamos que el producer2 no debe recibir el contexto
    public static void demo2() {
        getWelcomeMessage()
                .concatWith(Flux.merge(producer1(), producer2().contextWrite(context -> Context.empty())))
                .contextWrite(Context.of("user", "magadiflo"))
                .subscribe(Util.subscriber());
    }

    private static Mono<String> getWelcomeMessage() {
        return Mono.deferContextual(ctx -> {
            log.info("{}", ctx);
            if (ctx.hasKey("user")) {
                return Mono.just("Bienvenido %s".formatted(ctx.get("user").toString()));
            }
            return Mono.error(new RuntimeException("No autenticado"));
        });
    }

    private static Mono<String> producer1() {
        return Mono.<String>deferContextual(ctx -> {
            log.info("producer1: {}", ctx);
            return Mono.empty();
        }).subscribeOn(Schedulers.boundedElastic()); // Hace uso de su propio pool de hilos
    }

    private static Mono<String> producer2() {
        return Mono.<String>deferContextual(ctx -> {
            log.info("producer2: {}", ctx);
            return Mono.empty();
        }).subscribeOn(Schedulers.parallel()); // Hace uso de su propio pool de hilos
    }
}
````

La salida muestra que:

- El contexto con `user=magadiflo` se propaga correctamente a `getWelcomeMessage()` y a `producer1`.
- `producer2`, en cambio, no recibe ning√∫n dato en su contexto (`Context0{}`) debido a que fue expl√≠citamente limpiado.

````bash
12:39:36.311 INFO  [           main] .m.a.s.Lec03ContextPropagation : Context1{user=magadiflo}
12:39:36.311 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Bienvenido magadiflo
12:39:36.320 INFO  [oundedElastic-1] .m.a.s.Lec03ContextPropagation : producer1: Context1{user=magadiflo}
12:39:36.320 INFO  [     parallel-1] .m.a.s.Lec03ContextPropagation : producer2: Context0{}
12:39:36.327 INFO  [oundedElastic-1] d.m.a.common.DefaultSubscriber :  ¬°completado!
````
