# Secci√≥n 5: Operadores

---

## Operador - Handle

El operador `handle()` en `Reactor` `es un operador de combinaci√≥n (composite)` que permite aplicar l√≥gica imperativa y
condicional en el procesamiento de elementos dentro de un `Flux`.

Combina las funcionalidades de:

- `filter()` ‚Üí para decidir si un elemento debe pasar o no.
- `map()` ‚Üí para transformar los elementos.

Se comporta como un `filtro m√°s una transformaci√≥n personalizada`, utilizando una funci√≥n
`BiConsumer<T, SynchronousSink<R>>` para procesar cada elemento.

Veamos un ejemplo sencillo donde usamos el `.handle()`. El ejemplo consiste en emitir un conjunto de n√∫meros desde el
1 hasta el 10. Seg√∫n el valor del item emitido realizar alguna acci√≥n, por ejemplo:

- Si se emite el 1, enviaremos el valor -2.
- Si se emite el 4, no haremos nada.
- Si se emite el 7, lanzaremos un error.
- En cualquier otro caso, pasaremos el valor como est√°.

````java
public class Lec01Handle {
    public static void main(String[] args) {
        Flux.range(1, 10)
                .handle((item, synchronousSink) -> {
                    switch (item) {
                        case 1 -> synchronousSink.next(-2);     // transforma 1 en -2
                        case 4 -> {
                        }                                       // no emite nada (se descarta)
                        case 7 -> synchronousSink.error(new RuntimeException("Lanzando error porque el valor es 7"));
                        default -> synchronousSink.next(item);  // pasa el valor tal como est√°
                    }
                })
                .cast(Integer.class)
                .subscribe(Util.subscriber());
    }
}
````

- El c√≥digo anterior recibe una funci√≥n handler con dos argumentos:
    - El valor de entrada (`item`).
    - Un `SynchronousSink` que permite:
        - Emitir un nuevo valor con `next(R value)`.
        - Terminar el flujo con `complete()`.
        - Emitir un error con `error(Throwable e)`.

- Si no se invoca `next()`, el elemento no se emite (similar a un `filter()` que descarta el elemento).
- `cast(Integer.class)` asegura que el tipo gen√©rico sea `Integer`.

Como resultado obtenemos lo siguiente.

````bash
11:33:40.646 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: -2
11:33:40.648 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 2
11:33:40.648 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 3
11:33:40.648 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 5
11:33:40.648 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 6
11:33:40.653 ERROR [           main] d.m.a.common.DefaultSubscriber :  error: Lanzando error porque el valor es 7
````

### üß† Cu√°ndo usar `handle()`

- Cuando necesitas `filtrar y transformar` al mismo tiempo.
- Si la l√≥gica de procesamiento requiere m√°s control que el que permite `map()` y `filter()` por separado.
- Para emitir errores condicionalmente o terminar el flujo antes de tiempo (`sink.error(...)`, `sink.complete()`).

## Operador Handle - Tarea asignada

Esta tarea nos permitir√° aplicar lo aprendido sobre el operador `handle()` y explorar su uso en conjunto con
`generate()`.

````java
public class Lec02HandleUntilAssignment {
    public static void main(String[] args) {
        Flux.<String>generate(synchronousSink -> synchronousSink.next(Util.faker().country().name()))
                .handle((country, synchronousSink) -> {
                    synchronousSink.next(country);
                    if (country.equalsIgnoreCase("peru")) {
                        synchronousSink.complete();
                    }
                }).subscribe(Util.subscriber());
    }
}
````

### ‚úÖ ¬øQu√© hace este c√≥digo?

1. Se genera un `Flux<String>` con `generate()`, que puede emitir nombres de pa√≠ses indefinidamente, dependiendo de la
   cantidad de elementos solicitados por el `Subscriber` (a trav√©s de `request(n)`).
2. Luego se pasa por el operador `handle()`:
    - Cada pa√≠s generado se emite directamente con `synchronousSink.next(country)`.
    - Si el pa√≠s es `Peru` (ignorando may√∫sculas/min√∫sculas), se llama a `synchronousSink.complete()`, lo que detiene la
      emisi√≥n del `Flux`.

### üîß Explicaci√≥n t√©cnica paso a paso

1. `generate(...)`
    - Es un operador para crear flujos imperativos, uno a la vez.
    - Usa un `SynchronousSink<T>` para emitir elementos `uno por uno`.
    - En este caso, el flujo puede emitir nombres de pa√≠ses indefinidamente mientras el `Subscriber` contin√∫e
      solicitando elementos.

2. `handle(...)`
    - Aqu√≠ funciona como un controlador condicional:
        - Siempre emite el pa√≠s recibido.
        - Pero si el pa√≠s es `Peru`, finaliza el flujo.

````bash
12:01:02.342 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Seychelles
12:01:02.342 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Central African Republic
12:01:02.342 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Honduras
12:01:02.342 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Lebanon
12:01:02.342 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Peru
12:01:02.344 INFO  [           main] d.m.a.common.DefaultSubscriber :  ¬°completado!
````

‚ö†Ô∏è La cantidad de pa√≠ses antes de `Peru` es aleatoria porque faker genera datos aleatorios.

## Do Hooks/Callbacks

Los `operadores de la familia` `do...` (como `doOnNext`, `doFirst`, `doOnComplete`, etc.) se utilizan para
`agregar efectos secundarios` o ejecutar l√≥gica adicional en puntos clave del ciclo de vida de un `Publisher`
(como un `Flux` o `Mono`). A diferencia de operadores transformadores como `map()` o `filter()`, los operadores `do...`
`no modifican los datos del flujo`, sino que observan y reaccionan a eventos internos como la suscripci√≥n, la emisi√≥n
de datos, la finalizaci√≥n, errores, cancelaciones, entre otros.

Estos operadores son especialmente √∫tiles para:

- Depuraci√≥n y logging.
- Auditor√≠a de eventos en el flujo.
- Medici√≥n de tiempos o m√©tricas.
- Gesti√≥n de recursos (por ejemplo, liberaci√≥n de conexiones en `doFinally`).

> En resumen: los `do...` son "ganchos `(hooks)`" para insertar l√≥gica lateral que observa el comportamiento del flujo,
> sin intervenir en los datos que viajan por √©l.

Veamos que en el siguiente flujo observamos distintos m√©todos.

````java
public class Lec03DoCallbacks {

    private static final Logger log = LoggerFactory.getLogger(Lec03DoCallbacks.class);

    public static void main(String[] args) {
        Flux.<Integer>create(fluxSink -> {
                    log.info("Inicio del productor");
                    fluxSink.complete();
                    log.info("Fin del productor");
                })
                .doOnComplete(() -> log.info("doOnComplete-1"))
                .doFirst(() -> log.info("doFirst-1"))
                .doOnNext(item -> log.info("doOnNext-1: {}", item))
                .doOnSubscribe(subscription -> log.info("doOnSubscribe-1: {}", subscription))
                .doOnRequest(request -> log.info("doOnRequest-1: {}", request))
                .doOnError(error -> log.info("doOnError-1: {}", error.getMessage()))
                .doOnTerminate(() -> log.info("doOnTerminate-1"))
                .doOnCancel(() -> log.info("doOnCancel-1"))
                .doOnDiscard(Object.class, o -> log.info("doOnDiscard-1: {}", o))
                .doFinally(signal -> log.info("doFinally-1: {}", signal))
                // .take(2)
                .doOnComplete(() -> log.info("doOnComplete-2"))
                .doFirst(() -> log.info("doFirst-2"))
                .doOnNext(item -> log.info("doOnNext-2: {}", item))
                .doOnSubscribe(subscription -> log.info("doOnSubscribe-2: {}", subscription))
                .doOnRequest(request -> log.info("doOnRequest-2: {}", request))
                .doOnError(error -> log.info("doOnError-2: {}", error.getMessage()))
                .doOnTerminate(() -> log.info("doOnTerminate-2"))
                .doOnCancel(() -> log.info("doOnCancel-2"))
                .doOnDiscard(Object.class, o -> log.info("doOnDiscard-2: {}", o))
                .doFinally(signal -> log.info("doFinally-2: {}", signal))
                //.take(4)
                .subscribe(Util.subscriber("subscriber"));
    }
}
````

| Operador            | Descripci√≥n                                                                                                               |
|---------------------|---------------------------------------------------------------------------------------------------------------------------|
| `doFirst(Runnable)` | Se ejecuta `antes que todo`, incluso antes de `doOnSubscribe`. Se aplica de √∫ltimo hacia el primero si hay varios.        |
| `doOnSubscribe`     | Se activa cuando alguien se suscribe al `Flux`.                                                                           |
| `doOnRequest`       | Se ejecuta cuando el suscriptor solicita elementos.                                                                       |
| `doOnNext`          | Se activa cada vez que se emite un elemento (`next`).                                                                     |
| `doOnComplete`      | Se ejecuta cuando el `Flux` termina correctamente.                                                                        |
| `doOnError`         | Se ejecuta cuando el `Flux` termina por un error.                                                                         |
| `doOnTerminate`     | Se ejecuta cuando el `Flux` termina, ya sea por `onComplete` o `onError`.                                                 |
| `doOnCancel`        | Se activa si el `Subscriber` cancela la suscripci√≥n.                                                                      |
| `doOnDiscard`       | Se activa si los elementos fueron efectivamente emitidos por el `Publisher` y descartados por alg√∫n operador aguas abajo. |
| `doFinally`         | Siempre se ejecuta, ocurra lo que ocurra (`onComplete`, `onError`, `cancelaci√≥n`).                                        |

El √≥rden en la que se ejecutan los m√©todos es muy importante. Por ejemplo, ejecutamos el siguiente flujo cuyo flux no
emite ning√∫n valor, es decir, solo se completa, en ese sentido, este c√≥digo est√° bastante bien estructurado y es √∫til
para observar en qu√© orden se ejecutan los `hooks (doFirst, doOnSubscribe, doOnRequest, etc.)` y c√≥mo fluye desde el
`Subscriber` hacia el `Publisher` y viceversa.

En el resultado vemos el orden en el que los m√©todos son ejecutados.

````bash
INFO  [           main] d.m.app.sec05.Lec03DoCallbacks : doFirst-2
INFO  [           main] d.m.app.sec05.Lec03DoCallbacks : doFirst-1
INFO  [           main] d.m.app.sec05.Lec03DoCallbacks : doOnSubscribe-1: reactor.core.publisher.FluxPeekFuseable$PeekConditionalSubscriber@45b4c3a9
INFO  [           main] d.m.app.sec05.Lec03DoCallbacks : doOnSubscribe-2: reactor.core.publisher.FluxPeekFuseable$PeekConditionalSubscriber@5b94b04d
INFO  [           main] d.m.app.sec05.Lec03DoCallbacks : doOnRequest-2: 9223372036854775807
INFO  [           main] d.m.app.sec05.Lec03DoCallbacks : doOnRequest-1: 9223372036854775807
INFO  [           main] d.m.app.sec05.Lec03DoCallbacks : Inicio del productor
INFO  [           main] d.m.app.sec05.Lec03DoCallbacks : doOnComplete-1
INFO  [           main] d.m.app.sec05.Lec03DoCallbacks : doOnTerminate-1
INFO  [           main] d.m.app.sec05.Lec03DoCallbacks : doOnComplete-2
INFO  [           main] d.m.app.sec05.Lec03DoCallbacks : doOnTerminate-2
INFO  [           main] d.m.a.common.DefaultSubscriber : subscriber ¬°completado!
INFO  [           main] d.m.app.sec05.Lec03DoCallbacks : doFinally-2: onComplete
INFO  [           main] d.m.app.sec05.Lec03DoCallbacks : doFinally-1: onComplete
INFO  [           main] d.m.app.sec05.Lec03DoCallbacks : Fin del productor
````

- Primero se ejecuta `doFirst-2` y luego `doFirst-1`, ya que estos se ejecutan en orden inverso al que fueron
  declarados, desde el punto de vista del `Subscriber`. La `suscripci√≥n` inicia el flujo, y desde all√≠ se recorre
  hacia `arriba` hasta llegar al `productor`.
- Al ocurrir la `suscripci√≥n`, el flujo desciende, encontr√°ndose primero con `doOnSubscribe-1`, luego `doOnSubscribe-2`.
- Una vez que el `Subscriber` ha sido alcanzado, este solicita elementos (`request(n)`). En este caso, solicita todos
  (`Long.MAX_VALUE`). El flujo asciende nuevamente, activando primero `doOnRequest-2` y luego `doOnRequest-1`.
- Despu√©s se imprime `Inicio del productor`, indicando que el `Publisher` comenz√≥ a ejecutarse.
- Como el flujo solo se completa (sin emitir datos), se dispara la se√±al de completado. El flujo desciende nuevamente:
  se ejecuta `doOnComplete-1`, luego `doOnTerminate-1`, seguido por `doOnComplete-2` y finalmente `doOnTerminate-2`.
- Al llegar al `Subscriber`, se imprime `subscriber ¬°completado!`.
- Tras completarse el flujo, se activan los `doFinally()`, los cuales se ejecutan independientemente del motivo de
  finalizaci√≥n (`completo`, `error` o `cancelaci√≥n`). Primero se ejecuta `doFinally-2: onComplete`, seguido de
  `doFinally-1: onComplete`.
- Finalmente, despu√©s de que el `fluxSink.complete()` ha sido invocado, se imprime Fin del productor.

## Operador - doOnNext - Aclarando

El operador `doOnNext` en `Project Reactor` se utiliza para ejecutar una acci√≥n secundaria cada vez que el flujo
(`Mono` o `Flux`) emite un elemento. Este operador es parte de la familia de operadores `do...`, que permiten agregar
efectos secundarios (`side effects`) sin modificar los datos que fluyen.

- La inmutabilidad es una pr√°ctica recomendada, pero no significa que la mutaci√≥n sea intr√≠nsecamente mala.
- La `programaci√≥n funcional` prefiere las` funciones puras` (sin efectos secundarios).
    - Siempre que sea posible, deber√≠amos preferir funciones puras para mantener la previsibilidad y facilidad de
      pruebas.

Veamos el siguiente ejemplo.

````java
public class CustomerServiceImpl implements CustomerService {

    @Override
    public Mono<Customer> updateCustomer() {
        return this.repository.findById(123)
                .doOnNext(customer -> customer.setAge(10))
                .flatMap(this.repository::save);
    }

}
````

En este ejemplo, trabajamos con una entidad `Customer`, la cual `es un objeto mutable`. Al obtener el `Customer` desde
la base de datos mediante su `ID`, se nos retorna un `Mono<Customer>`. Como no sabemos en qu√© momento se emitir√° el
objeto, usamos `doOnNext` para realizar una acci√≥n `una vez que est√© disponible`, es decir, cuando se haya emitido.

La mutaci√≥n ocurre dentro del `doOnNext`, donde cambiamos la edad del cliente con `customer.setAge(10)`. Aunque esta
operaci√≥n implica un efecto secundario, `Project Reactor` garantiza que se ejecuta de forma segura en el hilo que
procesa ese flujo (ning√∫n otro hilo vendr√° y lo cambiar√°). Por tanto, no hay riesgo de condiciones de carrera a menos
que introduzcas concurrencia expl√≠cita t√∫ mismo.

## Operador - Delay Elements

Retrasa cada uno de los elementos de `Flux` (se√±ales `Subscriber.onNext`) durante una duraci√≥n determinada. Las se√±ales
se retrasan y contin√∫an en el Scheduler predeterminado en paralelo, pero las secuencias vac√≠as o las se√±ales de error
inmediatas no se retrasan.

El operador `delayElements()` en `Project Reactor` introduce un retraso entre la emisi√≥n de cada elemento en un `Flux`.
Su prop√≥sito es emitir los elementos con una demora espec√≠fica sin bloquear el hilo en el que se est√° ejecutando, lo
que lo hace ideal para escenarios reactivos.

````java
public class Lec04Delay {

    private static final Logger log = LoggerFactory.getLogger(Lec04Delay.class);

    public static void main(String[] args) {
        Flux.range(1, 4)
                .log()
                .delayElements(Duration.ofMillis(800)) // El Delay Element se aplicar√° en un hilo separado
                .subscribe(Util.subscriber());

        //Bloqueamos el hilo principal para ver los valores emitidos
        Util.sleepSeconds(4);
    }
}
````

En el ejemplo anterior, se emitir√° un n√∫mero cada 800 milisegundos. Internamente, `delayElements()` trabaja utilizando
un `Scheduler`, permitiendo que los elementos se emitan sin bloquear el hilo principal.

Ahora, solo para este ejemplo, como nos interesa ver c√≥mo se van emitiendo los valores, necesitamos bloquear el hilo
principal utilizando `Util.sleepSeconds(4)` para evitar que el programa termine antes de que se emitan todos los
elementos.

Como resultado obtenemos lo siguiente.

````bash
18:01:53.194 INFO  [           main] reactor.Flux.Range.1           : | onSubscribe([Synchronous Fuseable] FluxRange.RangeSubscription)
18:01:53.198 INFO  [           main] reactor.Flux.Range.1           : | request(1)
18:01:53.198 INFO  [           main] reactor.Flux.Range.1           : | onNext(1)
18:01:54.004 INFO  [     parallel-1] d.m.a.common.DefaultSubscriber :  recibido: 1
18:01:54.004 INFO  [     parallel-1] reactor.Flux.Range.1           : | request(1)
18:01:54.005 INFO  [     parallel-1] reactor.Flux.Range.1           : | onNext(2)
18:01:54.813 INFO  [     parallel-2] d.m.a.common.DefaultSubscriber :  recibido: 2
18:01:54.814 INFO  [     parallel-2] reactor.Flux.Range.1           : | request(1)
18:01:54.814 INFO  [     parallel-2] reactor.Flux.Range.1           : | onNext(3)
18:01:55.618 INFO  [     parallel-3] d.m.a.common.DefaultSubscriber :  recibido: 3
18:01:55.618 INFO  [     parallel-3] reactor.Flux.Range.1           : | request(1)
18:01:55.618 INFO  [     parallel-3] reactor.Flux.Range.1           : | onNext(4)
18:01:55.620 INFO  [     parallel-3] reactor.Flux.Range.1           : | onComplete()
18:01:56.425 INFO  [     parallel-4] d.m.a.common.DefaultSubscriber :  recibido: 4
18:01:56.431 INFO  [     parallel-4] d.m.a.common.DefaultSubscriber :  ¬°completado!
````

El operador `.delayElements(Duration)` no cambia el hilo del publisher original, pero interviene entre la emisi√≥n y la
propagaci√≥n de cada elemento, aplicando un retraso as√≠ncrono que se ejecuta en un Scheduler (por defecto,
Schedulers.parallel()).

### En detalle:

- El `Flux.range(1, 4)` se ejecuta en el hilo principal (por ejemplo, `main`).
- Luego `.delayElements(Duration.ofMillis(800))` inyecta un "delay" entre cada se√±al `onNext` enviada al downstream (es
  decir, al `subscriber`).
- Este delay no bloquea el hilo principal, sino que `programa la emisi√≥n futura de cada elemento` en un hilo del
  scheduler paralelo.
- Resultado: los valores se emiten en hilos como `parallel-1`, `parallel-2`, etc.

Entonces, la emisi√≥n hacia el `subscriber` ocurre en hilos paralelos, pero el flujo en s√≠ no ha cambiado completamente
de hilo, solo se ha introducido un retraso programado en paralelo.

Como se observa, `el productor no hace todo el trabajo por adelantado`. En lugar de emitir los valores de forma
inmediata, `delayElements()` utiliza un `Scheduler` para espaciar las emisiones. Cada vez que transcurre el intervalo
de tiempo especificado, el flujo reactivo solicita (`request(1`)) el siguiente valor al productor, quien responde en
ese momento. Es decir, `el productor emite el valor solo cuando se le solicita y cuando ha pasado el tiempo`, lo cual
encaja perfectamente con el modelo de `backpressure` y la naturaleza `no bloqueante` del procesamiento en `Reactor`.

## Subscribe

En este curso hemos estado usando el m√©todo est√°tico `Util.subscriber()` para mostrar la informaci√≥n que emiten los
flux. Recordemos que este m√©todo nos retorna una implementaci√≥n propia que creamos del `Subscriber`, donde implementamos
los m√©todos `onNext`, `onError`, `onComplete` y adem√°s el m√©todo `onSubscribe()` donde solicitamos el m√°ximo valor con
`subscription.request(Long.MAX_VALUE)`.

Por otro lado, hay algunos casos, en las que convendr√≠a hacer uso de los operadores `.doOnNext()`, `.doOnError()`,
`.doOnComplete()` y del `.subscribe()` sin pasarle par√°metros (por defecto se subscribe y solicita una demanda
ilimitada), tal como se ve en el siguiente ejemplo:

````java
public class Lec05Subscribe {

    private static final Logger log = LoggerFactory.getLogger(Lec05Subscribe.class);

    public static void main(String[] args) {
        Flux.range(1, 5)
                .doOnNext(value -> log.info("recibido: {}", value))
                .doOnError(throwable -> log.error(throwable.getMessage()))
                .doOnComplete(() -> log.info("¬°Se complet√≥!"))
                .subscribe(); // Se subscribe y solicita una demanda ilimitada.
    }
}
````

Si ejecutamos la aplicaci√≥n vemos que sigue funcionando como siempre pero esta imprimiendo los mensajes directamente en
los m√©todos `.doOnNext()`, `.doOnError()` y `.doOnComplete()`.

````bash
10:00:18.783 INFO  [           main] d.m.app.sec05.Lec05Subscribe   : recibido: 1
10:00:18.787 INFO  [           main] d.m.app.sec05.Lec05Subscribe   : recibido: 2
10:00:18.787 INFO  [           main] d.m.app.sec05.Lec05Subscribe   : recibido: 3
10:00:18.787 INFO  [           main] d.m.app.sec05.Lec05Subscribe   : recibido: 4
10:00:18.787 INFO  [           main] d.m.app.sec05.Lec05Subscribe   : recibido: 5
10:00:18.787 INFO  [           main] d.m.app.sec05.Lec05Subscribe   : ¬°Se complet√≥!
````
