# Secci√≥n 5: Operadores

---

## Operador - Handle

El operador `handle()` en `Reactor` `es un operador de combinaci√≥n (composite)` que permite aplicar l√≥gica imperativa y
condicional en el procesamiento de elementos dentro de un `Flux`.

Combina las funcionalidades de:

- `filter()` ‚Üí para decidir si un elemento debe pasar o no.
- `map()` ‚Üí para transformar los elementos.

Se comporta como un `filtro m√°s una transformaci√≥n personalizada`, utilizando una funci√≥n
`BiConsumer<T, SynchronousSink<R>>` para procesar cada elemento.

Veamos un ejemplo sencillo donde usamos el `.handle()`. El ejemplo consiste en emitir un conjunto de n√∫meros desde el
1 hasta el 10. Seg√∫n el valor del item emitido realizar alguna acci√≥n, por ejemplo:

- Si se emite el 1, enviaremos el valor -2.
- Si se emite el 4, no haremos nada.
- Si se emite el 7, lanzaremos un error.
- En cualquier otro caso, pasaremos el valor como est√°.

````java
public class Lec01Handle {
    public static void main(String[] args) {
        Flux.range(1, 10)
                .handle((item, synchronousSink) -> {
                    switch (item) {
                        case 1 -> synchronousSink.next(-2);     // transforma 1 en -2
                        case 4 -> {
                        }                                       // no emite nada (se descarta)
                        case 7 -> synchronousSink.error(new RuntimeException("Lanzando error porque el valor es 7"));
                        default -> synchronousSink.next(item);  // pasa el valor tal como est√°
                    }
                })
                .cast(Integer.class)
                .subscribe(Util.subscriber());
    }
}
````

- El c√≥digo anterior recibe una funci√≥n handler con dos argumentos:
    - El valor de entrada (`item`).
    - Un `SynchronousSink` que permite:
        - Emitir un nuevo valor con `next(R value)`.
        - Terminar el flujo con `complete()`.
        - Emitir un error con `error(Throwable e)`.

- Si no se invoca `next()`, el elemento no se emite (similar a un `filter()` que descarta el elemento).
- `cast(Integer.class)` asegura que el tipo gen√©rico sea `Integer`.

Como resultado obtenemos lo siguiente.

````bash
11:33:40.646 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: -2
11:33:40.648 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 2
11:33:40.648 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 3
11:33:40.648 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 5
11:33:40.648 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 6
11:33:40.653 ERROR [           main] d.m.a.common.DefaultSubscriber :  error: Lanzando error porque el valor es 7
````

### üß† Cu√°ndo usar `handle()`

- Cuando necesitas `filtrar y transformar` al mismo tiempo.
- Si la l√≥gica de procesamiento requiere m√°s control que el que permite `map()` y `filter()` por separado.
- Para emitir errores condicionalmente o terminar el flujo antes de tiempo (`sink.error(...)`, `sink.complete()`).

## Operador Handle - Tarea asignada

Esta tarea nos permitir√° aplicar lo aprendido sobre el operador `handle()` y explorar su uso en conjunto con
`generate()`.

````java
public class Lec02HandleUntilAssignment {
    public static void main(String[] args) {
        Flux.<String>generate(synchronousSink -> synchronousSink.next(Util.faker().country().name()))
                .handle((country, synchronousSink) -> {
                    synchronousSink.next(country);
                    if (country.equalsIgnoreCase("peru")) {
                        synchronousSink.complete();
                    }
                }).subscribe(Util.subscriber());
    }
}
````

### ‚úÖ ¬øQu√© hace este c√≥digo?

1. Se genera un `Flux<String>` con `generate()`, que puede emitir nombres de pa√≠ses indefinidamente, dependiendo de la
   cantidad de elementos solicitados por el `Subscriber` (a trav√©s de `request(n)`).
2. Luego se pasa por el operador `handle()`:
    - Cada pa√≠s generado se emite directamente con `synchronousSink.next(country)`.
    - Si el pa√≠s es `Peru` (ignorando may√∫sculas/min√∫sculas), se llama a `synchronousSink.complete()`, lo que detiene la
      emisi√≥n del `Flux`.

### üîß Explicaci√≥n t√©cnica paso a paso

1. `generate(...)`
    - Es un operador para crear flujos imperativos, uno a la vez.
    - Usa un `SynchronousSink<T>` para emitir elementos `uno por uno`.
    - En este caso, el flujo puede emitir nombres de pa√≠ses indefinidamente mientras el `Subscriber` contin√∫e
      solicitando elementos.

2. `handle(...)`
    - Aqu√≠ funciona como un controlador condicional:
        - Siempre emite el pa√≠s recibido.
        - Pero si el pa√≠s es `Peru`, finaliza el flujo.

````bash
12:01:02.342 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Seychelles
12:01:02.342 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Central African Republic
12:01:02.342 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Honduras
12:01:02.342 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Lebanon
12:01:02.342 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Peru
12:01:02.344 INFO  [           main] d.m.a.common.DefaultSubscriber :  ¬°completado!
````

‚ö†Ô∏è La cantidad de pa√≠ses antes de `Peru` es aleatoria porque faker genera datos aleatorios.

## Do Hooks/Callbacks

Los `operadores de la familia` `do...` (como `doOnNext`, `doFirst`, `doOnComplete`, etc.) se utilizan para
`agregar efectos secundarios` o ejecutar l√≥gica adicional en puntos clave del ciclo de vida de un `Publisher`
(como un `Flux` o `Mono`). A diferencia de operadores transformadores como `map()` o `filter()`, los operadores `do...`
`no modifican los datos del flujo`, sino que observan y reaccionan a eventos internos como la suscripci√≥n, la emisi√≥n
de datos, la finalizaci√≥n, errores, cancelaciones, entre otros.

Estos operadores son especialmente √∫tiles para:

- Depuraci√≥n y logging.
- Auditor√≠a de eventos en el flujo.
- Medici√≥n de tiempos o m√©tricas.
- Gesti√≥n de recursos (por ejemplo, liberaci√≥n de conexiones en `doFinally`).

> En resumen: los `do...` son "ganchos `(hooks)`" para insertar l√≥gica lateral que observa el comportamiento del flujo,
> sin intervenir en los datos que viajan por √©l.

Veamos que en el siguiente flujo observamos distintos m√©todos.

````java
public class Lec03DoCallbacks {

    private static final Logger log = LoggerFactory.getLogger(Lec03DoCallbacks.class);

    public static void main(String[] args) {
        Flux.<Integer>create(fluxSink -> {
                    log.info("Inicio del productor");
                    fluxSink.complete();
                    log.info("Fin del productor");
                })
                .doOnComplete(() -> log.info("doOnComplete-1"))
                .doFirst(() -> log.info("doFirst-1"))
                .doOnNext(item -> log.info("doOnNext-1: {}", item))
                .doOnSubscribe(subscription -> log.info("doOnSubscribe-1: {}", subscription))
                .doOnRequest(request -> log.info("doOnRequest-1: {}", request))
                .doOnError(error -> log.info("doOnError-1: {}", error.getMessage()))
                .doOnTerminate(() -> log.info("doOnTerminate-1"))
                .doOnCancel(() -> log.info("doOnCancel-1"))
                .doOnDiscard(Object.class, o -> log.info("doOnDiscard-1: {}", o))
                .doFinally(signal -> log.info("doFinally-1: {}", signal))
                // .take(2)
                .doOnComplete(() -> log.info("doOnComplete-2"))
                .doFirst(() -> log.info("doFirst-2"))
                .doOnNext(item -> log.info("doOnNext-2: {}", item))
                .doOnSubscribe(subscription -> log.info("doOnSubscribe-2: {}", subscription))
                .doOnRequest(request -> log.info("doOnRequest-2: {}", request))
                .doOnError(error -> log.info("doOnError-2: {}", error.getMessage()))
                .doOnTerminate(() -> log.info("doOnTerminate-2"))
                .doOnCancel(() -> log.info("doOnCancel-2"))
                .doOnDiscard(Object.class, o -> log.info("doOnDiscard-2: {}", o))
                .doFinally(signal -> log.info("doFinally-2: {}", signal))
                //.take(4)
                .subscribe(Util.subscriber("subscriber"));
    }
}
````

| Operador            | Descripci√≥n                                                                                                               |
|---------------------|---------------------------------------------------------------------------------------------------------------------------|
| `doFirst(Runnable)` | Se ejecuta `antes que todo`, incluso antes de `doOnSubscribe`. Se aplica de √∫ltimo hacia el primero si hay varios.        |
| `doOnSubscribe`     | Se activa cuando alguien se suscribe al `Flux`.                                                                           |
| `doOnRequest`       | Se ejecuta cuando el suscriptor solicita elementos.                                                                       |
| `doOnNext`          | Se activa cada vez que se emite un elemento (`next`).                                                                     |
| `doOnComplete`      | Se ejecuta cuando el `Flux` termina correctamente.                                                                        |
| `doOnError`         | Se ejecuta cuando el `Flux` termina por un error.                                                                         |
| `doOnTerminate`     | Se ejecuta cuando el `Flux` termina, ya sea por `onComplete` o `onError`.                                                 |
| `doOnCancel`        | Se activa si el `Subscriber` cancela la suscripci√≥n.                                                                      |
| `doOnDiscard`       | Se activa si los elementos fueron efectivamente emitidos por el `Publisher` y descartados por alg√∫n operador aguas abajo. |
| `doFinally`         | Siempre se ejecuta, ocurra lo que ocurra (`onComplete`, `onError`, `cancelaci√≥n`).                                        |

El √≥rden en la que se ejecutan los m√©todos es muy importante. Por ejemplo, ejecutamos el siguiente flujo cuyo flux no
emite ning√∫n valor, es decir, solo se completa, en ese sentido, este c√≥digo est√° bastante bien estructurado y es √∫til
para observar en qu√© orden se ejecutan los `hooks (doFirst, doOnSubscribe, doOnRequest, etc.)` y c√≥mo fluye desde el
`Subscriber` hacia el `Publisher` y viceversa.

En el resultado vemos el orden en el que los m√©todos son ejecutados.

````bash
INFO  [           main] d.m.app.sec05.Lec03DoCallbacks : doFirst-2
INFO  [           main] d.m.app.sec05.Lec03DoCallbacks : doFirst-1
INFO  [           main] d.m.app.sec05.Lec03DoCallbacks : doOnSubscribe-1: reactor.core.publisher.FluxPeekFuseable$PeekConditionalSubscriber@45b4c3a9
INFO  [           main] d.m.app.sec05.Lec03DoCallbacks : doOnSubscribe-2: reactor.core.publisher.FluxPeekFuseable$PeekConditionalSubscriber@5b94b04d
INFO  [           main] d.m.app.sec05.Lec03DoCallbacks : doOnRequest-2: 9223372036854775807
INFO  [           main] d.m.app.sec05.Lec03DoCallbacks : doOnRequest-1: 9223372036854775807
INFO  [           main] d.m.app.sec05.Lec03DoCallbacks : Inicio del productor
INFO  [           main] d.m.app.sec05.Lec03DoCallbacks : doOnComplete-1
INFO  [           main] d.m.app.sec05.Lec03DoCallbacks : doOnTerminate-1
INFO  [           main] d.m.app.sec05.Lec03DoCallbacks : doOnComplete-2
INFO  [           main] d.m.app.sec05.Lec03DoCallbacks : doOnTerminate-2
INFO  [           main] d.m.a.common.DefaultSubscriber : subscriber ¬°completado!
INFO  [           main] d.m.app.sec05.Lec03DoCallbacks : doFinally-2: onComplete
INFO  [           main] d.m.app.sec05.Lec03DoCallbacks : doFinally-1: onComplete
INFO  [           main] d.m.app.sec05.Lec03DoCallbacks : Fin del productor
````

- Primero se ejecuta `doFirst-2` y luego `doFirst-1`, ya que estos se ejecutan en orden inverso al que fueron
  declarados, desde el punto de vista del `Subscriber`. La `suscripci√≥n` inicia el flujo, y desde all√≠ se recorre
  hacia `arriba` hasta llegar al `productor`.
- Al ocurrir la `suscripci√≥n`, el flujo desciende, encontr√°ndose primero con `doOnSubscribe-1`, luego `doOnSubscribe-2`.
- Una vez que el `Subscriber` ha sido alcanzado, este solicita elementos (`request(n)`). En este caso, solicita todos
  (`Long.MAX_VALUE`). El flujo asciende nuevamente, activando primero `doOnRequest-2` y luego `doOnRequest-1`.
- Despu√©s se imprime `Inicio del productor`, indicando que el `Publisher` comenz√≥ a ejecutarse.
- Como el flujo solo se completa (sin emitir datos), se dispara la se√±al de completado. El flujo desciende nuevamente:
  se ejecuta `doOnComplete-1`, luego `doOnTerminate-1`, seguido por `doOnComplete-2` y finalmente `doOnTerminate-2`.
- Al llegar al `Subscriber`, se imprime `subscriber ¬°completado!`.
- Tras completarse el flujo, se activan los `doFinally()`, los cuales se ejecutan independientemente del motivo de
  finalizaci√≥n (`completo`, `error` o `cancelaci√≥n`). Primero se ejecuta `doFinally-2: onComplete`, seguido de
  `doFinally-1: onComplete`.
- Finalmente, despu√©s de que el `fluxSink.complete()` ha sido invocado, se imprime Fin del productor.

