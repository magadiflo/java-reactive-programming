# Secci√≥n 5: Operadores

---

## Operador - Handle

El operador `handle()` en `Reactor` `es un operador de combinaci√≥n (composite)` que permite aplicar l√≥gica imperativa y
condicional en el procesamiento de elementos dentro de un `Flux`.

Combina las funcionalidades de:

- `filter()` ‚Üí para decidir si un elemento debe pasar o no.
- `map()` ‚Üí para transformar los elementos.

Se comporta como un `filtro m√°s una transformaci√≥n personalizada`, utilizando una funci√≥n
`BiConsumer<T, SynchronousSink<R>>` para procesar cada elemento.

Veamos un ejemplo sencillo donde usamos el `.handle()`. El ejemplo consiste en emitir un conjunto de n√∫meros desde el
1 hasta el 10. Seg√∫n el valor del item emitido realizar alguna acci√≥n, por ejemplo:

- Si se emite el 1, enviaremos el valor -2.
- Si se emite el 4, no haremos nada.
- Si se emite el 7, lanzaremos un error.
- En cualquier otro caso, pasaremos el valor como est√°.

````java
public class Lec01Handle {
    public static void main(String[] args) {
        Flux.range(1, 10)
                .handle((item, synchronousSink) -> {
                    switch (item) {
                        case 1 -> synchronousSink.next(-2);     // transforma 1 en -2
                        case 4 -> {
                        }                                       // no emite nada (se descarta)
                        case 7 -> synchronousSink.error(new RuntimeException("Lanzando error porque el valor es 7"));
                        default -> synchronousSink.next(item);  // pasa el valor tal como est√°
                    }
                })
                .cast(Integer.class)
                .subscribe(Util.subscriber());
    }
}
````

- El c√≥digo anterior recibe una funci√≥n handler con dos argumentos:
    - El valor de entrada (`item`).
    - Un `SynchronousSink` que permite:
        - Emitir un nuevo valor con `next(R value)`.
        - Terminar el flujo con `complete()`.
        - Emitir un error con `error(Throwable e)`.

- Si no se invoca `next()`, el elemento no se emite (similar a un `filter()` que descarta el elemento).
- `cast(Integer.class)` asegura que el tipo gen√©rico sea `Integer`.

Como resultado obtenemos lo siguiente.

````bash
11:33:40.646 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: -2
11:33:40.648 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 2
11:33:40.648 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 3
11:33:40.648 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 5
11:33:40.648 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 6
11:33:40.653 ERROR [           main] d.m.a.common.DefaultSubscriber :  error: Lanzando error porque el valor es 7
````

### üß† Cu√°ndo usar `handle()`

- Cuando necesitas `filtrar y transformar` al mismo tiempo.
- Si la l√≥gica de procesamiento requiere m√°s control que el que permite `map()` y `filter()` por separado.
- Para emitir errores condicionalmente o terminar el flujo antes de tiempo (`sink.error(...)`, `sink.complete()`).

## Operador Handle - Tarea asignada

Esta tarea nos permitir√° aplicar lo aprendido sobre el operador `handle()` y explorar su uso en conjunto con
`generate()`.

````java
public class Lec02HandleUntilAssignment {
    public static void main(String[] args) {
        Flux.<String>generate(synchronousSink -> synchronousSink.next(Util.faker().country().name()))
                .handle((country, synchronousSink) -> {
                    synchronousSink.next(country);
                    if (country.equalsIgnoreCase("peru")) {
                        synchronousSink.complete();
                    }
                }).subscribe(Util.subscriber());
    }
}
````

### ‚úÖ ¬øQu√© hace este c√≥digo?

1. Se genera un `Flux<String>` con `generate()`, que puede emitir nombres de pa√≠ses indefinidamente, dependiendo de la
   cantidad de elementos solicitados por el `Subscriber` (a trav√©s de `request(n)`).
2. Luego se pasa por el operador `handle()`:
    - Cada pa√≠s generado se emite directamente con `synchronousSink.next(country)`.
    - Si el pa√≠s es `Peru` (ignorando may√∫sculas/min√∫sculas), se llama a `synchronousSink.complete()`, lo que detiene la
      emisi√≥n del `Flux`.

### üîß Explicaci√≥n t√©cnica paso a paso

1. `generate(...)`
    - Es un operador para crear flujos imperativos, uno a la vez.
    - Usa un `SynchronousSink<T>` para emitir elementos `uno por uno`.
    - En este caso, el flujo puede emitir nombres de pa√≠ses indefinidamente mientras el `Subscriber` contin√∫e
      solicitando elementos.

2. `handle(...)`
    - Aqu√≠ funciona como un controlador condicional:
        - Siempre emite el pa√≠s recibido.
        - Pero si el pa√≠s es `Peru`, finaliza el flujo.

````bash
12:01:02.342 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Seychelles
12:01:02.342 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Central African Republic
12:01:02.342 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Honduras
12:01:02.342 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Lebanon
12:01:02.342 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Peru
12:01:02.344 INFO  [           main] d.m.a.common.DefaultSubscriber :  ¬°completado!
````

‚ö†Ô∏è La cantidad de pa√≠ses antes de `Peru` es aleatoria porque faker genera datos aleatorios.

## Do Hooks/Callbacks

Los `operadores de la familia` `do...` (como `doOnNext`, `doFirst`, `doOnComplete`, etc.) se utilizan para
`agregar efectos secundarios` o ejecutar l√≥gica adicional en puntos clave del ciclo de vida de un `Publisher`
(como un `Flux` o `Mono`). A diferencia de operadores transformadores como `map()` o `filter()`, los operadores `do...`
`no modifican los datos del flujo`, sino que observan y reaccionan a eventos internos como la suscripci√≥n, la emisi√≥n
de datos, la finalizaci√≥n, errores, cancelaciones, entre otros.

Estos operadores son especialmente √∫tiles para:

- Depuraci√≥n y logging.
- Auditor√≠a de eventos en el flujo.
- Medici√≥n de tiempos o m√©tricas.
- Gesti√≥n de recursos (por ejemplo, liberaci√≥n de conexiones en `doFinally`).

> En resumen: los `do...` son "ganchos `(hooks)`" para insertar l√≥gica lateral que observa el comportamiento del flujo,
> sin intervenir en los datos que viajan por √©l.

Veamos que en el siguiente flujo observamos distintos m√©todos.

````java
public class Lec03DoCallbacks {

    private static final Logger log = LoggerFactory.getLogger(Lec03DoCallbacks.class);

    public static void main(String[] args) {
        Flux.<Integer>create(fluxSink -> {
                    log.info("Inicio del productor");
                    fluxSink.complete();
                    log.info("Fin del productor");
                })
                .doOnComplete(() -> log.info("doOnComplete-1"))
                .doFirst(() -> log.info("doFirst-1"))
                .doOnNext(item -> log.info("doOnNext-1: {}", item))
                .doOnSubscribe(subscription -> log.info("doOnSubscribe-1: {}", subscription))
                .doOnRequest(request -> log.info("doOnRequest-1: {}", request))
                .doOnError(error -> log.info("doOnError-1: {}", error.getMessage()))
                .doOnTerminate(() -> log.info("doOnTerminate-1"))
                .doOnCancel(() -> log.info("doOnCancel-1"))
                .doOnDiscard(Object.class, o -> log.info("doOnDiscard-1: {}", o))
                .doFinally(signal -> log.info("doFinally-1: {}", signal))
                // .take(2)
                .doOnComplete(() -> log.info("doOnComplete-2"))
                .doFirst(() -> log.info("doFirst-2"))
                .doOnNext(item -> log.info("doOnNext-2: {}", item))
                .doOnSubscribe(subscription -> log.info("doOnSubscribe-2: {}", subscription))
                .doOnRequest(request -> log.info("doOnRequest-2: {}", request))
                .doOnError(error -> log.info("doOnError-2: {}", error.getMessage()))
                .doOnTerminate(() -> log.info("doOnTerminate-2"))
                .doOnCancel(() -> log.info("doOnCancel-2"))
                .doOnDiscard(Object.class, o -> log.info("doOnDiscard-2: {}", o))
                .doFinally(signal -> log.info("doFinally-2: {}", signal))
                //.take(4)
                .subscribe(Util.subscriber("subscriber"));
    }
}
````

| Operador            | Descripci√≥n                                                                                                               |
|---------------------|---------------------------------------------------------------------------------------------------------------------------|
| `doFirst(Runnable)` | Se ejecuta `antes que todo`, incluso antes de `doOnSubscribe`. Se aplica de √∫ltimo hacia el primero si hay varios.        |
| `doOnSubscribe`     | Se activa cuando alguien se suscribe al `Flux`.                                                                           |
| `doOnRequest`       | Se ejecuta cuando el suscriptor solicita elementos.                                                                       |
| `doOnNext`          | Se activa cada vez que se emite un elemento (`next`).                                                                     |
| `doOnComplete`      | Se ejecuta cuando el `Flux` termina correctamente.                                                                        |
| `doOnError`         | Se ejecuta cuando el `Flux` termina por un error.                                                                         |
| `doOnTerminate`     | Se ejecuta cuando el `Flux` termina, ya sea por `onComplete` o `onError`.                                                 |
| `doOnCancel`        | Se activa si el `Subscriber` cancela la suscripci√≥n.                                                                      |
| `doOnDiscard`       | Se activa si los elementos fueron efectivamente emitidos por el `Publisher` y descartados por alg√∫n operador aguas abajo. |
| `doFinally`         | Siempre se ejecuta, ocurra lo que ocurra (`onComplete`, `onError`, `cancelaci√≥n`).                                        |

El √≥rden en la que se ejecutan los m√©todos es muy importante. Por ejemplo, ejecutamos el siguiente flujo cuyo flux no
emite ning√∫n valor, es decir, solo se completa, en ese sentido, este c√≥digo est√° bastante bien estructurado y es √∫til
para observar en qu√© orden se ejecutan los `hooks (doFirst, doOnSubscribe, doOnRequest, etc.)` y c√≥mo fluye desde el
`Subscriber` hacia el `Publisher` y viceversa.

En el resultado vemos el orden en el que los m√©todos son ejecutados.

````bash
INFO  [           main] d.m.app.sec05.Lec03DoCallbacks : doFirst-2
INFO  [           main] d.m.app.sec05.Lec03DoCallbacks : doFirst-1
INFO  [           main] d.m.app.sec05.Lec03DoCallbacks : doOnSubscribe-1: reactor.core.publisher.FluxPeekFuseable$PeekConditionalSubscriber@45b4c3a9
INFO  [           main] d.m.app.sec05.Lec03DoCallbacks : doOnSubscribe-2: reactor.core.publisher.FluxPeekFuseable$PeekConditionalSubscriber@5b94b04d
INFO  [           main] d.m.app.sec05.Lec03DoCallbacks : doOnRequest-2: 9223372036854775807
INFO  [           main] d.m.app.sec05.Lec03DoCallbacks : doOnRequest-1: 9223372036854775807
INFO  [           main] d.m.app.sec05.Lec03DoCallbacks : Inicio del productor
INFO  [           main] d.m.app.sec05.Lec03DoCallbacks : doOnComplete-1
INFO  [           main] d.m.app.sec05.Lec03DoCallbacks : doOnTerminate-1
INFO  [           main] d.m.app.sec05.Lec03DoCallbacks : doOnComplete-2
INFO  [           main] d.m.app.sec05.Lec03DoCallbacks : doOnTerminate-2
INFO  [           main] d.m.a.common.DefaultSubscriber : subscriber ¬°completado!
INFO  [           main] d.m.app.sec05.Lec03DoCallbacks : doFinally-2: onComplete
INFO  [           main] d.m.app.sec05.Lec03DoCallbacks : doFinally-1: onComplete
INFO  [           main] d.m.app.sec05.Lec03DoCallbacks : Fin del productor
````

- Primero se ejecuta `doFirst-2` y luego `doFirst-1`, ya que estos se ejecutan en orden inverso al que fueron
  declarados, desde el punto de vista del `Subscriber`. La `suscripci√≥n` inicia el flujo, y desde all√≠ se recorre
  hacia `arriba` hasta llegar al `productor`.
- Al ocurrir la `suscripci√≥n`, el flujo desciende, encontr√°ndose primero con `doOnSubscribe-1`, luego `doOnSubscribe-2`.
- Una vez que el `Subscriber` ha sido alcanzado, este solicita elementos (`request(n)`). En este caso, solicita todos
  (`Long.MAX_VALUE`). El flujo asciende nuevamente, activando primero `doOnRequest-2` y luego `doOnRequest-1`.
- Despu√©s se imprime `Inicio del productor`, indicando que el `Publisher` comenz√≥ a ejecutarse.
- Como el flujo solo se completa (sin emitir datos), se dispara la se√±al de completado. El flujo desciende nuevamente:
  se ejecuta `doOnComplete-1`, luego `doOnTerminate-1`, seguido por `doOnComplete-2` y finalmente `doOnTerminate-2`.
- Al llegar al `Subscriber`, se imprime `subscriber ¬°completado!`.
- Tras completarse el flujo, se activan los `doFinally()`, los cuales se ejecutan independientemente del motivo de
  finalizaci√≥n (`completo`, `error` o `cancelaci√≥n`). Primero se ejecuta `doFinally-2: onComplete`, seguido de
  `doFinally-1: onComplete`.
- Finalmente, despu√©s de que el `fluxSink.complete()` ha sido invocado, se imprime Fin del productor.

## Operador - doOnNext - Aclarando

El operador `doOnNext` en `Project Reactor` se utiliza para ejecutar una acci√≥n secundaria cada vez que el flujo
(`Mono` o `Flux`) emite un elemento. Este operador es parte de la familia de operadores `do...`, que permiten agregar
efectos secundarios (`side effects`) sin modificar los datos que fluyen.

- La inmutabilidad es una pr√°ctica recomendada, pero no significa que la mutaci√≥n sea intr√≠nsecamente mala.
- La `programaci√≥n funcional` prefiere las` funciones puras` (sin efectos secundarios).
    - Siempre que sea posible, deber√≠amos preferir funciones puras para mantener la previsibilidad y facilidad de
      pruebas.

Veamos el siguiente ejemplo.

````java
public class CustomerServiceImpl implements CustomerService {

    @Override
    public Mono<Customer> updateCustomer() {
        return this.repository.findById(123)
                .doOnNext(customer -> customer.setAge(10))
                .flatMap(this.repository::save);
    }

}
````

En este ejemplo, trabajamos con una entidad `Customer`, la cual `es un objeto mutable`. Al obtener el `Customer` desde
la base de datos mediante su `ID`, se nos retorna un `Mono<Customer>`. Como no sabemos en qu√© momento se emitir√° el
objeto, usamos `doOnNext` para realizar una acci√≥n `una vez que est√© disponible`, es decir, cuando se haya emitido.

La mutaci√≥n ocurre dentro del `doOnNext`, donde cambiamos la edad del cliente con `customer.setAge(10)`. Aunque esta
operaci√≥n implica un efecto secundario, `Project Reactor` garantiza que se ejecuta de forma segura en el hilo que
procesa ese flujo (ning√∫n otro hilo vendr√° y lo cambiar√°). Por tanto, no hay riesgo de condiciones de carrera a menos
que introduzcas concurrencia expl√≠cita t√∫ mismo.

## Operador - Delay Elements

Retrasa cada uno de los elementos de `Flux` (se√±ales `Subscriber.onNext`) durante una duraci√≥n determinada. Las se√±ales
se retrasan y contin√∫an en el Scheduler predeterminado en paralelo, pero las secuencias vac√≠as o las se√±ales de error
inmediatas no se retrasan.

El operador `delayElements()` en `Project Reactor` introduce un retraso entre la emisi√≥n de cada elemento en un `Flux`.
Su prop√≥sito es emitir los elementos con una demora espec√≠fica sin bloquear el hilo en el que se est√° ejecutando, lo
que lo hace ideal para escenarios reactivos.

````java
public class Lec04Delay {

    private static final Logger log = LoggerFactory.getLogger(Lec04Delay.class);

    public static void main(String[] args) {
        Flux.range(1, 4)
                .log()
                .delayElements(Duration.ofMillis(800)) // El Delay Element se aplicar√° en un hilo separado
                .subscribe(Util.subscriber());

        //Bloqueamos el hilo principal para ver los valores emitidos
        Util.sleepSeconds(4);
    }
}
````

En el ejemplo anterior, se emitir√° un n√∫mero cada 800 milisegundos. Internamente, `delayElements()` trabaja utilizando
un `Scheduler`, permitiendo que los elementos se emitan sin bloquear el hilo principal.

Ahora, solo para este ejemplo, como nos interesa ver c√≥mo se van emitiendo los valores, necesitamos bloquear el hilo
principal utilizando `Util.sleepSeconds(4)` para evitar que el programa termine antes de que se emitan todos los
elementos.

Como resultado obtenemos lo siguiente.

````bash
18:01:53.194 INFO  [           main] reactor.Flux.Range.1           : | onSubscribe([Synchronous Fuseable] FluxRange.RangeSubscription)
18:01:53.198 INFO  [           main] reactor.Flux.Range.1           : | request(1)
18:01:53.198 INFO  [           main] reactor.Flux.Range.1           : | onNext(1)
18:01:54.004 INFO  [     parallel-1] d.m.a.common.DefaultSubscriber :  recibido: 1
18:01:54.004 INFO  [     parallel-1] reactor.Flux.Range.1           : | request(1)
18:01:54.005 INFO  [     parallel-1] reactor.Flux.Range.1           : | onNext(2)
18:01:54.813 INFO  [     parallel-2] d.m.a.common.DefaultSubscriber :  recibido: 2
18:01:54.814 INFO  [     parallel-2] reactor.Flux.Range.1           : | request(1)
18:01:54.814 INFO  [     parallel-2] reactor.Flux.Range.1           : | onNext(3)
18:01:55.618 INFO  [     parallel-3] d.m.a.common.DefaultSubscriber :  recibido: 3
18:01:55.618 INFO  [     parallel-3] reactor.Flux.Range.1           : | request(1)
18:01:55.618 INFO  [     parallel-3] reactor.Flux.Range.1           : | onNext(4)
18:01:55.620 INFO  [     parallel-3] reactor.Flux.Range.1           : | onComplete()
18:01:56.425 INFO  [     parallel-4] d.m.a.common.DefaultSubscriber :  recibido: 4
18:01:56.431 INFO  [     parallel-4] d.m.a.common.DefaultSubscriber :  ¬°completado!
````

El operador `.delayElements(Duration)` no cambia el hilo del publisher original, pero interviene entre la emisi√≥n y la
propagaci√≥n de cada elemento, aplicando un retraso as√≠ncrono que se ejecuta en un Scheduler (por defecto,
Schedulers.parallel()).

### En detalle:

- El `Flux.range(1, 4)` se ejecuta en el hilo principal (por ejemplo, `main`).
- Luego `.delayElements(Duration.ofMillis(800))` inyecta un "delay" entre cada se√±al `onNext` enviada al downstream (es
  decir, al `subscriber`).
- Este delay no bloquea el hilo principal, sino que `programa la emisi√≥n futura de cada elemento` en un hilo del
  scheduler paralelo.
- Resultado: los valores se emiten en hilos como `parallel-1`, `parallel-2`, etc.

Entonces, la emisi√≥n hacia el `subscriber` ocurre en hilos paralelos, pero el flujo en s√≠ no ha cambiado completamente
de hilo, solo se ha introducido un retraso programado en paralelo.

Como se observa, `el productor no hace todo el trabajo por adelantado`. En lugar de emitir los valores de forma
inmediata, `delayElements()` utiliza un `Scheduler` para espaciar las emisiones. Cada vez que transcurre el intervalo
de tiempo especificado, el flujo reactivo solicita (`request(1`)) el siguiente valor al productor, quien responde en
ese momento. Es decir, `el productor emite el valor solo cuando se le solicita y cuando ha pasado el tiempo`, lo cual
encaja perfectamente con el modelo de `backpressure` y la naturaleza `no bloqueante` del procesamiento en `Reactor`.

## Subscribe

En este curso hemos estado usando el m√©todo est√°tico `Util.subscriber()` para mostrar la informaci√≥n que emiten los
flux. Recordemos que este m√©todo nos retorna una implementaci√≥n propia que creamos del `Subscriber`, donde implementamos
los m√©todos `onNext`, `onError`, `onComplete` y adem√°s el m√©todo `onSubscribe()` donde solicitamos el m√°ximo valor con
`subscription.request(Long.MAX_VALUE)`.

Por otro lado, hay algunos casos, en las que convendr√≠a hacer uso de los operadores `.doOnNext()`, `.doOnError()`,
`.doOnComplete()` y del `.subscribe()` sin pasarle par√°metros (por defecto se subscribe y solicita una demanda
ilimitada), tal como se ve en el siguiente ejemplo:

````java
public class Lec05Subscribe {

    private static final Logger log = LoggerFactory.getLogger(Lec05Subscribe.class);

    public static void main(String[] args) {
        Flux.range(1, 5)
                .doOnNext(value -> log.info("recibido: {}", value))
                .doOnError(throwable -> log.error(throwable.getMessage()))
                .doOnComplete(() -> log.info("¬°Se complet√≥!"))
                .subscribe(); // Se subscribe y solicita una demanda ilimitada.
    }
}
````

Si ejecutamos la aplicaci√≥n vemos que sigue funcionando como siempre pero esta imprimiendo los mensajes directamente en
los m√©todos `.doOnNext()`, `.doOnError()` y `.doOnComplete()`.

````bash
10:00:18.783 INFO  [           main] d.m.app.sec05.Lec05Subscribe   : recibido: 1
10:00:18.787 INFO  [           main] d.m.app.sec05.Lec05Subscribe   : recibido: 2
10:00:18.787 INFO  [           main] d.m.app.sec05.Lec05Subscribe   : recibido: 3
10:00:18.787 INFO  [           main] d.m.app.sec05.Lec05Subscribe   : recibido: 4
10:00:18.787 INFO  [           main] d.m.app.sec05.Lec05Subscribe   : recibido: 5
10:00:18.787 INFO  [           main] d.m.app.sec05.Lec05Subscribe   : ¬°Se complet√≥!
````

## Error Handling - onErrorReturn

En el siguiente ejemplo se emite un conjunto de n√∫meros. Cuando el valor emitido sea 5 lo dividimos entre cero, eso nos
dar√° un error, as√≠ que veamos el comportamiento.

````java
    public static void main(String[] args) {
    Flux.range(1, 10)
            .map(value -> value == 5 ? 5 / 0 : value) //Intencional
            .subscribe(Util.subscriber());
}
````

El resultado del error lo imprime el m√©todo `onError(...)` dentro del `Util.subscriber()`.

````bash
10:35:30.122 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 1
10:35:30.125 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 2
10:35:30.125 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 3
10:35:30.125 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 4
10:35:30.129 ERROR [           main] d.m.a.common.DefaultSubscriber :  error: / by zero
````

Una forma de manejar los errores que se produzcan en el flujo es emitiendo un valor de respaldo, esto gracias al
m√©todo `onErrorReturn`.

````java
public static void main(String[] args) {
    Flux.range(1, 10)
            .map(value -> value == 5 ? 5 / 0 : value) //Intencional
            .onErrorReturn(-1) //El valor a emitir si ocurre un error
            .subscribe(Util.subscriber());
}
````

El operador `onErrorReturn()` emite un valor de respaldo capturado cuando se observe alg√∫n error en el flux.
El operador `onErrorReturn()` de `Project Reactor` finaliza el flujo despu√©s de devolver el valor especificado cuando
ocurre un error. Es decir, una vez que se captura una excepci√≥n y se emite el valor de retorno, `el flujo se completa`,
aunque queden m√°s elementos por emitir.

````bash
10:39:32.882 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 1
10:39:32.885 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 2
10:39:32.885 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 3
10:39:32.885 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 4
10:39:32.890 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: -1
10:39:32.890 INFO  [           main] d.m.a.common.DefaultSubscriber :  ¬°completado!
````

**Importante**
> Es importante la ubicaci√≥n del operador `.onErrorReturn()`, por lo general podr√≠amos colocarlo casi al final para
> que est√© pendiente de todo el flujo.

Ahora, supongamos que queremos retornar un valor en caso de una excepci√≥n, pero siempre y cuando sea en funci√≥n de una
excepci√≥n espec√≠fica. Por ejemplo, si ocurre la excepci√≥n `IllegalArgumentException`, solo en ese caso se emitir√° como
valor de retorno el `-1`.

````java
private static void onErrorReturn() {
    Flux.range(1, 10)
            .map(value -> value == 5 ? 5 / 0 : value) //Intencional
            .onErrorReturn(IllegalArgumentException.class, -1)
            .subscribe(Util.subscriber());
}
````

En el ejemplo anterior, recibimos un error y finalizamos el flux. En el operador `onErrorReturn()`
esper√°bamos un error del tipo `IllegalArgumentException` para retornar un `-1` pero el error que obtuvimos fue
del tipo `ArithmeticException`, es por eso que se continu√≥ propagando el error hasta el `subscribe`.

````bash
10:45:07.163 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 1
10:45:07.166 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 2
10:45:07.166 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 3
10:45:07.166 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 4
10:45:07.171 ERROR [           main] d.m.a.common.DefaultSubscriber :  error: / by zero
````

Podemos agregar tantos operadores `onErrorReturn` como quisi√©ramos especificando la excepci√≥n que se debe producir
para retornar un valor de respaldo.

````java
private static void onErrorReturn() {
    Flux.range(1, 10)
            .map(value -> value == 5 ? 5 / 0 : value) //Intencional
            .onErrorReturn(IllegalArgumentException.class, -1)
            .onErrorReturn(ArithmeticException.class, -2)
            .onErrorReturn(-3)
            .subscribe(Util.subscriber());
}
````

En el ejemplo anterior estamos esperando que se produzca la excepci√≥n `IllegalArgumentException` para retornar el valor
`-1`, o la excepci√≥n `ArithmeticException` para retornar el valor `-2`, o en cualquier otro caso retornar el `-3`.

````bash
10:47:29.236 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 1
10:47:29.239 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 2
10:47:29.239 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 3
10:47:29.239 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 4
10:47:29.244 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: -2
10:47:29.244 INFO  [           main] d.m.a.common.DefaultSubscriber :  ¬°completado!
````

## Error Handling - onErrorResume

En la secci√≥n anterior, al usar el operador `onErrorReturn()`, vimos que podemos devolver un valor fijo (hardcoded)
cuando ocurre un error. Pero **¬øqu√© sucede si queremos calcular ese valor o continuar con otro flujo dependiendo del
tipo de error?**

Para este escenario, `Project Reactor` proporciona el operador `onErrorResume()`, que ofrece una forma m√°s flexible y
din√°mica de manejar errores.

Este operador:

- Se activa cuando ocurre un error en el flujo original.
- Permite `interceptar la excepci√≥n` y retornar un nuevo `Publisher` (`Flux` o `Mono`).
- A diferencia de `onErrorReturn()`, no se limita a emitir un valor est√°tico, sino que puede emitir m√∫ltiples elementos
  desde la nueva fuente.
- Es √∫til cuando quieres `recuperarte del error` y continuar con el procesamiento, en lugar de finalizar el flujo.

````java
public class Lec06ErrorHandling {
    private static final Logger log = LoggerFactory.getLogger(Lec06ErrorHandling.class);

    public static void main(String[] args) {
        onErrorResume();
    }

    private static void onErrorResume() {
        Flux.range(1, 10)
                .map(value -> value == 5 ? 5 / 0 : value) //Intencional
                .onErrorResume(throwable -> fallback(throwable))
                .subscribe(Util.subscriber());
    }

    private static Mono<Integer> fallback(Throwable throwable) {
        log.error("Ocurri√≥ un error: {}", throwable.getMessage());
        log.info("Generando valor aleatorio...");
        return Mono.fromSupplier(() -> Util.faker().random().nextInt(10, 100));
    }
}
````

En el ejemplo anterior, creamos un `Flux` que emite los n√∫meros del `1 al 10`. `Intencionalmente`, provocamos una
excepci√≥n (`ArithmeticException`) cuando el valor es igual a 5. Cuando ocurre la excepci√≥n, el operador
`onErrorResume()` intercepta el error y llama al m√©todo `fallback(Throwable)`, pas√°ndole la excepci√≥n generada como
argumento.

Dentro del m√©todo `fallback()`:

- Se imprime un mensaje de error con el detalle de la excepci√≥n (`/ by zero`).
- Luego se imprime un mensaje adicional indicando que se est√° generando un valor aleatorio.
- Finalmente, se retorna un nuevo `Mono<Integer>` que emite un n√∫mero aleatorio entre `10 y 100` como valor de
  recuperaci√≥n.

Es importante destacar que:

- Aunque el flujo original es de tipo `Flux`, el operador `onErrorResume()` puede retornar un `Mono`, ya que un `Mono`
  tambi√©n es un `Publisher`.
- En este contexto, retornar un `Mono` que emite un solo valor es v√°lido porque el flujo se interrumpi√≥ al llegar al
  error, y lo que se busca es continuar desde ese punto con un nuevo valor.
- Este comportamiento da la sensaci√≥n de que el flujo original simplemente contin√∫a, como si el error no hubiese
  ocurrido, aunque internamente se haya manejado y redirigido a una nueva fuente.

````bash
11:15:46.406 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 1
11:15:46.409 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 2
11:15:46.409 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 3
11:15:46.409 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 4
11:15:46.413 ERROR [           main] d.m.a.sec05.Lec06ErrorHandling : Ocurri√≥ un error: / by zero
11:15:46.413 INFO  [           main] d.m.a.sec05.Lec06ErrorHandling : Generando valor aleatorio...
11:15:46.432 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 58
11:15:46.433 INFO  [           main] d.m.a.common.DefaultSubscriber :  ¬°completado!
````

Como se puede ver:

- Los valores del 1 al 4 se emiten normalmente.
- Al llegar al 5, se lanza una excepci√≥n y se ejecuta el `fallback()`.
- El nuevo valor (58 en este caso) es emitido desde el `Mono` de respaldo.
- Luego el flujo se completa correctamente.

En el ejemplo anterior, el flujo se completa luego de emitir el valor de respaldo (58), pero esto no ocurre porque
`onErrorResume()` tenga un comportamiento que fuerce el completado (como s√≠ ocurre con `onErrorReturn()`).

La raz√≥n por la que el flujo se completa es que el `Publisher` retornado por `fallback()` es un `Mono`, y por
definici√≥n, un `Mono` emite solo un elemento o un `error`, y luego `completa`.

Si en lugar de un `Mono` hubi√©ramos retornado un `Flux` con m√∫ltiples valores, entonces el flujo habr√≠a continuado
emitiendo todos los elementos de ese `Flux` hasta que este completara por s√≠ mismo.

Esto demuestra la flexibilidad de `onErrorResume()`, ya que permite decidir la estrategia de recuperaci√≥n y c√≥mo
contin√∫a el flujo, delegando ese control al `Publisher` de respaldo que se retorne.

Precisamente, para ejemplificar lo mencionado l√≠neas arriba, es que vamos a crear el siguiente ejemplo.

````java

public class Lec06ErrorHandling {
    private static final Logger log = LoggerFactory.getLogger(Lec06ErrorHandling.class);

    public static void main(String[] args) {
        onErrorResume();
    }

    private static void onErrorResume() {
        Flux.range(1, 10)
                .map(value -> value == 5 ? 5 / 0 : value) //Intencional
                .onErrorResume(throwable -> fallback(throwable.getMessage()))
                .subscribe(Util.subscriber());
    }

    private static Flux<Integer> fallback(String message) {
        log.error("Mensaje del error: {}", message);
        log.info("Generando valor aleatorio..");
        return Flux.range(50, 5);
    }

}
````

En este ejemplo, cuando el valor 5 causa una excepci√≥n (`/ by zero`), el operador `onErrorResume()` intercepta el error
y redirige el flujo hacia una nueva fuente de datos, que en este caso es un `Flux.range(50, 5)` (es decir, los n√∫meros
del 50 al 54).

Esto confirma claramente lo que discutimos:

`onErrorResume()` no simplemente emite un √∫nico valor y termina el flujo (como lo hace `onErrorReturn()`), sino que
permite continuar la secuencia con otro `Publisher` completo.

> En este caso, como se retorna un `Flux` con m√∫ltiples elementos, el flujo contin√∫a normalmente desde esa nueva fuente
> hasta que se completa, como si nunca hubiera ocurrido el error en la fuente original.

Este comportamiento hace que `onErrorResume()` sea ideal para casos donde no solo se quiere emitir un valor de respaldo,
sino tambi√©n realizar una l√≥gica m√°s compleja, como:

- Decidir din√°micamente qu√© datos emitir.
- Loguear errores de forma centralizada.
- Consultar otro servicio o fuente de datos alternativa.

````bash
11:43:36.005 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 1
11:43:36.008 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 2
11:43:36.009 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 3
11:43:36.009 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 4
11:43:36.013 ERROR [           main] d.m.a.sec05.Lec06ErrorHandling : Mensaje del error: / by zero
11:43:36.013 INFO  [           main] d.m.a.sec05.Lec06ErrorHandling : Generando valor aleatorio..
11:43:36.013 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 50
11:43:36.013 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 51
11:43:36.013 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 52
11:43:36.013 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 53
11:43:36.013 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 54
11:43:36.013 INFO  [           main] d.m.a.common.DefaultSubscriber :  ¬°completado!
````

Ahora veamos el siguiente ejemplo. El `Flux` comienza emitiendo un error de tipo `RuntimeException`. El primer operador
`onErrorResume(ArithmeticException.class, ...)` no captura la excepci√≥n porque el tipo no coincide, por lo que el flujo
contin√∫a al siguiente operador de manejo de errores.

El segundo operador `onErrorResume(throwable -> fallback())` s√≠ captura el `RuntimeException`, pero dentro del m√©todo
`fallback()` se lanza intencionalmente una nueva excepci√≥n de tipo `IllegalArgumentException`. Esto provoca un nuevo
error en la cadena, que a su vez activa el siguiente operador de manejo de errores.

Finalmente, el operador `onErrorReturn(-5)` act√∫a como √∫ltimo recurso, devolviendo el valor `-5` cuando se detecta que
la cadena ha fallado nuevamente. Despu√©s de emitir este valor, el flujo se completa normalmente.

Este flujo evidencia c√≥mo:

- `onErrorResume` puede ser encadenado para manejar diferentes tipos o escenarios de error.
- Si una nueva excepci√≥n ocurre dentro de un `fallback`, el control pasa al siguiente operador de error.
- `onErrorReturn` es √∫til como `√∫ltima defensa`, asegurando que el flujo nunca falle visiblemente para el suscriptor.

````java
public class Lec06ErrorHandling {
    private static final Logger log = LoggerFactory.getLogger(Lec06ErrorHandling.class);

    public static void main(String[] args) {
        onErrorResume2();
    }

    private static void onErrorResume2() {
        Flux.error(() -> new RuntimeException("Error de la fuente principal (intencional)"))
                .onErrorResume(ArithmeticException.class, throwable -> fallback(throwable))
                .onErrorResume(throwable -> fallback())
                .onErrorReturn(-5)
                .subscribe(Util.subscriber());

    }

    private static Mono<Integer> fallback(Throwable throwable) {
        log.error("Ocurri√≥ un error: {}", throwable.getMessage());
        log.info("Generando valor aleatorio...");
        return Mono.fromSupplier(() -> Util.faker().random().nextInt(10, 100));
    }

    private static Flux<Integer> fallback() {
        return Flux.error(new IllegalArgumentException("Ocurri√≥ un error (intencional)"));
    }
}
````

En √∫ltima instancia, al no poder recuperar el flujo mediante los operadores `onErrorResume` (ya sea por tipo de
excepci√≥n o por errores secundarios durante la recuperaci√≥n), el operador `onErrorReturn` se activa, emitiendo un valor
fijo y completando el flujo de manera controlada.

````bash
11:56:14.034 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: -5
11:56:14.039 INFO  [           main] d.m.a.common.DefaultSubscriber :  ¬°completado!
````

## Error Handling - onErrorComplete

Simplemente, complete la secuencia reemplazando una se√±al `onError` por una se√±al `onComplete`. Todas las dem√°s se√±ales
se propagan tal cual.

````java
public class Lec06ErrorHandling {
    private static final Logger log = LoggerFactory.getLogger(Lec06ErrorHandling.class);

    public static void main(String[] args) {
        onErrorComplete();
    }

    private static void onErrorComplete() {
        Mono.error(new RuntimeException("Error emitido intencionalmente"))
                .onErrorComplete()
                .subscribe(Util.subscriber());
    }
}
````

En este ejemplo, usamos el operador `onErrorComplete()` para interceptar un error y convertirlo en una se√±al de
finalizaci√≥n (`onComplete`).

Esto significa que si el `Mono` produce un error, dicho `error no ser√° propagado` al `suscriptor`. En su lugar, se
completar√° el flujo silenciosamente, como si no hubiera ocurrido ninguna excepci√≥n.

Es importante destacar que todas las dem√°s se√±ales (`onNext`, `onComplete`) siguen fluyendo de forma normal; solo la
se√±al `onError` es suprimida y reemplazada por `onComplete`.

````bash
12:31:12.659 INFO  [           main] d.m.a.common.DefaultSubscriber :  ¬°completado!
````

## Error Handling - onErrorContinue

El operador `onErrorContinue()` en Project Reactor permite que el flujo contin√∫e emitiendo elementos despu√©s de
encontrar un error, omitiendo los elementos problem√°ticos sin detener todo el flujo. A diferencia de operadores como
`onErrorReturn()` o `onErrorResume()`, que manejan el error y completan el flujo o lo reemplazan por una nueva
secuencia, `onErrorContinue()` simplemente omite el error y contin√∫a con los siguientes elementos.

Este operador permite que ciertos operadores compatibles se recuperen del error eliminando el elemento que caus√≥ el
problema, y se contin√∫e emitiendo los elementos subsiguientes. El error y el valor problem√°tico se notifican a trav√©s de
un `BiConsumer`, lo que permite personalizar el manejo del error. Si se lanza una nueva excepci√≥n desde ese
`BiConsumer`, esta se propagar√° hacia abajo en la cadena de operadores, y el error original quedar√° como una excepci√≥n
suprimida.

Cuando un error ocurre en un elemento del flujo, `onErrorContinue()` permite saltarse ese error y continuar procesando
los elementos restantes. Adem√°s, te permite acceder tanto al error como al elemento que caus√≥ el problema para manejar
el error de forma personalizada, pero sin detener la emisi√≥n de otros elementos.

````java
public class Lec06ErrorHandling {
    private static final Logger log = LoggerFactory.getLogger(Lec06ErrorHandling.class);

    public static void main(String[] args) {
        onErrorContinue();
    }

    private static void onErrorContinue() {
        Flux.range(1, 10)
                .map(value -> value == 5 ? 5 / 0 : value) //Intencional
                .onErrorContinue((throwable, value) -> {
                    log.error("Error ocurrido: {}", throwable.getMessage());
                    log.error("Valor que caus√≥ el error: {}", value);
                })
                .subscribe(Util.subscriber());
    }
}
````

Como se observa en la salida, cuando el valor 5 genera una excepci√≥n aritm√©tica, el operador `onErrorContinue()`
captura el error, registra tanto el mensaje como el valor que lo caus√≥, y permite que el flujo contin√∫e normalmente
con los siguientes elementos, en lugar de detenerse.

````bash
12:41:02.579 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 1
12:41:02.582 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 2
12:41:02.582 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 3
12:41:02.582 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 4
12:41:02.584 ERROR [           main] d.m.a.sec05.Lec06ErrorHandling : Error ocurrido: / by zero
12:41:02.584 ERROR [           main] d.m.a.sec05.Lec06ErrorHandling : Valor que caus√≥ el error: 5
12:41:02.585 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 6
12:41:02.585 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 7
12:41:02.585 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 8
12:41:02.585 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 9
12:41:02.585 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 10
12:41:02.585 INFO  [           main] d.m.a.common.DefaultSubscriber :  ¬°completado!
````

## Operador - DefaultIfEmpty

El operador `defaultIfEmpty()` en Project Reactor se utiliza para emitir un `valor por defecto` cuando un `Mono` o
`Flux` no emite ning√∫n elemento. Si el flujo est√° vac√≠o, `defaultIfEmpty()` permite proporcionar un valor alternativo en
lugar de completar el flujo sin emitir nada.

Este operador es especialmente √∫til cuando se desea evitar un flujo sin emisiones, proporcionando un valor `predefinido`
o `hardcodeado`, es decir, un valor conocido que se especifica directamente al invocar el operador. Este valor se
emitir√° √∫nicamente si el flujo original no emite elementos.

````java
public class Lec07DefaultIfEmpty {

    public static void main(String[] args) {
        Flux.empty()
                .defaultIfEmpty("Valor predefinido")
                .subscribe(Util.subscriber());
    }
}
````

En el resultado, observamos que se emite el valor `Valor predefinido`, ya que el `Flux` original no conten√≠a ning√∫n
elemento. El operador `defaultIfEmpty()` act√∫a como respaldo, garantizando que al menos un valor sea emitido antes de
completar el flujo.

````bash
13:04:33.083 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Valor predefinido
13:04:33.087 INFO  [           main] d.m.a.common.DefaultSubscriber :  ¬°completado!
````

## Operador - DefaultIfEmpty

El operador `switchIfEmpty()` en Project Reactor es similar a `defaultIfEmpty()`, pero ofrece m√°s flexibilidad.
Mientras que `defaultIfEmpty()` solo emite un valor `hardcodeado` cuando un flujo est√° vac√≠o, `switchIfEmpty()`
permite sustituir el flujo vac√≠o por otro `Publisher` (otro `Flux` o `Mono`). Esto lo hace √∫til cuando necesitas
reaccionar din√°micamente si no se emite ning√∫n valor.

Cuando el flujo original no emite ning√∫n valor, `switchIfEmpty()` permite `cambiar` a otro flujo (otro `Flux` o `Mono`)
y continuar la emisi√≥n desde esa nueva fuente.

````java
public class Lec08SwitchIfEmpty {

    public static void main(String[] args) {
        Flux.range(1, 10)
                .filter(value -> value > 11) // Intencional
                .switchIfEmpty(fallback())
                .subscribe(Util.subscriber());
    }

    private static Flux<Integer> fallback() {
        return Flux.range(100, 3);
    }
}
````

Como se observa en el resultado, el `Flux` original no emite ning√∫n elemento porque ninguno cumple la condici√≥n
establecida en el filter. Debido a esto, el flujo queda vac√≠o y se activa el operador `switchIfEmpty()`, el cual
sustituye el flujo vac√≠o por el emitido por el m√©todo `fallback()`. Este m√©todo proporciona un nuevo `Flux` que emite
los valores 100, 101 y 102, asegurando as√≠ que el suscriptor reciba elementos a pesar del filtro inicial.

````bash
13:14:11.053 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 100
13:14:11.056 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 101
13:14:11.056 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 102
13:14:11.059 INFO  [           main] d.m.a.common.DefaultSubscriber :  ¬°completado!
````

## Operador - Timeout

El `timeout()` propaga una excepci√≥n `TimeoutException` si no se emite ning√∫n elemento dentro del tiempo especificado.
En el siguiente ejemplo, `timeout(Duration.ofSeconds(1))` esperar√° como m√°ximo 1 segundo a que el `Publisher` del
m√©todo `getProductName()` emita un valor. Si transcurre ese tiempo sin recibir una respuesta, el operador `timeout()`
propagar√° la excepci√≥n `TimeoutException`.

````java
public class Lec09Timeout {
    public static void main(String[] args) {
        timeoutDefaultBehavior();
        Util.sleepSeconds(4); // Evita que el programa termine antes de ver el resultado
    }

    private static void timeoutDefaultBehavior() {
        getProductName()
                .timeout(Duration.ofSeconds(1)) // Como m√°ximo esperamos 1 segundo, sino lanzamos el TimeoutException
                .subscribe(Util.subscriber());
    }

    private static Mono<String> getProductName() {
        return Mono.fromSupplier(() -> Util.faker().commerce().productName())
                .delayElement(Duration.ofSeconds(3)); // Simula una demora de 3 segundos
    }
}
````

En este ejemplo, el m√©todo `getProductName()` se demora intencionalmente `3 segundos` en emitir un valor.
Como el operador `timeout()` est√° configurado para esperar solo `1 segundo`, se lanza una excepci√≥n de tipo
`TimeoutException` al no recibirse ninguna se√±al dentro del tiempo l√≠mite.

````bash
15:34:19.770 ERROR [     parallel-2] d.m.a.common.DefaultSubscriber :  error: Did not observe any item or terminal signal within 1000ms in 'delayElement' (and no fallback has been configured)
````

En el siguiente ejemplo, se maneja la excepci√≥n producida por el operador `timeout()` utilizando el operador
`onErrorReturn`. Esto permite emitir un valor por defecto en caso de que se produzca una excepci√≥n, como una
`TimeoutException`.

````java
public class Lec09Timeout {
    public static void main(String[] args) {
        timeoutDefaultBehaviorWithErrorHandler();
        Util.sleepSeconds(4);
    }

    private static void timeoutDefaultBehaviorWithErrorHandler() {
        getProductName()
                .timeout(Duration.ofSeconds(1))
                .onErrorReturn("Producto de respaldo")
                .subscribe(Util.subscriber());
    }

    private static Mono<String> getProductName() {
        return Mono.fromSupplier(() -> Util.faker().commerce().productName())
                .delayElement(Duration.ofSeconds(3));
    }
}
````

En este caso, como el m√©todo `getProductName()` tarda 3 segundos en responder y el `timeout()` solo permite 1 segundo,
se lanza una excepci√≥n. Sin embargo, en lugar de propagarla, el operador `onErrorReturn` captura la excepci√≥n y emite
un valor por defecto: ` Producto de respaldo`.

````bash
15:54:11.091 INFO  [     parallel-2] d.m.a.common.DefaultSubscriber :  recibido: Producto de respaldo
15:54:11.096 INFO  [     parallel-2] d.m.a.common.DefaultSubscriber :  ¬°completado!
````

Ahora veamos una caracter√≠stica adicional del operador `timeout()`. Este operador permite definir un `fallback`
directamente como segundo par√°metro. Esto nos da la posibilidad de reaccionar ante un tiempo de espera excedido sin
necesidad de utilizar `onErrorResume` por separado. Por ejemplo, podr√≠amos llamar a otro servicio alternativo en caso
de que el original no responda a tiempo.

En el siguiente ejemplo, se define un `timeout` de 1 segundo. Si transcurre ese tiempo sin recibir una se√±al, se invoca
el m√©todo `getFallback()`, que retorna un `Mono` alternativo.

Es importante tener en cuenta que el l√≠mite de tiempo de 1 segundo solo aplica a la ejecuci√≥n de `getProductName()`.
Una vez que se activa el `fallback`, ya no se aplica el `timeout`, por lo que `getFallback()` puede demorarse lo que
sea necesario.

````java
public class Lec09Timeout {
    public static void main(String[] args) {
        timeoutFallback();
        Util.sleepSeconds(5);
    }

    private static void timeoutFallback() {
        getProductName()
                .timeout(Duration.ofSeconds(1), getFallback())
                .subscribe(Util.subscriber());
    }

    private static Mono<String> getProductName() {
        return Mono.fromSupplier(() -> Util.faker().commerce().productName())
                .delayElement(Duration.ofSeconds(3));
    }

    private static Mono<String> getFallback() {
        return Mono.fromSupplier(() -> "getFallback(): " + Util.faker().commerce().productName())
                .delayElement(Duration.ofSeconds(3));

    }
}
````

El tiempo l√≠mite de 1 segundo aplica √∫nicamente a `getProductName()`. Una vez que se activa el `fallback`, ya no se
impone ning√∫n l√≠mite de tiempo a su ejecuci√≥n.

````bash
16:05:32.927 INFO  [     parallel-3] d.m.a.common.DefaultSubscriber :  recibido: getFallback(): Ergonomic Bronze Gloves
16:05:32.933 INFO  [     parallel-3] d.m.a.common.DefaultSubscriber :  ¬°completado!
````

## Operador - Transform

### Introducci√≥n al operador `transform()`

En `programaci√≥n reactiva`, construir pipelines con m√∫ltiples operadores es muy com√∫n. Sin embargo, es f√°cil caer en
la repetici√≥n cuando aplicamos los mismos operadores entre el `Publisher` y el `Subscriber` en diferentes flujos.

Veamos el siguiente ejemplo, donde usamos `doOnNext`, `doOnError` y `doOnComplete` tanto para clientes como para √≥rdenes
de compra.

````java

public class Lec10Transform {

    private static final Logger log = LoggerFactory.getLogger(Lec10Transform.class);

    public static void main(String[] args) {
        getCustomers()
                .doOnNext(cusomer -> log.info("recibido: {}", cusomer))
                .doOnError(throwable -> log.error("error: {}", throwable.getMessage()))
                .doOnComplete(() -> log.info("¬°Se complet√≥!"))
                .subscribe();
        log.info("");
        getPurchaseOrders()
                .doOnNext(purchaseOrder -> log.info("recibido: {}", purchaseOrder))
                .doOnError(throwable -> log.error("error: {}", throwable.getMessage()))
                .doOnComplete(() -> log.info("¬°Se complet√≥!"))
                .subscribe();
    }

    private static Flux<Cusomer> getCustomers() {
        return Flux.range(1, 3)
                .map(value -> new Cusomer(value, Util.faker().name().firstName()));
    }

    private static Flux<PurchaseOrder> getPurchaseOrders() {
        return Flux.range(1, 3)
                .map(value -> new PurchaseOrder(Util.faker().commerce().productName(), value, value * 10));
    }

    record Cusomer(int id, String name) {
    }

    record PurchaseOrder(String productName, int price, int quantity) {
    }
}
````

Como se puede observar, hay una repetici√≥n evidente de operadores (`doOnNext`, `doOnError`, `doOnComplete`) en ambos
flujos. Entonces, `¬øexiste alguna forma de reutilizar esta l√≥gica com√∫n de manera m√°s limpia y elegante?`

S√≠, y aqu√≠ es donde entra en juego el operador `transform()`. Este operador nos permite encapsular una secuencia de
transformaciones comunes en una sola funci√≥n reutilizable.

````bash
16:55:34.474 INFO  [           main] d.m.app.sec05.Lec10Transform   : recibido: Cusomer[id=1, name=Leona]
16:55:34.502 INFO  [           main] d.m.app.sec05.Lec10Transform   : recibido: Cusomer[id=2, name=Hiram]
16:55:34.503 INFO  [           main] d.m.app.sec05.Lec10Transform   : recibido: Cusomer[id=3, name=Agnus]
16:55:34.503 INFO  [           main] d.m.app.sec05.Lec10Transform   : ¬°Se complet√≥!
16:55:34.503 INFO  [           main] d.m.app.sec05.Lec10Transform   : 
16:55:34.509 INFO  [           main] d.m.app.sec05.Lec10Transform   : recibido: PurchaseOrder[productName=Ergonomic Silk Gloves, price=1, quantity=10]
16:55:34.521 INFO  [           main] d.m.app.sec05.Lec10Transform   : recibido: PurchaseOrder[productName=Fantastic Rubber Lamp, price=2, quantity=20]
16:55:34.521 INFO  [           main] d.m.app.sec05.Lec10Transform   : recibido: PurchaseOrder[productName=Awesome Rubber Keyboard, price=3, quantity=30]
16:55:34.521 INFO  [           main] d.m.app.sec05.Lec10Transform   : ¬°Se complet√≥!
````

### Uso del operador `transform()` en Project Reactor para componer operadores reutilizables

El operador `transform()` en Project Reactor permite transformar un flujo (`Flux` o `Mono`) utilizando una funci√≥n. Es
una forma de aplicar una serie de operadores a un flujo dentro de una operaci√≥n de transformaci√≥n reutilizable. El
objetivo principal de `transform()` es permitir la composici√≥n de operadores en un solo paso.

`transform`: Es una funci√≥n que recibe un `Flux<T>` y devuelve un nuevo `Publisher<V>`. Dentro de esta funci√≥n puedes
aplicar cualquier transformaci√≥n o conjunto de operadores al flujo original.

Con el operador `transform()` podemos evitar duplicaci√≥n de c√≥digo. Si aplicas la misma serie de operadores en varios
lugares de tu c√≥digo, puedes encapsular esa l√≥gica en una funci√≥n y usar `transform()` para aplicarla de manera
consistente en diferentes flujos.

````java
public class Lec10Transform {

    private static final Logger log = LoggerFactory.getLogger(Lec10Transform.class);

    public static void main(String[] args) {
        getCustomers()
                .transform(addDebugger())
                .subscribe();
        log.info("");
        getPurchaseOrders()
                .transform(addDebugger())
                .subscribe();
    }

    private static Flux<Cusomer> getCustomers() {
        return Flux.range(1, 3)
                .map(value -> new Cusomer(value, Util.faker().name().firstName()));
    }

    private static Flux<PurchaseOrder> getPurchaseOrders() {
        return Flux.range(1, 3)
                .map(value -> new PurchaseOrder(Util.faker().commerce().productName(), value, value * 10));
    }

    private static <T> Function<Flux<T>, Flux<T>> addDebugger() {
        return flux -> flux
                .doOnNext(value -> log.info("recibido: {}", value))
                .doOnError(throwable -> log.error("error: {}", throwable.getMessage()))
                .doOnComplete(() -> log.info("¬°Se complet√≥!"));
    }

    record Cusomer(int id, String name) {
    }

    record PurchaseOrder(String productName, int price, int quantity) {
    }

}
````

En el c√≥digo anterior hemos creado el m√©todo gen√©rico `addDebugger()`, este m√©todo retorna una funci√≥n que toma un
`Flux<T>` como entrada y retorna un `Flux<T>` como salida. En otras palabras, se recibe un `flux` y se retorna el
mismo `flux`.

El m√©todo toma un `Flux<T>` y aplica varios operadores como `doOnNext()`, `doOnError()`, y `doOnComplete()` para a√±adir
acciones de depuraci√≥n. La salida es otro `Flux<T>` con los mismos elementos, pero ahora con capacidades de depuraci√≥n
a√±adidas.

````bash
17:08:46.484 INFO  [           main] d.m.app.sec05.Lec10Transform   : recibido: Cusomer[id=1, name=Cathy]
17:08:46.508 INFO  [           main] d.m.app.sec05.Lec10Transform   : recibido: Cusomer[id=2, name=Weston]
17:08:46.509 INFO  [           main] d.m.app.sec05.Lec10Transform   : recibido: Cusomer[id=3, name=Eusebio]
17:08:46.509 INFO  [           main] d.m.app.sec05.Lec10Transform   : ¬°Se complet√≥!
17:08:46.509 INFO  [           main] d.m.app.sec05.Lec10Transform   : 
17:08:46.514 INFO  [           main] d.m.app.sec05.Lec10Transform   : recibido: PurchaseOrder[productName=Mediocre Granite Car, price=1, quantity=10]
17:08:46.525 INFO  [           main] d.m.app.sec05.Lec10Transform   : recibido: PurchaseOrder[productName=Rustic Paper Coat, price=2, quantity=20]
17:08:46.525 INFO  [           main] d.m.app.sec05.Lec10Transform   : recibido: PurchaseOrder[productName=Heavy Duty Cotton Bottle, price=3, quantity=30]
17:08:46.525 INFO  [           main] d.m.app.sec05.Lec10Transform   : ¬°Se complet√≥!
````

### Uso de `UnaryOperator` como alternativa clara y sem√°ntica a `Function` en transformaciones de Flux

Ahora, el m√©todo gen√©rico que creamos anteriormente utiliza el tipo `Function<Flux<T>, Flux<T>>` pero podr√≠amos haberlo
creado usando la interfaz funcional `UnaryOperator<T>`, dado que esta interfaz extiende a la interfaz funcional
`Function<T,T>`.

`UnaryOperator<Flux<T>>`, este es un caso especial de `Function<T, T>` cuando el tipo de entrada y el tipo de salida
son el mismo (`Flux<T>` en este caso). Al usar `UnaryOperator`, simplemente indicas que el m√©todo devuelve una funci√≥n
que toma y devuelve un `Flux<T>` del mismo tipo, lo que en realidad es una simplificaci√≥n sem√°ntica del uso de
`Function<Flux<T>, Flux<T>>`.

````java
private static <T> UnaryOperator<Flux<T>> addDebugger() {
    return flux -> flux
            .doOnNext(value -> log.info("recibido: {}", value))
            .doOnError(throwable -> log.error("error", throwable))
            .doOnComplete(() -> log.info("Completado"));
}
````

Realizando este cambio, nuestro ejemplo quedar√≠a de la siguiente manera.

````java
public class Lec10Transform {

    private static final Logger log = LoggerFactory.getLogger(Lec10Transform.class);

    public static void main(String[] args) {
        getCustomers()
                .transform(addDebugger())
                .subscribe();
        log.info("");
        getPurchaseOrders()
                .transform(addDebugger())
                .subscribe();
    }

    private static Flux<Cusomer> getCustomers() {
        return Flux.range(1, 3)
                .map(value -> new Cusomer(value, Util.faker().name().firstName()));
    }

    private static Flux<PurchaseOrder> getPurchaseOrders() {
        return Flux.range(1, 3)
                .map(value -> new PurchaseOrder(Util.faker().commerce().productName(), value, value * 10));
    }

    private static <T> UnaryOperator<Flux<T>> addDebugger() {
        return flux -> flux
                .doOnNext(value -> log.info("recibido: {}", value))
                .doOnError(throwable -> log.error("error: {}", throwable.getMessage()))
                .doOnComplete(() -> log.info("¬°Se complet√≥!"));
    }

    record Cusomer(int id, String name) {
    }

    record PurchaseOrder(String productName, int price, int quantity) {
    }

}
````

Observamos que el resultado es similar a cuando usamos el `Function<Flux<T>, Flux<T>>`.

````bash
17:24:27.746 INFO  [           main] d.m.app.sec05.Lec10Transform   : recibido: Cusomer[id=1, name=Willie]
17:24:27.781 INFO  [           main] d.m.app.sec05.Lec10Transform   : recibido: Cusomer[id=2, name=Elinore]
17:24:27.781 INFO  [           main] d.m.app.sec05.Lec10Transform   : recibido: Cusomer[id=3, name=Mattie]
17:24:27.781 INFO  [           main] d.m.app.sec05.Lec10Transform   : ¬°Se complet√≥!
17:24:27.782 INFO  [           main] d.m.app.sec05.Lec10Transform   : 
17:24:27.788 INFO  [           main] d.m.app.sec05.Lec10Transform   : recibido: PurchaseOrder[productName=Heavy Duty Wooden Clock, price=1, quantity=10]
17:24:27.799 INFO  [           main] d.m.app.sec05.Lec10Transform   : recibido: PurchaseOrder[productName=Synergistic Marble Car, price=2, quantity=20]
17:24:27.799 INFO  [           main] d.m.app.sec05.Lec10Transform   : recibido: PurchaseOrder[productName=Practical Silk Keyboard, price=3, quantity=30]
17:24:27.799 INFO  [           main] d.m.app.sec05.Lec10Transform   : ¬°Se complet√≥!
````

### Control condicional de transformaciones con `transform()` y `Function.identity()`

Ahora, supongamos que por alguna raz√≥n queremos controlar cu√°ndo ejecutar la funci√≥n del `transform` y cu√°ndo no. Para
eso podemos aplicar el siguiente c√≥digo dentro del operador
`transform(isDebugEnabled ? addDebugger() : Function.identity())`.

````java
public class Lec10Transform {

    private static final Logger log = LoggerFactory.getLogger(Lec10Transform.class);

    public static void main(String[] args) {
        boolean isDebugEnabled = false;

        getCustomers()
                .transform(isDebugEnabled ? addDebugger() : Function.identity())
                .subscribe();
        log.info("");
        getPurchaseOrders()
                .transform(addDebugger())
                .subscribe();
    }

    private static Flux<Cusomer> getCustomers() {
        return Flux.range(1, 3)
                .map(value -> new Cusomer(value, Util.faker().name().firstName()));
    }

    private static Flux<PurchaseOrder> getPurchaseOrders() {
        return Flux.range(1, 3)
                .map(value -> new PurchaseOrder(Util.faker().commerce().productName(), value, value * 10));
    }

    private static <T> UnaryOperator<Flux<T>> addDebugger() {
        return flux -> flux
                .doOnNext(value -> log.info("recibido: {}", value))
                .doOnError(throwable -> log.error("error: {}", throwable.getMessage()))
                .doOnComplete(() -> log.info("¬°Se complet√≥!"));
    }

    record Cusomer(int id, String name) {
    }

    record PurchaseOrder(String productName, int price, int quantity) {
    }

}
````

`Function.identity()` devuelve una funci√≥n que retorna exactamente el mismo `Flux` que recibe, sin aplicar
transformaci√≥n alguna.

En el c√≥digo anterior, al estar `isDebugEnabled` en `false`, no aplicamos la funci√≥n `addDebugger()`, sino que usamos
`Function.identity()` para mantener el flujo sin modificaciones. Como resultado, solo se imprimen los mensajes
correspondientes al flujo de `getPurchaseOrders()`, ya que en ese caso s√≠ se aplic√≥ la funci√≥n `addDebugger()`.

````bash
17:29:28.284 INFO  [           main] d.m.app.sec05.Lec10Transform   : 
17:29:28.294 INFO  [           main] d.m.app.sec05.Lec10Transform   : recibido: PurchaseOrder[productName=Heavy Duty Aluminum Pants, price=1, quantity=10]
17:29:28.324 INFO  [           main] d.m.app.sec05.Lec10Transform   : recibido: PurchaseOrder[productName=Gorgeous Bronze Watch, price=2, quantity=20]
17:29:28.325 INFO  [           main] d.m.app.sec05.Lec10Transform   : recibido: PurchaseOrder[productName=Ergonomic Copper Table, price=3, quantity=30]
17:29:28.325 INFO  [           main] d.m.app.sec05.Lec10Transform   : ¬°Se complet√≥!
````

## Tarea asignada

- Tenemos 4 ids de productos: 1, 2, 3, 4.
- Obtener el nombre del producto usando `product-service`.
- Timeout 2 segundos.
    - Llama al servicio `fallback for timeout` para obtener el nombre del producto.
- Llama al servicio `fallback for empty` para obtener el nombre del producto en caso de que est√© vac√≠o.
- Deje que la clase cliente abstraiga el manejo de tiempos de espera y tiempos vac√≠os.
    - client.getProductName(1)

### Soluci√≥n

Lo primero que haremos ser√° levantar el servicio externo que utilizaremos para resolver esta tarea.

````bash
D:\programming\spring\01.udemy\03.vinoth_selvaraj\java-reactive-programming (feature/section-5)
$ java -jar .\servers\external-services.jar
````

Los tres endpoints que usaremos se muestran en la siguiente imagen.

![01.png](assets/section-05/01.png)

Lo primero que haremos ser√° crear en nuestra clase de servicio externo el endpoint hacia donde realizaremos la petici√≥n.

````java
public class ExternalServiceClient extends AbstractHttpClient {

    public Mono<String> getProductName(int productId) {
        String defaultPath = "/demo03/product/" + productId;
        String timeoutPath = "/demo03/timeout-fallback/product/" + productId;
        String emptyPath = "/demo03/empty-fallback/product/" + productId;
        return this.getProductName(defaultPath)
                .timeout(Duration.ofSeconds(2), getProductName(timeoutPath))
                .switchIfEmpty(getProductName(emptyPath));
    }

    private Mono<String> getProductName(String path) {
        return this.httpClient
                .get()
                .uri(path)
                .responseContent()
                .asString()
                .next();
    }

}
````

Finalmente, en la clase principal utilizando un bucle `for` llamamos al endpoint definido anteriormente pas√°ndole en
cada iteraci√≥n el identificador del producto a consultar.

````java
public class Lec11Assignment {

    private static final Logger log = LoggerFactory.getLogger(Lec11Assignment.class);

    public static void main(String[] args) {
        ExternalServiceClient externalServiceClient = new ExternalServiceClient();
        for (int i = 1; i <= 4; i++) {
            externalServiceClient.getProductName(i)
                    .subscribe(Util.subscriber());
        }

        Util.sleepSeconds(3);
    }
}
````

Los resultados, seg√∫n cada identificador del producto consultado se muestran a continuaci√≥n. El √∫nico producto que
se consult√≥ sin hacer uso de m√©todos alternativos fue el `product-1`, los dem√°s si hicieron uso de llamadas a los
endpoints `timeout-fallback` y `empty-fallback`.

````bash
18:29:13.711 INFO  [magadiflo-nio-1] d.m.a.common.DefaultSubscriber :  recibido: product-2 from empty-fallback
18:29:13.715 INFO  [magadiflo-nio-1] d.m.a.common.DefaultSubscriber :  ¬°completado!
18:29:14.704 INFO  [magadiflo-nio-1] d.m.a.common.DefaultSubscriber :  recibido: product-1
18:29:14.706 INFO  [magadiflo-nio-1] d.m.a.common.DefaultSubscriber :  ¬°completado!
18:29:15.621 INFO  [magadiflo-nio-1] d.m.a.common.DefaultSubscriber :  recibido: product-3 from timeout-fallback
18:29:15.621 INFO  [magadiflo-nio-1] d.m.a.common.DefaultSubscriber :  ¬°completado!
18:29:15.624 INFO  [magadiflo-nio-1] d.m.a.common.DefaultSubscriber :  recibido: product-4 from empty-fallback
18:29:15.624 INFO  [magadiflo-nio-1] d.m.a.common.DefaultSubscriber :  ¬°completado!
````
