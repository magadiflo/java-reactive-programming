# Secci√≥n 11: Repeat & Retry

---

## Introducci√≥n

En la programaci√≥n reactiva con Reactor, los operadores `repeat` y `retry` permiten volver a ejecutar una secuencia
de datos bajo ciertas condiciones espec√≠ficas. Ambos son √∫tiles cuando se quiere repetir una operaci√≥n, pero lo hacen
en circunstancias distintas.

- `repeat`: Este operador vuelve a suscribirse autom√°ticamente al Publisher una vez que este ha emitido todos sus
  elementos y ha finalizado con una se√±al de `onComplete`. Es decir, se repite la secuencia desde el inicio despu√©s de
  completarse exitosamente.


- `retry`: En cambio, este operador vuelve a suscribirse autom√°ticamente despu√©s de una se√±al de `onError`. Se utiliza
  cuando ocurre un error en la secuencia, y se desea intentar nuevamente la operaci√≥n.

Estos operadores son √∫tiles en casos como:

- `repeat`: para reenviar solicitudes peri√≥dicas, simular m√∫ltiples flujos id√©nticos, o testear comportamiento repetido.
- `retry`: para manejar errores temporales como problemas de red, ca√≠das moment√°neas de servicios externos, etc.

> ‚ö†Ô∏è Es importante tener cuidado al usar estos operadores sin restricciones, ya que pueden generar bucles infinitos si
> no se configura un n√∫mero m√°ximo de repeticiones o reintentos.

## Repeat

El operador `repeat` en Reactor se utiliza para volver a ejecutar una secuencia despu√©s de que esta ha finalizado
exitosamente, es decir, despu√©s de que se emite la se√±al `onComplete`.

Caracter√≠sticas principales:

- Vuelve a `suscribirse` a la fuente original despu√©s de la `finalizaci√≥n` (no despu√©s de un error).
- El n√∫mero de repeticiones puede ser controlado pasando un valor entero como argumento.
- Al aplicarlo a un `Mono`, este se convierte en un `Flux`, ya que se emitir√°n m√∫ltiples valores a trav√©s de
  repeticiones.

### Ejemplo 01

````java
public class Lec01Repeat {
    public static void main(String[] args) {
        demo1();
    }

    private static void demo1() {
        // Desde que se aplica repeat(), el tipo cambia de Mono a Flux. Esto ejecutar√° la fuente original 
        // 1 (emisi√≥n original) + 2 (repeticiones) = 3 veces.
        getCountryName()
                .repeat(2)
                .subscribe(Util.subscriber());
    }

    private static Mono<String> getCountryName() {
        return Mono.fromSupplier(() -> Util.faker().country().name());
    }
}
````

Observaciones:

- En este caso, el `Mono` original genera un pa√≠s aleatorio. Al aplicar `repeat(2)`, la secuencia se repite dos veces
  adicionales, resultando en `tres elementos emitidos` en total.
- El operador `repeat` `no maneja errores`. Si ocurre un error en la fuente, el operador no reintentar√°, simplemente
  propagar√° el error.

````bash
12:43:09.909 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Iceland
12:43:09.913 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Grenada
12:43:09.913 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Serbia
12:43:09.917 INFO  [           main] d.m.a.common.DefaultSubscriber :  ¬°completado!
````

### Ejemplo 02: Repetir hasta cumplir una condici√≥n

En este ejemplo, se utiliza el operador `repeat` junto con `takeUntil` para seguir repitiendo la ejecuci√≥n de un `Mono`
hasta que se cumpla una condici√≥n espec√≠fica: en este caso, que se emita el pa√≠s `Peru`.

````java
public class Lec01Repeat {
    public static void main(String[] args) {
        demo2();
    }

    private static void demo2() {
        getCountryName()
                .repeat()
                .takeUntil(country -> country.equalsIgnoreCase("peru"))
                .subscribe(Util.subscriber());
    }

    private static Mono<String> getCountryName() {
        return Mono.fromSupplier(() -> Util.faker().country().name());
    }
}
````

Explicaci√≥n:

- `repeat()` permite que el `Mono` vuelva a ejecutarse indefinidamente.
- `takeUntil(...)` act√∫a como una condici√≥n de salida: detiene la emisi√≥n cuando se recibe el valor `Peru`.
- Este patr√≥n es √∫til cuando se quiere `esperar` hasta obtener un resultado deseado, repitiendo la operaci√≥n cuantas
  veces sea necesario.
- En este caso, el `Mono` que genera un nombre de pa√≠s se ejecuta m√∫ltiples veces hasta que devuelve `Peru`, momento en
  el cual se completa el flujo.

> üí° Es una forma elegante de construir un bucle reactivo basado en condici√≥n sin escribir estructuras de control
> tradicionales como `while`.

````bash
15:07:53.216 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Azerbaijan
15:07:53.219 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Chad
15:07:53.220 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Azerbaijan
15:07:53.220 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Philippines
15:07:53.220 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Saint Vincent and the Grenadines
15:07:53.220 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Algeria
15:07:53.220 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Peru
15:07:53.223 INFO  [           main] d.m.a.common.DefaultSubscriber :  ¬°completado!
````

### Ejemplo 03: Repetir controladamente usando una condici√≥n

En este ejemplo se utiliza el operador `repeat(BooleanSupplier)` para controlar expl√≠citamente cu√°ntas veces se debe
repetir la ejecuci√≥n del `Mono`. En lugar de repetir indefinidamente, se emplea una condici√≥n basada en un contador
para limitar el n√∫mero de repeticiones.

````java
public class Lec01Repeat {
    public static void main(String[] args) {
        demo3();
    }

    private static void demo3() {
        AtomicInteger atomicInteger = new AtomicInteger(0);
        getCountryName()
                .repeat(() -> atomicInteger.incrementAndGet() < 3)
                .subscribe(Util.subscriber());
    }

    private static Mono<String> getCountryName() {
        return Mono.fromSupplier(() -> Util.faker().country().name());
    }
}
````

Explicaci√≥n:

- Se crea un `AtomicInteger` para contar las repeticiones.
- El operador `repeat(BooleanSupplier)` eval√∫a la condici√≥n cada vez que se emite un valor y el flujo se completa.
- En este caso, el `Mono` se ejecutar√° mientras el contador sea menor que 3.
- Es decir, se obtiene un pa√≠s 3 veces, y luego el flujo se completa.

> üí° Este patr√≥n es √∫til cuando se desea controlar manualmente el n√∫mero de repeticiones, por ejemplo, para implementar
> una l√≥gica de reintento limitada o simular pruebas con un n√∫mero fijo de iteraciones.

````bash
15:11:02.382 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Mali
15:11:02.385 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Angola
15:11:02.385 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Albania
15:11:02.388 INFO  [           main] d.m.a.common.DefaultSubscriber :  ¬°completado!
````

### Ejemplo 04: Repetir con retraso y control mediante repeatWhen

En este ejemplo se utiliza el operador `repeatWhen` que permite controlar de manera flexible cu√°ndo se repite un
`Mono` o `Flux` en funci√≥n de un flujo que recibe las se√±ales de repetici√≥n.

````java
public class Lec01Repeat {
    public static void main(String[] args) {
        demo4();
        Util.sleepSeconds(10);
    }

    private static void demo4() {
        getCountryName()
                .repeatWhen(flux -> flux
                        .delayElements(Duration.ofSeconds(2))   // Retrasa cada repetici√≥n 2 segundos
                        .take(2))                               // Limita a 2 repeticiones
                .subscribe(Util.subscriber());
    }

    private static Mono<String> getCountryName() {
        return Mono.fromSupplier(() -> Util.faker().country().name());
    }
}
````

Explicaci√≥n:

- `repeatWhen` recibe un Flux que indica las se√±ales de repetici√≥n.
- En este caso, esas se√±ales se retrasan 2 segundos con `delayElements(Duration.ofSeconds(2))` para espaciar las
  repeticiones.
- `take(2)` limita la cantidad de repeticiones a 2, lo que significa que el `Mono` original se ejecutar√° 3 veces en
  total (`1 inicial + 2 repeticiones`).
- Se observa que cada repetici√≥n se ejecuta en un hilo paralelo, mostrando la naturaleza as√≠ncrona del retraso.
- Finalmente, despu√©s de las repeticiones indicadas, el flujo se completa.

> üí° `repeatWhen` es especialmente √∫til para implementar patrones donde quieres repetir con condiciones temporales o
> basadas en eventos externos, controlando la cadencia y cantidad de repeticiones.

````bash
15:16:35.062 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Bahrain
15:16:37.090 INFO  [     parallel-1] d.m.a.common.DefaultSubscriber :  recibido: Canada
15:16:39.098 INFO  [     parallel-2] d.m.a.common.DefaultSubscriber :  recibido: Papua New Guinea
15:16:39.100 INFO  [     parallel-2] d.m.a.common.DefaultSubscriber :  ¬°completado!
````
