# Secci√≥n 11: Repeat & Retry

---

## Introducci√≥n

En la programaci√≥n reactiva con Reactor, los operadores `repeat` y `retry` permiten volver a ejecutar una secuencia
de datos bajo ciertas condiciones espec√≠ficas. Ambos son √∫tiles cuando se quiere repetir una operaci√≥n, pero lo hacen
en circunstancias distintas.

- `repeat`: Este operador vuelve a suscribirse autom√°ticamente al Publisher una vez que este ha emitido todos sus
  elementos y ha finalizado con una se√±al de `onComplete`. Es decir, se repite la secuencia desde el inicio despu√©s de
  completarse exitosamente.


- `retry`: En cambio, este operador vuelve a suscribirse autom√°ticamente despu√©s de una se√±al de `onError`. Se utiliza
  cuando ocurre un error en la secuencia, y se desea intentar nuevamente la operaci√≥n.

Estos operadores son √∫tiles en casos como:

- `repeat`: para reenviar solicitudes peri√≥dicas, simular m√∫ltiples flujos id√©nticos, o testear comportamiento repetido.
- `retry`: para manejar errores temporales como problemas de red, ca√≠das moment√°neas de servicios externos, etc.

> ‚ö†Ô∏è Es importante tener cuidado al usar estos operadores sin restricciones, ya que pueden generar bucles infinitos si
> no se configura un n√∫mero m√°ximo de repeticiones o reintentos.

## Repeat

El operador `repeat` en Reactor se utiliza para volver a ejecutar una secuencia despu√©s de que esta ha finalizado
exitosamente, es decir, despu√©s de que se emite la se√±al `onComplete`.

Caracter√≠sticas principales:

- Vuelve a `suscribirse` a la fuente original despu√©s de la `finalizaci√≥n` (no despu√©s de un error).
- El n√∫mero de repeticiones puede ser controlado pasando un valor entero como argumento.
- Al aplicarlo a un `Mono`, este se convierte en un `Flux`, ya que se emitir√°n m√∫ltiples valores a trav√©s de
  repeticiones.

### Ejemplo 01

````java
public class Lec01Repeat {
    public static void main(String[] args) {
        demo1();
    }

    private static void demo1() {
        // Desde que se aplica repeat(), el tipo cambia de Mono a Flux. Esto ejecutar√° la fuente original 
        // 1 (emisi√≥n original) + 2 (repeticiones) = 3 veces.
        getCountryName()
                .repeat(2)
                .subscribe(Util.subscriber());
    }

    private static Mono<String> getCountryName() {
        return Mono.fromSupplier(() -> Util.faker().country().name());
    }
}
````

Observaciones:

- En este caso, el `Mono` original genera un pa√≠s aleatorio. Al aplicar `repeat(2)`, la secuencia se repite dos veces
  adicionales, resultando en `tres elementos emitidos` en total.
- El operador `repeat` `no maneja errores`. Si ocurre un error en la fuente, el operador no reintentar√°, simplemente
  propagar√° el error.

````bash
12:43:09.909 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Iceland
12:43:09.913 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Grenada
12:43:09.913 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Serbia
12:43:09.917 INFO  [           main] d.m.a.common.DefaultSubscriber :  ¬°completado!
````

### Ejemplo 02: Repetir hasta cumplir una condici√≥n

En este ejemplo, se utiliza el operador `repeat` junto con `takeUntil` para seguir repitiendo la ejecuci√≥n de un `Mono`
hasta que se cumpla una condici√≥n espec√≠fica: en este caso, que se emita el pa√≠s `Peru`.

````java
public class Lec01Repeat {
    public static void main(String[] args) {
        demo2();
    }

    private static void demo2() {
        getCountryName()
                .repeat()
                .takeUntil(country -> country.equalsIgnoreCase("peru"))
                .subscribe(Util.subscriber());
    }

    private static Mono<String> getCountryName() {
        return Mono.fromSupplier(() -> Util.faker().country().name());
    }
}
````

Explicaci√≥n:

- `repeat()` permite que el `Mono` vuelva a ejecutarse indefinidamente.
- `takeUntil(...)` act√∫a como una condici√≥n de salida: detiene la emisi√≥n cuando se recibe el valor `Peru`.
- Este patr√≥n es √∫til cuando se quiere `esperar` hasta obtener un resultado deseado, repitiendo la operaci√≥n cuantas
  veces sea necesario.
- En este caso, el `Mono` que genera un nombre de pa√≠s se ejecuta m√∫ltiples veces hasta que devuelve `Peru`, momento en
  el cual se completa el flujo.

> üí° Es una forma elegante de construir un bucle reactivo basado en condici√≥n sin escribir estructuras de control
> tradicionales como `while`.

````bash
15:07:53.216 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Azerbaijan
15:07:53.219 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Chad
15:07:53.220 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Azerbaijan
15:07:53.220 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Philippines
15:07:53.220 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Saint Vincent and the Grenadines
15:07:53.220 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Algeria
15:07:53.220 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Peru
15:07:53.223 INFO  [           main] d.m.a.common.DefaultSubscriber :  ¬°completado!
````

### Ejemplo 03: Repetir controladamente usando una condici√≥n

En este ejemplo se utiliza el operador `repeat(BooleanSupplier)` para controlar expl√≠citamente cu√°ntas veces se debe
repetir la ejecuci√≥n del `Mono`. En lugar de repetir indefinidamente, se emplea una condici√≥n basada en un contador
para limitar el n√∫mero de repeticiones.

````java
public class Lec01Repeat {
    public static void main(String[] args) {
        demo3();
    }

    private static void demo3() {
        AtomicInteger atomicInteger = new AtomicInteger(0);
        getCountryName()
                .repeat(() -> atomicInteger.incrementAndGet() < 3)
                .subscribe(Util.subscriber());
    }

    private static Mono<String> getCountryName() {
        return Mono.fromSupplier(() -> Util.faker().country().name());
    }
}
````

Explicaci√≥n:

- Se crea un `AtomicInteger` para contar las repeticiones.
- El operador `repeat(BooleanSupplier)` eval√∫a la condici√≥n cada vez que se emite un valor y el flujo se completa.
- En este caso, el `Mono` se ejecutar√° mientras el contador sea menor que 3.
- Es decir, se obtiene un pa√≠s 3 veces, y luego el flujo se completa.

> üí° Este patr√≥n es √∫til cuando se desea controlar manualmente el n√∫mero de repeticiones, por ejemplo, para implementar
> una l√≥gica de reintento limitada o simular pruebas con un n√∫mero fijo de iteraciones.

````bash
15:11:02.382 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Mali
15:11:02.385 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Angola
15:11:02.385 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Albania
15:11:02.388 INFO  [           main] d.m.a.common.DefaultSubscriber :  ¬°completado!
````

### Ejemplo 04: Repetir con retraso y control mediante repeatWhen

En este ejemplo se utiliza el operador `repeatWhen` que permite controlar de manera flexible cu√°ndo se repite un
`Mono` o `Flux` en funci√≥n de un flujo que recibe las se√±ales de repetici√≥n.

````java
public class Lec01Repeat {
    public static void main(String[] args) {
        demo4();
        Util.sleepSeconds(10);
    }

    private static void demo4() {
        getCountryName()
                .repeatWhen(flux -> flux
                        .delayElements(Duration.ofSeconds(2))   // Retrasa cada repetici√≥n 2 segundos
                        .take(2))                               // Limita a 2 repeticiones
                .subscribe(Util.subscriber());
    }

    private static Mono<String> getCountryName() {
        return Mono.fromSupplier(() -> Util.faker().country().name());
    }
}
````

Explicaci√≥n:

- `repeatWhen` recibe un Flux que indica las se√±ales de repetici√≥n.
- En este caso, esas se√±ales se retrasan 2 segundos con `delayElements(Duration.ofSeconds(2))` para espaciar las
  repeticiones.
- `take(2)` limita la cantidad de repeticiones a 2, lo que significa que el `Mono` original se ejecutar√° 3 veces en
  total (`1 inicial + 2 repeticiones`).
- Se observa que cada repetici√≥n se ejecuta en un hilo paralelo, mostrando la naturaleza as√≠ncrona del retraso.
- Finalmente, despu√©s de las repeticiones indicadas, el flujo se completa.

> üí° `repeatWhen` es especialmente √∫til para implementar patrones donde quieres repetir con condiciones temporales o
> basadas en eventos externos, controlando la cadencia y cantidad de repeticiones.

````bash
15:16:35.062 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Bahrain
15:16:37.090 INFO  [     parallel-1] d.m.a.common.DefaultSubscriber :  recibido: Canada
15:16:39.098 INFO  [     parallel-2] d.m.a.common.DefaultSubscriber :  recibido: Papua New Guinea
15:16:39.100 INFO  [     parallel-2] d.m.a.common.DefaultSubscriber :  ¬°completado!
````

## Retry

El operador `retry` se utiliza cuando se desea volver a intentar una operaci√≥n que ha fallado debido a un error. Este
operador `vuelve a suscribirse a la fuente` (`Mono` o `Flux`) despu√©s de recibir una se√±al de error (`onError`),
en lugar de terminar inmediatamente con ese error.

### Ejemplo 01 ‚Äì Retry con cantidad limitada de reintentos

En este ejemplo utilizamos el operador `retry(n)`, donde `n` representa la cantidad de veces que se intentar√° volver a
suscribir en caso de error.

El flujo comienza con una suscripci√≥n al `Mono` que simula una operaci√≥n que puede fallar (por ejemplo, una llamada
a un servicio externo). Si la operaci√≥n falla (se lanza una excepci√≥n), el operador `retry` vuelve a suscribirse
autom√°ticamente hasta alcanzar el n√∫mero de reintentos especificado.

````java
// El operador retry simplemente se vuelve a suscribir cuando ve se√±ales de error
public class Lec02Retry {

    private static final Logger log = LoggerFactory.getLogger(Lec02Retry.class);

    public static void main(String[] args) {
        demo1();
    }

    private static void demo1() {
        getCountryName()
                .retry(2)
                .subscribe(Util.subscriber());
    }

    private static Mono<String> getCountryName() {
        AtomicInteger atomicInteger = new AtomicInteger(0);
        return Mono.fromSupplier(() -> {
                    if (atomicInteger.incrementAndGet() < 3) {
                        throw new RuntimeException("Ocurri√≥ un error al buscar un pa√≠s");
                    }
                    return Util.faker().country().name();
                })
                .doOnError(throwable -> log.error("ERROR: {}", throwable.getMessage()))
                .doOnSubscribe(subscription -> log.info("suscribi√©ndose..."));

    }
}
````

En este caso espec√≠fico:

- Se utiliza un contador (`AtomicInteger`) que lanza una excepci√≥n las dos primeras veces que se invoca el `Mono`.
- Como se ha indicado `retry(2)`, el flujo se reintenta `dos veces` antes de que se considere un fallo definitivo.
- En la tercera suscripci√≥n, ya no se lanza la excepci√≥n y se obtiene el nombre de un pa√≠s de forma exitosa,
  completando el flujo.

Este operador es √∫til cuando se desea manejar errores transitorios y permitir que el flujo tenga una segunda (o tercera)
oportunidad antes de fallar definitivamente.

````bash
16:00:43.746 INFO  [           main] d.m.app.sec11.Lec02Retry       : suscribi√©ndose...
16:00:43.748 ERROR [           main] d.m.app.sec11.Lec02Retry       : ERROR: Ocurri√≥ un error al buscar un pa√≠s
16:00:43.749 INFO  [           main] d.m.app.sec11.Lec02Retry       : suscribi√©ndose...
16:00:43.749 ERROR [           main] d.m.app.sec11.Lec02Retry       : ERROR: Ocurri√≥ un error al buscar un pa√≠s
16:00:43.749 INFO  [           main] d.m.app.sec11.Lec02Retry       : suscribi√©ndose...
16:00:43.820 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Zimbabwe
16:00:43.825 INFO  [           main] d.m.a.common.DefaultSubscriber :  ¬°completado!
````

Consideraciones:

- A diferencia de `repeat`, que se activa despu√©s de una se√±al de `onComplete`, `retry` se activa solo tras una se√±al
  de `onError`.
- Si se exceden los reintentos permitidos y la fuente sigue fallando, el flujo termina con un error.

### Ejemplo 02: retryWhen(Retry.max(n)) ‚Äì Reintento con pol√≠tica expl√≠cita

En este ejemplo, usamos el operador `retryWhen` junto con `Retry.max(2)`, que indica que deseamos reintentar la
operaci√≥n como m√°ximo dos veces despu√©s de una falla.

Aunque conceptualmente este uso es muy similar a `retry(2)`, la diferencia clave est√° en la flexibilidad que ofrece
`retryWhen`, ya que permite definir pol√≠ticas de reintento m√°s complejas, como retrasos entre intentos, condiciones
basadas en el tipo de error, o estrategias de retroceso exponencial.

````java
public class Lec02Retry {

    private static final Logger log = LoggerFactory.getLogger(Lec02Retry.class);

    public static void main(String[] args) {
        demo2();
    }

    private static void demo2() {
        getCountryName()
                .retryWhen(Retry.max(2))
                .subscribe(Util.subscriber());
    }

    private static Mono<String> getCountryName() {
        AtomicInteger atomicInteger = new AtomicInteger(0);
        return Mono.fromSupplier(() -> {
                    if (atomicInteger.incrementAndGet() < 3) {
                        throw new RuntimeException("Ocurri√≥ un error al buscar un pa√≠s");
                    }
                    return Util.faker().country().name();
                })
                .doOnError(throwable -> log.error("ERROR: {}", throwable.getMessage()))
                .doOnSubscribe(subscription -> log.info("suscribi√©ndose..."));

    }
}
````

En este caso espec√≠fico:

- La operaci√≥n `getCountryName()` falla dos veces y finalmente tiene √©xito en el tercer intento.
- Como hemos usado `Retry.max(2)`, la suscripci√≥n se reintenta exactamente `2 veces`, igual que en el ejemplo
  anterior con `retry(2)`.
- La salida muestra los 3 intentos (`1 inicial + 2 reintentos`) y termina con un valor emitido y la se√±al de completado.

Este ejemplo es √∫til para demostrar que `retryWhen` con `Retry.max(n)` puede actuar igual que `retry(n)`, pero prepara
el camino para estrategias de reintento m√°s sofisticadas en escenarios reales.

````bash
16:32:41.808 INFO  [           main] d.m.app.sec11.Lec02Retry       : suscribi√©ndose...
16:32:41.810 ERROR [           main] d.m.app.sec11.Lec02Retry       : ERROR: Ocurri√≥ un error al buscar un pa√≠s
16:32:41.817 INFO  [           main] d.m.app.sec11.Lec02Retry       : suscribi√©ndose...
16:32:41.817 ERROR [           main] d.m.app.sec11.Lec02Retry       : ERROR: Ocurri√≥ un error al buscar un pa√≠s
16:32:41.817 INFO  [           main] d.m.app.sec11.Lec02Retry       : suscribi√©ndose...
16:32:41.890 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: India
16:32:41.894 INFO  [           main] d.m.a.common.DefaultSubscriber :  ¬°completado!
````

### Ejemplo 03 - Retry con fixedDelay

En este ejemplo, se utiliza el operador `retryWhen` con la estrategia `Retry.fixedDelay`, que permite reintentar una
operaci√≥n fallida con un retardo fijo entre cada intento.

`.retryWhen(Retry.fixedDelay(2, Duration.ofSeconds(3)))`, este operador reintentar√° la suscripci√≥n hasta 2 veces, con
una pausa de 3 segundos entre cada intento. En el m√©todo `getCountryName()`, se lanza una excepci√≥n controlada en
los dos primeros intentos, lo que activa la l√≥gica de reintento.

````java
public class Lec02Retry {

    private static final Logger log = LoggerFactory.getLogger(Lec02Retry.class);

    public static void main(String[] args) {
        demo3();
        Util.sleepSeconds(10);
    }

    private static void demo3() {
        getCountryName()
                .retryWhen(Retry.fixedDelay(2, Duration.ofSeconds(3)))
                .subscribe(Util.subscriber());
    }

    private static Mono<String> getCountryName() {
        AtomicInteger atomicInteger = new AtomicInteger(0);
        return Mono.fromSupplier(() -> {
                    if (atomicInteger.incrementAndGet() < 3) {
                        throw new RuntimeException("Ocurri√≥ un error al buscar un pa√≠s");
                    }
                    return Util.faker().country().name();
                })
                .doOnError(throwable -> log.error("ERROR: {}", throwable.getMessage()))
                .doOnSubscribe(subscription -> log.info("suscribi√©ndose..."));

    }
}
````

La salida del programa muestra que, luego de cada error, hay una espera de 3 segundos antes de volver a intentar.
En el tercer intento, finalmente se obtiene el resultado exitoso y se completa la suscripci√≥n.

Este tipo de estrategia es √∫til cuando se espera que una falla temporal (por ejemplo, una red ca√≠da o un servicio no
disponible) pueda resolverse en un corto periodo de tiempo.

````bash
16:40:06.603 INFO  [           main] d.m.app.sec11.Lec02Retry       : suscribi√©ndose...
16:40:06.605 ERROR [           main] d.m.app.sec11.Lec02Retry       : ERROR: Ocurri√≥ un error al buscar un pa√≠s
16:40:09.625 INFO  [     parallel-1] d.m.app.sec11.Lec02Retry       : suscribi√©ndose...
16:40:09.625 ERROR [     parallel-1] d.m.app.sec11.Lec02Retry       : ERROR: Ocurri√≥ un error al buscar un pa√≠s
16:40:12.635 INFO  [     parallel-2] d.m.app.sec11.Lec02Retry       : suscribi√©ndose...
16:40:12.701 INFO  [     parallel-2] d.m.a.common.DefaultSubscriber :  recibido: Brazil
16:40:12.706 INFO  [     parallel-2] d.m.a.common.DefaultSubscriber :  ¬°completado!
````

### Ejemplo 04: Retry con retardo fijo y acci√≥n previa al reintento (doBeforeRetry)

Este ejemplo demuestra el uso del operador `retryWhen` con una estrategia de reintento basada en retardo
fijo (`fixedDelay`) y adem√°s, a√±ade una acci√≥n personalizada que se ejecuta antes de cada reintento, utilizando el
m√©todo `doBeforeRetry`.

````java
public class Lec02Retry {

    private static final Logger log = LoggerFactory.getLogger(Lec02Retry.class);

    public static void main(String[] args) {
        demo4();
        Util.sleepSeconds(10);
    }

    private static void demo4() {
        getCountryName()
                .retryWhen(Retry.fixedDelay(2, Duration.ofSeconds(3))
                        .doBeforeRetry(retrySignal -> log.info("Reintentando...")))
                .subscribe(Util.subscriber());
    }

    private static Mono<String> getCountryName() {
        AtomicInteger atomicInteger = new AtomicInteger(0);
        return Mono.fromSupplier(() -> {
                    if (atomicInteger.incrementAndGet() < 3) {
                        throw new RuntimeException("Ocurri√≥ un error al buscar un pa√≠s");
                    }
                    return Util.faker().country().name();
                })
                .doOnError(throwable -> log.error("ERROR: {}", throwable.getMessage()))
                .doOnSubscribe(subscription -> log.info("suscribi√©ndose..."));
    }
}
````

En este caso:

- Se intenta obtener un nombre de pa√≠s desde un `Mono`, pero las dos primeras ejecuciones lanzan un error
  intencionalmente.
- El `retryWhen(Retry.fixedDelay(2, Duration.ofSeconds(3)))` indica que se realizar√°n hasta 2 reintentos, con un retardo
  de 3 segundos entre cada uno.
- Gracias a `doBeforeRetry`, se imprime un mensaje `Reintentando...` antes de cada intento de repetici√≥n.
- Finalmente, en el tercer intento exitoso, se emite el pa√≠s y la secuencia se completa.

Este patr√≥n es √∫til cuando deseas agregar l√≥gica personalizada para monitorear o registrar informaci√≥n en cada
reintento, sin afectar el flujo principal del pipeline.

````bash
16:42:36.814 INFO  [           main] d.m.app.sec11.Lec02Retry       : suscribi√©ndose...
16:42:36.816 ERROR [           main] d.m.app.sec11.Lec02Retry       : ERROR: Ocurri√≥ un error al buscar un pa√≠s
16:42:36.831 INFO  [           main] d.m.app.sec11.Lec02Retry       : Reintentando...
16:42:39.849 INFO  [     parallel-1] d.m.app.sec11.Lec02Retry       : suscribi√©ndose...
16:42:39.850 ERROR [     parallel-1] d.m.app.sec11.Lec02Retry       : ERROR: Ocurri√≥ un error al buscar un pa√≠s
16:42:39.850 INFO  [     parallel-1] d.m.app.sec11.Lec02Retry       : Reintentando...
16:42:42.856 INFO  [     parallel-2] d.m.app.sec11.Lec02Retry       : suscribi√©ndose...
16:42:42.921 INFO  [     parallel-2] d.m.a.common.DefaultSubscriber :  recibido: Angola
16:42:42.924 INFO  [     parallel-2] d.m.a.common.DefaultSubscriber :  ¬°completado!
````

### Ejemplo 05: Retry con filtro por tipo de excepci√≥n (filter)

En este ejemplo se utiliza el operador `retryWhen` con la estrategia `fixedDelay`, y adem√°s se aplica un filtro
de errores mediante `.filter(...)` para que solo se reintente si el error es de tipo `RuntimeException`.

Esto permite manejar de forma m√°s precisa los errores que son `reintentables`, y evitar reintentos innecesarios si
ocurre una excepci√≥n que no se debe volver a intentar.

````java
public class Lec02Retry {

    private static final Logger log = LoggerFactory.getLogger(Lec02Retry.class);

    public static void main(String[] args) {
        demo5();
        Util.sleepSeconds(10);
    }

    private static void demo5() {
        getCountryName()
                .retryWhen(Retry.fixedDelay(2, Duration.ofSeconds(3))
                        .filter(throwable -> RuntimeException.class.equals(throwable.getClass())))
                .subscribe(Util.subscriber());
    }

    private static Mono<String> getCountryName() {
        AtomicInteger atomicInteger = new AtomicInteger(0);
        return Mono.fromSupplier(() -> {
                    if (atomicInteger.incrementAndGet() < 3) {
                        throw new RuntimeException("Ocurri√≥ un error al buscar un pa√≠s");
                    }
                    return Util.faker().country().name();
                })
                .doOnError(throwable -> log.error("ERROR: {}", throwable.getMessage()))
                .doOnSubscribe(subscription -> log.info("suscribi√©ndose..."));

    }
}
````

Detalles importantes:

- `retryWhen(Retry.fixedDelay(2, Duration.ofSeconds(3))...)`: permite reintentar hasta 2 veces con un retardo fijo de 3
  segundos.
- `.filter(throwable -> RuntimeException.class.equals(throwable.getClass()))`: define una condici√≥n para que solo los
  errores de tipo `RuntimeException` sean considerados para reintento.
- Si ocurriera otro tipo de excepci√≥n (como `IOException`, `NullPointerException`, etc.) no se reintentar√≠a y el `Mono`
  terminar√≠a con error.

Este patr√≥n es muy √∫til en casos reales cuando algunos errores son recuperables (como problemas de red transitorios), y
otros no (como errores de l√≥gica de negocio).

````bash
16:45:54.606 INFO  [           main] d.m.app.sec11.Lec02Retry       : suscribi√©ndose...
16:45:54.608 ERROR [           main] d.m.app.sec11.Lec02Retry       : ERROR: Ocurri√≥ un error al buscar un pa√≠s
16:45:57.637 INFO  [     parallel-1] d.m.app.sec11.Lec02Retry       : suscribi√©ndose...
16:45:57.638 ERROR [     parallel-1] d.m.app.sec11.Lec02Retry       : ERROR: Ocurri√≥ un error al buscar un pa√≠s
16:46:00.639 INFO  [     parallel-2] d.m.app.sec11.Lec02Retry       : suscribi√©ndose...
16:46:00.721 INFO  [     parallel-2] d.m.a.common.DefaultSubscriber :  recibido: Zimbabwe
16:46:00.725 INFO  [     parallel-2] d.m.a.common.DefaultSubscriber :  ¬°completado!
````
