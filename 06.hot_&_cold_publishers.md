# Secci√≥n 6: Cold & Hot Publishers

---

## Introducci√≥n

En programaci√≥n reactiva (y particularmente en `Project Reactor`), los t√©rminos `Cold Publisher` y `Hot Publisher`
hacen referencia a c√≥mo se manejan las emisiones de datos y c√≥mo los suscriptores reciben esos datos de los publishers.
Entender la diferencia entre ellos es fundamental para manejar correctamente el comportamiento de los flujos de datos.

Hasta ahora, hemos considerado que todos los `Flux` (y `Mono`) son iguales: *representan una secuencia as√≠ncrona de
datos y no ocurre nada antes de la suscripci√≥n.*

Sin embargo, existen dos grandes familias de publicadores: `Cold Publisher` y `Hot Publisher`.

La descripci√≥n anterior se aplica a los `Cold Publisher`. Generan datos de nuevo para cada suscripci√≥n. Si no se crea
ninguna suscripci√≥n, los datos nunca se generan.

![01.png](assets/section-06/01.png)

Los `Hot Publisher`, por otro lado, no dependen de ning√∫n n√∫mero de suscriptores. Podr√≠an empezar a publicar
datos de inmediato y continuar√≠an haci√©ndolo cada vez que llega un nuevo suscriptor (en cuyo caso, el suscriptor solo
ver√≠a los nuevos elementos emitidos despu√©s de suscribirse).

![02.png](assets/section-06/02.png)

## Cold Publisher (Publicador fr√≠o)

Un `Cold Publisher` es un flujo de datos que `emite elementos desde el principio cada vez que un suscriptor
se conecta.` Los `cold publishers` producen datos `bajo demanda`, es decir, el flujo comienza a emitir sus elementos
solo cuando hay un suscriptor y `cada suscriptor recibe los datos desde el inicio`.

![03.png](assets/section-06/03.png)

### Caracter√≠sticas de los Cold Publishers

- Cada nuevo suscriptor ver√° las emisiones desde el principio, sin importar cu√°ndo se conecte.
- Los datos suelen ser generados bajo demanda para cada suscriptor.
- `Ejemplo`: Flujos de datos que se generan a partir de bases de datos, archivos, o c√°lculos, donde cada suscriptor
  necesita ver todos los datos desde el inicio.

````java
public class Lec00ColdHot {
    private static final Logger log = LoggerFactory.getLogger(Lec00ColdHot.class);

    public static void main(String[] args) {
        coldPublisher();
    }

    private static void coldPublisher() {
        Flux<Integer> coldFlux = Flux.range(1, 3);
        coldFlux.subscribe(Util.subscriber("sub1"));
        coldFlux.subscribe(Util.subscriber("sub2"));
    }
}
````

En este caso, cada suscriptor recibe los n√∫meros del 1 al 3 desde el inicio, independientemente del momento en el
que se suscriba.

````bash
11:04:53.515 INFO  [           main] d.m.a.common.DefaultSubscriber : sub1 recibido: 1
11:04:53.517 INFO  [           main] d.m.a.common.DefaultSubscriber : sub1 recibido: 2
11:04:53.517 INFO  [           main] d.m.a.common.DefaultSubscriber : sub1 recibido: 3
11:04:53.520 INFO  [           main] d.m.a.common.DefaultSubscriber : sub1 ¬°completado!
11:04:53.520 INFO  [           main] d.m.a.common.DefaultSubscriber : sub2 recibido: 1
11:04:53.521 INFO  [           main] d.m.a.common.DefaultSubscriber : sub2 recibido: 2
11:04:53.521 INFO  [           main] d.m.a.common.DefaultSubscriber : sub2 recibido: 3
11:04:53.521 INFO  [           main] d.m.a.common.DefaultSubscriber : sub2 ¬°completado!
````

Ejemplos del mundo real:

- Llamadas a bases de datos.
- Lectura de archivos.
- Fetch de APIs, donde cada suscriptor obtiene una nueva llamada y datos frescos.

## Hot Publisher (Publicador caliente)

Un `Hot Publisher` emite datos a medida que ocurren, y cada suscriptor recibe los datos solo desde el momento en que
se suscribe. Dependiendo de su configuraci√≥n (como `connect`, `autoConnect`, o `refCount`), puede comenzar la emisi√≥n
autom√°ticamente o requerir al menos un suscriptor.

Si un suscriptor se conecta a un hot publisher `tarde`, recibir√° solo los datos que se emiten `despu√©s` de su
suscripci√≥n. Esto significa que cualquier dato emitido antes de la suscripci√≥n no ser√° recibido por el nuevo suscriptor.

![04.png](assets/section-06/04.png)

### Caracter√≠sticas de los Hot Publishers

- Los datos fluyen independientemente de los suscriptores.
- Los suscriptores que se conecten tarde se perder√°n los elementos ya emitidos.
- Son √∫tiles para eventos que no dependen del suscriptor, como transmisiones en vivo.
- `Ejemplo`: Sensores de temperatura, transmisi√≥n de datos en tiempo real.

### üî• Hot Publisher que inicia la emisi√≥n al tener al menos un suscriptor (.share() / refCount(1))

En este caso, el `Hot Publisher` comienza a emitir datos solamente cuando se suscribe al menos un consumidor. Este
comportamiento se logra utilizando `.share()`, que internamente equivale a `.publish().refCount(1)`.

Si en alg√∫n momento todos los suscriptores se cancelan, el flujo de datos se detiene autom√°ticamente.
Cada nuevo suscriptor recibe solo los datos emitidos a partir del momento de su suscripci√≥n, sin acceso a eventos
anteriores.

````java
public class Lec00ColdHot {
    private static final Logger log = LoggerFactory.getLogger(Lec00ColdHot.class);

    public static void main(String[] args) {
        hotPublisher();
    }

    private static void hotPublisher() {
        Flux<Long> hotFlux = Flux.interval(Duration.ofSeconds(1))
                .share(); // Convierte este Cold Publisher en Hot Publisher

        hotFlux.subscribe(Util.subscriber("sub1"));
        Util.sleepSeconds(2); // Esperamos 2 segundos antes de a√±adir el segundo suscriptor

        hotFlux.subscribe(Util.subscriber("sub2"));
        Util.sleepSeconds(4);
    }
}
````

La llamada a `.share()` es un atajo para `.publish().refCount(1)`, lo cual significa:

- El flujo `comienza a emitir` cuando `hay al menos un suscriptor`.
- Si todos los `suscriptores se cancelan`, el `flujo se detiene`.
- Los nuevos suscriptores solo reciben los elementos emitidos desde el momento de su suscripci√≥n.

En este caso:

- El `sub1` comienza a recibir datos de inmediato.
- El `sub2` se conecta 2 segundos despu√©s, por lo que no ver√° los primeros 2 valores emitidos y comenzar√° a
  recibir datos desde el tercer valor.

````bash
11:12:10.409 INFO  [     parallel-1] d.m.a.common.DefaultSubscriber : sub1 recibido: 0
11:12:11.406 INFO  [     parallel-1] d.m.a.common.DefaultSubscriber : sub1 recibido: 1
11:12:12.415 INFO  [     parallel-1] d.m.a.common.DefaultSubscriber : sub1 recibido: 2
11:12:12.415 INFO  [     parallel-1] d.m.a.common.DefaultSubscriber : sub2 recibido: 2
11:12:13.409 INFO  [     parallel-1] d.m.a.common.DefaultSubscriber : sub1 recibido: 3
11:12:13.409 INFO  [     parallel-1] d.m.a.common.DefaultSubscriber : sub2 recibido: 3
11:12:14.420 INFO  [     parallel-1] d.m.a.common.DefaultSubscriber : sub1 recibido: 4
11:12:14.420 INFO  [     parallel-1] d.m.a.common.DefaultSubscriber : sub2 recibido: 4
11:12:15.410 INFO  [     parallel-1] d.m.a.common.DefaultSubscriber : sub1 recibido: 5
11:12:15.410 INFO  [     parallel-1] d.m.a.common.DefaultSubscriber : sub2 recibido: 5
````

Ejemplos del mundo real:

- `Sensores`: Un sensor que mide la temperatura sigue emitiendo datos, y cualquier suscriptor que se conecte despu√©s
  solo ver√° los datos a partir de su conexi√≥n.
- `Eventos en tiempo real`: Streams de redes sociales, precios de acciones en bolsa, etc., donde los suscriptores que
  se unan tarde no ven eventos pasados, solo eventos futuros.

### üî• Hot Publisher que emite sin necesidad de suscriptores

Un `Hot Publisher` basado en `ConnectableFlux` con `.connect()` comienza a emitir datos inmediatamente despu√©s de
invocar `connect()`, sin necesidad de que haya suscriptores activos.

Esto significa que los elementos emitidos pueden perderse si no hay nadie suscrito en ese momento, ya que el flujo
avanza continuamente y no guarda historial.

‚úÖ Caracter√≠sticas clave:

- La emisi√≥n no espera suscriptores.
- Si un suscriptor se une tarde, no recibe los datos anteriores.
- La fuente se activa expl√≠citamente con `.connect()`, lo que hace que el `Flux` comience a empujar datos aunque nadie
  est√© escuchando.
- La emisi√≥n del flujo se cancela solo en ciertas condiciones espec√≠ficas, ya que este tipo de flujo:
    1. No depende de los suscriptores para comenzar.
    2. Sigue emitiendo hasta que ocurra uno de estos casos:
        - Cuando el `Publisher` fuente se completa o falla.
        - Cuando se llama manualmente a `dispose()` sobre la `Disposable` que devuelve `connect()`.
        - Cuando se cancela el `Subscription` internamente por el operador.

> üìå `Importante`: si nadie llama a `dispose()` y el flujo es infinito, seguir√° emitiendo datos indefinidamente,
> incluso si no hay suscriptores.

Veamos el siguiente ejemplo t√≠pico.

````java
public class Lec00ColdHot {
    private static final Logger log = LoggerFactory.getLogger(Lec00ColdHot.class);

    public static void main(String[] args) {
        hotPublisher2();
    }

    private static void hotPublisher2() {
        ConnectableFlux<Long> hot = Flux.interval(Duration.ofSeconds(1)).publish();
        hot.connect(); // Inicia la emisi√≥n, incluso sin suscriptores

        Util.sleepSeconds(3);

        hot.subscribe(Util.subscriber("sub1")); // Sub1 se une tarde

        Util.sleepSeconds(6);
    }
}
````

Este ejemplo demuestra que un `Hot Publisher` creado con `publish()` y activado mediante `connect()` comienza a emitir
inmediatamente, incluso si no hay suscriptores presentes en ese momento.

Cuando el suscriptor (`sub1`) se conecta despu√©s de `3 segundos`, no recibe los primeros elementos (0, 1, 2), sino que
empieza a recibir desde el elemento 3 en adelante, justo desde que se suscribi√≥.

Esto confirma que:

- La emisi√≥n no depende de tener suscriptores activos.
- Los elementos anteriores a la suscripci√≥n se pierden.
- La fuente (`Flux.interval`) es infinita y seguir√° emitiendo hasta que se cancele manualmente o se apague el programa.

````bash
11:54:09.365 INFO  [     parallel-1] d.m.a.common.DefaultSubscriber : sub1 recibido: 3
11:54:10.352 INFO  [     parallel-1] d.m.a.common.DefaultSubscriber : sub1 recibido: 4
11:54:11.359 INFO  [     parallel-1] d.m.a.common.DefaultSubscriber : sub1 recibido: 5
11:54:12.351 INFO  [     parallel-1] d.m.a.common.DefaultSubscriber : sub1 recibido: 6
11:54:13.360 INFO  [     parallel-1] d.m.a.common.DefaultSubscriber : sub1 recibido: 7
11:54:14.351 INFO  [     parallel-1] d.m.a.common.DefaultSubscriber : sub1 recibido: 8
````

## Hot Publisher - share()

Anteriormente, vimos que el m√©todo `.share()` nos permite convertir un `Cold Publisher` en un `Hot Publisher`.
Este tipo de `Hot Publisher` tiene las siguientes caracter√≠sticas clave:

- Empieza a emitir valores solo cuando al menos un suscriptor se ha conectado.
- Si todos los suscriptores se cancelan, el flujo se detiene autom√°ticamente.
- Cuando un nuevo suscriptor se une, recibe √∫nicamente los elementos emitidos desde ese momento en adelante, sin acceso
  a los eventos anteriores.

Veamos un ejemplo pr√°ctico que ilustra este comportamiento:

````java
public class Lec02HotSharePublisher {
    private static final Logger log = LoggerFactory.getLogger(Lec02HotSharePublisher.class);

    public static void main(String[] args) {
        Flux<String> movieFlux = movieStream()
                .share(); // Convierte este Cold Publisher en Hot Publisher

        Util.sleepSeconds(2);
        movieFlux.subscribe(Util.subscriber("mar")); // Se suscribe "mar" antes

        Util.sleepSeconds(3);
        movieFlux
                .take(3) // "gab" solo observar√° 3 escenas
                .subscribe(Util.subscriber("gab")); // Se une tarde

        Util.sleepSeconds(13);
    }

    private static Flux<String> movieStream() {
        return Flux.generate(
                        () -> {
                            log.info("Request recibido");
                            return 1;
                        }, (stateValue, synchronousSink) -> {
                            String scene = "escena de pel√≠cula %d".formatted(stateValue);
                            log.info("Ejecutando {}", stateValue);
                            synchronousSink.next(scene);
                            return ++stateValue;
                        }, stateValue -> log.info("Valor final del estado: {}", stateValue)
                )
                .take(10)
                .delayElements(Duration.ofSeconds(1))
                .cast(String.class);
    }
}
````

üß† ¬øQu√© observamos en la ejecuci√≥n?

- A las `13:11:03`, el primer suscriptor `mar` empieza a recibir las escenas desde el inicio.
- A las `13:11:05`, el segundo suscriptor `gab` se une y solo empieza a recibir desde la escena 3 en adelante.
- `gab` se detiene luego de `3 elementos` (escena 3, 4, 5), cumpliendo la l√≥gica del `.take(3)`.
- `mar` contin√∫a recibiendo hasta el final de las `10 escenas` emitidas por el flujo.
- El flujo se detiene autom√°ticamente al completar la emisi√≥n de los 10 elementos definidos por `.take(10)` en el
  `movieStream()`.

````bash
13:11:02.851 INFO  [           main] d.m.a.s.Lec02HotSharePublisher : Request recibido
13:11:02.869 INFO  [           main] d.m.a.s.Lec02HotSharePublisher : Ejecutando 1
13:11:03.890 INFO  [     parallel-1] d.m.a.common.DefaultSubscriber : mar recibido: escena de pel√≠cula 1
13:11:03.890 INFO  [     parallel-1] d.m.a.s.Lec02HotSharePublisher : Ejecutando 2
13:11:04.897 INFO  [     parallel-2] d.m.a.common.DefaultSubscriber : mar recibido: escena de pel√≠cula 2
13:11:04.897 INFO  [     parallel-2] d.m.a.s.Lec02HotSharePublisher : Ejecutando 3
13:11:05.904 INFO  [     parallel-3] d.m.a.common.DefaultSubscriber : mar recibido: escena de pel√≠cula 3
13:11:05.904 INFO  [     parallel-3] d.m.a.common.DefaultSubscriber : gab recibido: escena de pel√≠cula 3
13:11:05.904 INFO  [     parallel-3] d.m.a.s.Lec02HotSharePublisher : Ejecutando 4
13:11:06.911 INFO  [     parallel-4] d.m.a.common.DefaultSubscriber : mar recibido: escena de pel√≠cula 4
13:11:06.911 INFO  [     parallel-4] d.m.a.common.DefaultSubscriber : gab recibido: escena de pel√≠cula 4
13:11:06.911 INFO  [     parallel-4] d.m.a.s.Lec02HotSharePublisher : Ejecutando 5
13:11:07.925 INFO  [     parallel-5] d.m.a.common.DefaultSubscriber : mar recibido: escena de pel√≠cula 5
13:11:07.926 INFO  [     parallel-5] d.m.a.common.DefaultSubscriber : gab recibido: escena de pel√≠cula 5
13:11:07.938 INFO  [     parallel-5] d.m.a.common.DefaultSubscriber : gab ¬°completado!
13:11:07.938 INFO  [     parallel-5] d.m.a.s.Lec02HotSharePublisher : Ejecutando 6
13:11:08.940 INFO  [     parallel-6] d.m.a.common.DefaultSubscriber : mar recibido: escena de pel√≠cula 6
13:11:08.940 INFO  [     parallel-6] d.m.a.s.Lec02HotSharePublisher : Ejecutando 7
13:11:09.948 INFO  [     parallel-7] d.m.a.common.DefaultSubscriber : mar recibido: escena de pel√≠cula 7
13:11:09.949 INFO  [     parallel-7] d.m.a.s.Lec02HotSharePublisher : Ejecutando 8
13:11:10.964 INFO  [     parallel-8] d.m.a.common.DefaultSubscriber : mar recibido: escena de pel√≠cula 8
13:11:10.964 INFO  [     parallel-8] d.m.a.s.Lec02HotSharePublisher : Ejecutando 9
13:11:11.978 INFO  [     parallel-1] d.m.a.common.DefaultSubscriber : mar recibido: escena de pel√≠cula 9
13:11:11.978 INFO  [     parallel-1] d.m.a.s.Lec02HotSharePublisher : Ejecutando 10
13:11:11.978 INFO  [     parallel-1] d.m.a.s.Lec02HotSharePublisher : Valor final del estado: 11
13:11:12.987 INFO  [     parallel-2] d.m.a.common.DefaultSubscriber : mar recibido: escena de pel√≠cula 10
13:11:12.988 INFO  [     parallel-2] d.m.a.common.DefaultSubscriber : mar ¬°completado!
````

‚úÖ Conclusi√≥n

- `.share()` permite que m√∫ltiples suscriptores compartan un mismo flujo de datos.
- Cada nuevo suscriptor solo ver√° lo que ocurra desde el momento en que se suscribi√≥.
- El flujo se inicia con el primer suscriptor y se detiene cuando todos se cancelan o el flujo se completa.

## Hot Publisher - refCount()

Recordemos que en el apartado anterior vimos el operador `share()`, el cual devuelve un nuevo `Flux` que transmite en
forma m√∫ltiple (es decir, comparte el flujo original con varios suscriptores).

Mientras haya al menos un suscriptor activo, este `Flux` permanecer√° conectado y continuar√° emitiendo datos. Cuando
todos los suscriptores se hayan cancelado, el `Flux` de origen ser√° cancelado tambi√©n.

`share()` es un alias de `publish().refCount()` o `publish().refCount(1)`. Por defecto, necesita `al menos 1 suscriptor`
para comenzar a emitir datos. Por eso, en nuestro ejemplo anterior, el flujo esper√≥ a que hubiera
`al menos 1 suscriptor` (`mar`) para comenzar a emitir.

Tambi√©n podemos modificar ese valor por defecto. Por ejemplo, podemos indicar que deben haber al menos `2 suscriptores`
para que el flujo comience a emitir datos. Luego, bastar√° con que haya al menos 1 suscriptor para que contin√∫e
emitiendo.

En el siguiente ejemplo, reemplazamos el alias `share()` por su equivalente `.publish().refCount(2)`. Esto indica que
el flujo solo comenzar√° a emitir cuando haya al menos `2 suscriptores activos`.

````java
public class Lec03HotRefCountPublisher {
    private static final Logger log = LoggerFactory.getLogger(Lec03HotRefCountPublisher.class);

    public static void main(String[] args) {
        Flux<String> movieFlux = movieStream()
                .publish().refCount(2); // share(), es su alias

        Util.sleepSeconds(2);
        movieFlux.subscribe(Util.subscriber("mar"));

        Util.sleepSeconds(3);
        movieFlux
                .take(3)
                .subscribe(Util.subscriber("gab"));

        Util.sleepSeconds(13);
    }

    private static Flux<String> movieStream() {
        return Flux.generate(
                        () -> {
                            log.info("Request recibido");
                            return 1;
                        }, (stateValue, synchronousSink) -> {
                            String scene = "escena de pel√≠cula %d".formatted(stateValue);
                            log.info("Ejecutando {}", stateValue);
                            synchronousSink.next(scene);
                            return ++stateValue;
                        }, stateValue -> log.info("Valor final del estado: {}", stateValue)
                )
                .take(10)
                .delayElements(Duration.ofSeconds(1))
                .cast(String.class);
    }
}
````

En el c√≥digo anterior hicimos lo siguiente:

1. Configuramos el `refCount(2)` correctamente: eso exige `2 suscriptores` para `activar el flujo`.
2. Sincronizamos los `subscribe()` con `sleep()s`: el primer `suscriptor (mar)` entra solo, y 3 segundos despu√©s entra
   `gab`, activando el flujo justo cuando hay `2`.
3. Usamos `take(3)` para `gab`: esto demuestra c√≥mo un suscriptor puede recibir solo una parte del flujo.
4. El `movieStream()` est√° limpio, con `generate + delayElements()`: es una buena forma de simular una fuente de datos
   que genera escenas con un intervalo de tiempo.

````bash
15:26:42.115 INFO  [           main] .a.s.Lec03HotRefCountPublisher : Request recibido
15:26:42.129 INFO  [           main] .a.s.Lec03HotRefCountPublisher : Ejecutando 1
15:26:43.140 INFO  [     parallel-1] d.m.a.common.DefaultSubscriber : mar recibido: escena de pel√≠cula 1
15:26:43.141 INFO  [     parallel-1] d.m.a.common.DefaultSubscriber : gab recibido: escena de pel√≠cula 1
15:26:43.141 INFO  [     parallel-1] .a.s.Lec03HotRefCountPublisher : Ejecutando 2
15:26:44.148 INFO  [     parallel-2] d.m.a.common.DefaultSubscriber : mar recibido: escena de pel√≠cula 2
15:26:44.149 INFO  [     parallel-2] d.m.a.common.DefaultSubscriber : gab recibido: escena de pel√≠cula 2
15:26:44.149 INFO  [     parallel-2] .a.s.Lec03HotRefCountPublisher : Ejecutando 3
15:26:45.163 INFO  [     parallel-3] d.m.a.common.DefaultSubscriber : mar recibido: escena de pel√≠cula 3
15:26:45.164 INFO  [     parallel-3] d.m.a.common.DefaultSubscriber : gab recibido: escena de pel√≠cula 3
15:26:45.168 INFO  [     parallel-3] d.m.a.common.DefaultSubscriber : gab ¬°completado!
15:26:45.168 INFO  [     parallel-3] .a.s.Lec03HotRefCountPublisher : Ejecutando 4
15:26:46.175 INFO  [     parallel-4] d.m.a.common.DefaultSubscriber : mar recibido: escena de pel√≠cula 4
15:26:46.176 INFO  [     parallel-4] .a.s.Lec03HotRefCountPublisher : Ejecutando 5
15:26:47.183 INFO  [     parallel-5] d.m.a.common.DefaultSubscriber : mar recibido: escena de pel√≠cula 5
15:26:47.184 INFO  [     parallel-5] .a.s.Lec03HotRefCountPublisher : Ejecutando 6
15:26:48.194 INFO  [     parallel-6] d.m.a.common.DefaultSubscriber : mar recibido: escena de pel√≠cula 6
15:26:48.194 INFO  [     parallel-6] .a.s.Lec03HotRefCountPublisher : Ejecutando 7
15:26:49.199 INFO  [     parallel-7] d.m.a.common.DefaultSubscriber : mar recibido: escena de pel√≠cula 7
15:26:49.200 INFO  [     parallel-7] .a.s.Lec03HotRefCountPublisher : Ejecutando 8
15:26:50.244 INFO  [     parallel-8] d.m.a.common.DefaultSubscriber : mar recibido: escena de pel√≠cula 8
15:26:50.246 INFO  [     parallel-8] .a.s.Lec03HotRefCountPublisher : Ejecutando 9
15:26:51.246 INFO  [     parallel-1] d.m.a.common.DefaultSubscriber : mar recibido: escena de pel√≠cula 9
15:26:51.246 INFO  [     parallel-1] .a.s.Lec03HotRefCountPublisher : Ejecutando 10
15:26:51.246 INFO  [     parallel-1] .a.s.Lec03HotRefCountPublisher : Valor final del estado: 11
15:26:52.257 INFO  [     parallel-2] d.m.a.common.DefaultSubscriber : mar recibido: escena de pel√≠cula 10
15:26:52.257 INFO  [     parallel-2] d.m.a.common.DefaultSubscriber : mar ¬°completado!
````

En el resultado observamos lo siguiente:

- El mensaje `Request recibido` aparece cuando ya est√°n los dos suscriptores activos.
- Ambos (`mar` y `gab`) reciben las escenas 1, 2 y 3.
- Luego `gab` se desconecta (por el `.take(3)`).
- `mar` contin√∫a recibiendo el resto (hasta la escena 10), porque al menos queda un suscriptor.

## Hot Publisher - autoConnect()

### Hot Publisher con autoConnect(1) ‚Äì Comienza a emitir con el primer suscriptor

`autoConnect()` conecta el `ConnectableFlux` a su fuente tan pronto como se alcanza un n√∫mero espec√≠fico de
suscriptores. Por defecto, con `autoConnect()` sin argumentos, la conexi√≥n ocurre cuando se suscribe el
`primer subscriber`.

Este operador es similar a `publish().refCount(1)`, pero con una diferencia importante:

- Una vez que se conecta a la fuente, `no se desconecta aunque todos los suscriptores se hayan cancelado`.
- Es decir, la fuente comenzar√° a emitir datos tan pronto como se alcance el n√∫mero m√≠nimo de suscriptores definido
  (por defecto, `1`), y `continuar√° emitiendo incluso si ya no hay suscriptores activos`.

En el siguiente ejemplo, emitiremos 10 elementos desde un Flux. Apenas se suscriba el primer observador, la emisi√≥n
comenzar√°. Incluso si despu√©s se cancelan suscripciones o no hay nuevos observadores, la emisi√≥n continuar√°.

````java
public class Lec04HotAutoConnectPublisher {
    private static final Logger log = LoggerFactory.getLogger(Lec04HotAutoConnectPublisher.class);

    public static void main(String[] args) {
        Flux<String> movieFlux = movieStream()
                .publish().autoConnect(); // Casi igual que publish().refCount(1). NO se detiene cuando los suscriptores cancelan. Por lo tanto, comenzar√° a producir incluso para 0 suscriptores una vez iniciado.

        Util.sleepSeconds(2);
        movieFlux
                .take(4)
                .subscribe(Util.subscriber("mar"));

        Util.sleepSeconds(3);
        movieFlux
                .take(3)
                .subscribe(Util.subscriber("gab"));

        Util.sleepSeconds(13);
    }

    private static Flux<String> movieStream() {
        return Flux.generate(
                        () -> {
                            log.info("Request recibido");
                            return 1;
                        }, (stateValue, synchronousSink) -> {
                            String scene = "escena de pel√≠cula %d".formatted(stateValue);
                            log.info("Ejecutando {}", stateValue);
                            synchronousSink.next(scene);
                            return ++stateValue;
                        }, stateValue -> log.info("Valor final del estado: {}", stateValue)
                )
                .take(10)
                .delayElements(Duration.ofSeconds(1))
                .cast(String.class);
    }
}
````

En este ejemplo, el `Flux` comienza a emitir elementos tan pronto como el primer suscriptor (`mar`) se conecta,
debido a que usamos `publish().autoConnect()`.

````bash
15:57:03.922 INFO  [           main] s.Lec04HotAutoConnectPublisher : Request recibido
15:57:03.939 INFO  [           main] s.Lec04HotAutoConnectPublisher : Ejecutando 1
15:57:04.956 INFO  [     parallel-1] d.m.a.common.DefaultSubscriber : mar recibido: escena de pel√≠cula 1
15:57:04.956 INFO  [     parallel-1] s.Lec04HotAutoConnectPublisher : Ejecutando 2
15:57:05.966 INFO  [     parallel-2] d.m.a.common.DefaultSubscriber : mar recibido: escena de pel√≠cula 2
15:57:05.967 INFO  [     parallel-2] s.Lec04HotAutoConnectPublisher : Ejecutando 3
15:57:06.980 INFO  [     parallel-3] d.m.a.common.DefaultSubscriber : mar recibido: escena de pel√≠cula 3
15:57:06.980 INFO  [     parallel-3] d.m.a.common.DefaultSubscriber : gab recibido: escena de pel√≠cula 3
15:57:06.980 INFO  [     parallel-3] s.Lec04HotAutoConnectPublisher : Ejecutando 4
15:57:07.990 INFO  [     parallel-4] d.m.a.common.DefaultSubscriber : mar recibido: escena de pel√≠cula 4
15:57:07.992 INFO  [     parallel-4] d.m.a.common.DefaultSubscriber : mar ¬°completado!
15:57:07.992 INFO  [     parallel-4] d.m.a.common.DefaultSubscriber : gab recibido: escena de pel√≠cula 4
15:57:07.992 INFO  [     parallel-4] s.Lec04HotAutoConnectPublisher : Ejecutando 5
15:57:09.007 INFO  [     parallel-5] d.m.a.common.DefaultSubscriber : gab recibido: escena de pel√≠cula 5
15:57:09.008 INFO  [     parallel-5] d.m.a.common.DefaultSubscriber : gab ¬°completado!
15:57:09.008 INFO  [     parallel-5] s.Lec04HotAutoConnectPublisher : Ejecutando 6
15:57:10.017 INFO  [     parallel-6] s.Lec04HotAutoConnectPublisher : Ejecutando 7
15:57:11.020 INFO  [     parallel-7] s.Lec04HotAutoConnectPublisher : Ejecutando 8
15:57:12.029 INFO  [     parallel-8] s.Lec04HotAutoConnectPublisher : Ejecutando 9
15:57:13.035 INFO  [     parallel-1] s.Lec04HotAutoConnectPublisher : Ejecutando 10
15:57:13.035 INFO  [     parallel-1] s.Lec04HotAutoConnectPublisher : Valor final del estado: 11
````

A continuaci√≥n, explicamos paso a paso lo que ocurre:

1. Inicio de la emisi√≥n:
    - A los 2 segundos del inicio del programa, se suscribe `mar`.
    - Esto activa la conexi√≥n al `Flux` y se imprime el log: `Request recibido` y `Ejecutando 1`.

2. Emisi√≥n continua:
    - Cada segundo se emite una nueva "escena de pel√≠cula".
    - `mar` recibe las escenas 1 a 4. Luego, como hicimos `.take(4)`, su suscripci√≥n se completa: `mar ¬°completado!`.

3. Suscripci√≥n tard√≠a:
    - `gab` se suscribe 3 segundos despu√©s de `mar`, cuando ya se estaban emitiendo las escenas.
    - Como la fuente sigue activa, `gab` recibe a partir de la escena 3 (que estaba en emisi√≥n justo al momento de su
      suscripci√≥n) hasta la escena 5.
    - Luego, como hicimos `.take(3)`, su suscripci√≥n tambi√©n finaliza: `gab ¬°completado!`.

4. Emisi√≥n sin suscriptores:
    - A pesar de que ya no hay suscriptores activos, el `Flux` contin√∫a ejecutando las escenas 6 a 10.
    - Esto confirma que `autoConnect()` no detiene la emisi√≥n aunque no haya observadores conectados.

### Hot Publisher con autoConnect(0) ‚Äì Comienza a emitir sin necesidad de suscriptores

Cuando se usa `autoConnect(0)`, el `ConnectableFlux` comenzar√° a emitir elementos inmediatamente, sin esperar a que haya
ning√∫n suscriptor. Esto significa que los datos del flujo de origen se generar√°n y perder√°n si no hay nadie suscrito en
ese momento, ya que es un flujo caliente y no almacena elementos por defecto.

En el siguiente ejemplo, el flujo empieza a emitir apenas se ejecuta, antes de que alg√∫n suscriptor se haya conectado.
Por eso, algunos valores ya habr√°n sido emitidos y descartados antes de que `mar` o `gab` se suscriban.

````java
public class Lec04HotAutoConnectPublisher {
    private static final Logger log = LoggerFactory.getLogger(Lec04HotAutoConnectPublisher.class);

    public static void main(String[] args) {
        Flux<String> movieFlux = movieStream()
                .publish().autoConnect(0); // Con el valor 0, empezar√° a emitir datos sin esperar a que haya alg√∫n subscriptor suscrito.

        Util.sleepSeconds(2);
        movieFlux
                .take(4)
                .subscribe(Util.subscriber("mar"));

        Util.sleepSeconds(3);
        movieFlux
                .take(3)
                .subscribe(Util.subscriber("gab"));

        Util.sleepSeconds(13);
    }

    private static Flux<String> movieStream() {
        return Flux.generate(
                        () -> {
                            log.info("Request recibido");
                            return 1;
                        }, (stateValue, synchronousSink) -> {
                            String scene = "escena de pel√≠cula %d".formatted(stateValue);
                            log.info("Ejecutando {}", stateValue);
                            synchronousSink.next(scene);
                            return ++stateValue;
                        }, stateValue -> log.info("Valor final del estado: {}", stateValue)
                )
                .take(10)
                .delayElements(Duration.ofSeconds(1))
                .cast(String.class);
    }
}
````

En este caso, el `ConnectableFlux` comienza a emitir desde el momento en que se ejecuta, incluso sin ning√∫n suscriptor
conectado, gracias al uso de `autoConnect(0)`.

Observa que:

- A las `16:11:12` ya se genera la primera escena, sin que ning√∫n subscriber est√© presente.
- A las `16:11:15`, el suscriptor `mar` se conecta y recibe la escena 3, lo que indica que las escenas 1 y 2 ya fueron
  emitidas y descartadas.
- Luego, `gab` se conecta m√°s tarde (a los 5 segundos) y solo alcanza a recibir desde la escena 5 en adelante.
- Cada suscriptor recibe solo los elementos emitidos a partir del momento en que se conectan, ya que no hay
  almacenamiento intermedio ni reemisi√≥n de elementos anteriores.

Esto demuestra claramente el comportamiento de un `hot publisher` con `autoConnect(0)`: inicia la emisi√≥n sin esperar
suscriptores y no guarda los elementos emitidos.

````bash
16:11:12.450 INFO  [           main] s.Lec04HotAutoConnectPublisher : Request recibido
16:11:12.471 INFO  [           main] s.Lec04HotAutoConnectPublisher : Ejecutando 1
16:11:13.491 INFO  [     parallel-1] s.Lec04HotAutoConnectPublisher : Ejecutando 2
16:11:14.499 INFO  [     parallel-2] s.Lec04HotAutoConnectPublisher : Ejecutando 3
16:11:15.510 INFO  [     parallel-3] d.m.a.common.DefaultSubscriber : mar recibido: escena de pel√≠cula 3
16:11:15.510 INFO  [     parallel-3] s.Lec04HotAutoConnectPublisher : Ejecutando 4
16:11:16.520 INFO  [     parallel-4] d.m.a.common.DefaultSubscriber : mar recibido: escena de pel√≠cula 4
16:11:16.520 INFO  [     parallel-4] s.Lec04HotAutoConnectPublisher : Ejecutando 5
16:11:17.529 INFO  [     parallel-5] d.m.a.common.DefaultSubscriber : mar recibido: escena de pel√≠cula 5
16:11:17.529 INFO  [     parallel-5] d.m.a.common.DefaultSubscriber : gab recibido: escena de pel√≠cula 5
16:11:17.529 INFO  [     parallel-5] s.Lec04HotAutoConnectPublisher : Ejecutando 6
16:11:18.536 INFO  [     parallel-6] d.m.a.common.DefaultSubscriber : mar recibido: escena de pel√≠cula 6
16:11:18.546 INFO  [     parallel-6] d.m.a.common.DefaultSubscriber : mar ¬°completado!
16:11:18.546 INFO  [     parallel-6] d.m.a.common.DefaultSubscriber : gab recibido: escena de pel√≠cula 6
16:11:18.547 INFO  [     parallel-6] s.Lec04HotAutoConnectPublisher : Ejecutando 7
16:11:19.558 INFO  [     parallel-7] d.m.a.common.DefaultSubscriber : gab recibido: escena de pel√≠cula 7
16:11:19.559 INFO  [     parallel-7] d.m.a.common.DefaultSubscriber : gab ¬°completado!
16:11:19.559 INFO  [     parallel-7] s.Lec04HotAutoConnectPublisher : Ejecutando 8
16:11:20.565 INFO  [     parallel-8] s.Lec04HotAutoConnectPublisher : Ejecutando 9
16:11:21.578 INFO  [     parallel-1] s.Lec04HotAutoConnectPublisher : Ejecutando 10
16:11:21.579 INFO  [     parallel-1] s.Lec04HotAutoConnectPublisher : Valor final del estado: 11
````
