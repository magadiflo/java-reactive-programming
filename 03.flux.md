# Sección 3: Flux

---

## Flux

- `Flux<T>` representa una secuencia reactiva que puede emitir `0 a N elementos`.
- Puede terminar con una señal de éxito (`onComplete`) o error (`onError`).

## Flux - Just

Crea un `Flux` que emite los elementos proporcionados y luego se completa.

````java
public class Lec01FluxJust {
    public static void main(String[] args) {
        Flux.just(1, 2, 3, 4)
                .subscribe(Util.subscriber());
    }
}
````

Este `Flux` emitirá los elementos 1, 2, 3, 4 uno tras otro, y luego enviará una señal de completado (`onComplete`).

````bash
16:54:54.196 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 1
16:54:54.199 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 2
16:54:54.199 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 3
16:54:54.199 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 4
16:54:54.201 INFO  [           main] d.m.a.common.DefaultSubscriber :  ¡completado!
````

## Flux - Multiple Subscribers

Creamos un `Flux` que emite los números del 1 al 4. Luego hay dos suscriptores distintos al mismo `Flux`.

1. El primer suscriptor (`sub1`) se suscribe a una versión filtrada del `Flux` (solo números pares).
2. El segundo suscriptor (`sub2`) se suscribe al `Flux` sin filtro, por lo tanto, recibe todos los elementos.

- `Flux.just(...)` crea un `Cold Publisher`.
- Un `Cold Publisher` genera una secuencia cada vez que alguien se suscribe.
- Cada suscripción comienza desde el principio y no comparte el flujo con otros suscriptores.

Esto es útil cuando quieres que cada consumidor reciba la secuencia completa y pueda aplicar sus propias
transformaciones.

````java
public class Lec02MultipleSubscribers {
    public static void main(String[] args) {
        Flux<Integer> numbers = Flux.just(1, 2, 3, 4);

        numbers
                .filter(value -> value % 2 == 0)
                .subscribe(Util.subscriber("sub1"));

        numbers.subscribe(Util.subscriber("sub2"));
    }
}
````

Cuando se tiene más de un `Subscriber` suscrito al mismo `Flux`, cada suscriptor recibe su propia instancia de la
secuencia de datos.

````bash
17:00:41.794 INFO  [           main] d.m.a.common.DefaultSubscriber : sub1 recibido: 2
17:00:41.796 INFO  [           main] d.m.a.common.DefaultSubscriber : sub1 recibido: 4
17:00:41.799 INFO  [           main] d.m.a.common.DefaultSubscriber : sub1 ¡completado!
17:00:41.800 INFO  [           main] d.m.a.common.DefaultSubscriber : sub2 recibido: 1
17:00:41.800 INFO  [           main] d.m.a.common.DefaultSubscriber : sub2 recibido: 2
17:00:41.800 INFO  [           main] d.m.a.common.DefaultSubscriber : sub2 recibido: 3
17:00:41.800 INFO  [           main] d.m.a.common.DefaultSubscriber : sub2 recibido: 4
17:00:41.800 INFO  [           main] d.m.a.common.DefaultSubscriber : sub2 ¡completado!
````

## Flux - From Array / List

Este tema es fundamental porque muestra cómo crear un `Flux` a partir de estructuras de datos ya existentes, como
`listas` o `arrays`.

- `Flux.fromIterable(Iterable<T>)`: Crea un `Flux` que emite todos los elementos de una colección (por ejemplo, `List`,
  `Set`, etc.).
- `Flux.fromArray(T[])`: Crea un `Flux` a partir de un arreglo de cualquier tipo.

Ambos son métodos estáticos de fábrica utilizados para `convertir fuentes de datos existentes en secuencias reactivas`.

````java
public class Lec03FluxFromIterableOrArray {
    public static void main(String[] args) {
        List<String> letters = List.of("a", "b", "c");
        Flux.fromIterable(letters)
                .subscribe(Util.subscriber());

        Integer[] ages = {18, 20, 25};
        Flux.fromArray(ages)
                .subscribe(Util.subscriber());
    }
}
````

Al ejecutar la clase anterior, observamos el siguiente resultado.

````bash
17:13:08.170 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: a
17:13:08.172 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: b
17:13:08.172 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: c
17:13:08.175 INFO  [           main] d.m.a.common.DefaultSubscriber :  ¡completado!
17:13:08.176 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 18
17:13:08.176 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 20
17:13:08.176 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 25
17:13:08.176 INFO  [           main] d.m.a.common.DefaultSubscriber :  ¡completado!
````

## Flux - From Stream

`Flux.fromStream(Stream<T>)` permite convertir un `java.util.stream.Stream` en un `Flux`, para emitir sus elementos de
forma reactiva.

````java
public class Lec04FluxFromStream {
    public static void main(String[] args) {
        List<Integer> numbers = List.of(1, 2, 3);
        Stream<Integer> stream = numbers.stream();

        Flux<Integer> flux = Flux.fromStream(stream);

        flux.subscribe(Util.subscriber("sub1"));
    }
}
````

Si ejecutamos el código anterior veremos que todo está funcionando correctamente.

````bash
17:31:08.222 INFO  [           main] d.m.a.common.DefaultSubscriber : sub1 recibido: 1
17:31:08.224 INFO  [           main] d.m.a.common.DefaultSubscriber : sub1 recibido: 2
17:31:08.224 INFO  [           main] d.m.a.common.DefaultSubscriber : sub1 recibido: 3
17:31:08.226 INFO  [           main] d.m.a.common.DefaultSubscriber : sub1 ¡completado!
````

Sin embargo, es importante entender que los `Streams` en Java son de un solo uso. Esto significa que, una vez consumido
un stream, no puede volver a ser reutilizado (intentar hacerlo lanza una excepción).

En ese sentido, si intentamos utilizar el `Flux.fromStream(stream)` con varias suscripciones, veremos que en el
resultado nos muestra un error.

````java
public class Lec04FluxFromStream {
    public static void main(String[] args) {
        List<Integer> numbers = List.of(1, 2, 3);
        Stream<Integer> stream = numbers.stream();

        Flux<Integer> flux = Flux.fromStream(stream);

        flux.subscribe(Util.subscriber("sub1")); // OK
        flux.subscribe(Util.subscriber("sub2")); // ERROR: el stream ya fue usado
    }
}
````

Este error no es del `Flux`, sino del propio `stream` de java. Si se reutiliza un `stream` ya consumido, se obtiene una
excepción.

````bash
17:32:06.467 INFO  [           main] d.m.a.common.DefaultSubscriber : sub1 recibido: 1
17:32:06.469 INFO  [           main] d.m.a.common.DefaultSubscriber : sub1 recibido: 2
17:32:06.469 INFO  [           main] d.m.a.common.DefaultSubscriber : sub1 recibido: 3
17:32:06.471 INFO  [           main] d.m.a.common.DefaultSubscriber : sub1 ¡completado!
17:32:06.473 ERROR [           main] d.m.a.common.DefaultSubscriber : sub2 error: stream has already been operated upon or closed
````

### ✅ Solución: usar un Stream Supplier

La manera correcta de trabajar con múltiples suscripciones es usando un `Supplier` que crea un nuevo `stream` cada vez.
Esto garantiza que `cada suscriptor reciba su propio stream nuevo`, evitando el error de reutilización.

````java
public class Lec04FluxFromStream {
    public static void main(String[] args) {
        List<Integer> numbers = List.of(1, 2, 3);

        Flux<Integer> flux = Flux.fromStream(() -> numbers.stream());

        flux.subscribe(Util.subscriber("sub1"));
        flux.subscribe(Util.subscriber("sub2"));
    }
}
````

Ahora, si volvemos a ejecutar la aplicación veremos que todos los suscribers están recibiendo sus datos.

````bash
17:34:37.380 INFO  [           main] d.m.a.common.DefaultSubscriber : sub1 recibido: 1
17:34:37.382 INFO  [           main] d.m.a.common.DefaultSubscriber : sub1 recibido: 2
17:34:37.382 INFO  [           main] d.m.a.common.DefaultSubscriber : sub1 recibido: 3
17:34:37.385 INFO  [           main] d.m.a.common.DefaultSubscriber : sub1 ¡completado!
17:34:37.385 INFO  [           main] d.m.a.common.DefaultSubscriber : sub2 recibido: 1
17:34:37.385 INFO  [           main] d.m.a.common.DefaultSubscriber : sub2 recibido: 2
17:34:37.385 INFO  [           main] d.m.a.common.DefaultSubscriber : sub2 recibido: 3
17:34:37.385 INFO  [           main] d.m.a.common.DefaultSubscriber : sub2 ¡completado!
````

## Flux - Range

El operador `range` en `Flux` crea una secuencia de números dentro de un rango específico, generando un `Flux` con un
flujo de números enteros. Es útil cuando necesitas producir una secuencia de números consecutivos en un rango
determinado.

En el siguiente ejemplo, el `Flux.range(3, 4)` genera un `Flux` que emitirá los números `3, 4, 5, 6`. El primer
parámetro es el `número inicial` y el segundo parámetro es la `cantidad de números a emitir`.

Aprovechamos que vamos a emitir 4 elementos para que en cada uno de ellos obtengamos un nombre aleatorio a partir del
`Util.faker().name().firstName()`. Le damos un formato y lo pasamos al `subscriber` para ser procesado.

````java
public class Lec05FluxRange {
    public static void main(String[] args) {
        Flux.range(3, 4)
                .map(i -> String.format("%d°: %s", i, Util.faker().name().firstName()))
                .subscribe(Util.subscriber());
    }
}
````

````bash
17:54:29.879 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 3°: Marquita
17:54:29.883 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 4°: Brenton
17:54:29.883 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 5°: Maria
17:54:29.883 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 6°: Carmelita
17:54:29.887 INFO  [           main] d.m.a.common.DefaultSubscriber :  ¡completado!
````
