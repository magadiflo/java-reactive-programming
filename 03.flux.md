# Secci√≥n 3: Flux

---

## Flux

- `Flux<T>` representa una secuencia reactiva que puede emitir `0 a N elementos`.
- Puede terminar con una se√±al de √©xito (`onComplete`) o error (`onError`).

## Flux - Just

Crea un `Flux` que emite los elementos proporcionados y luego se completa.

````java
public class Lec01FluxJust {
    public static void main(String[] args) {
        Flux.just(1, 2, 3, 4)
                .subscribe(Util.subscriber());
    }
}
````

Este `Flux` emitir√° los elementos 1, 2, 3, 4 uno tras otro, y luego enviar√° una se√±al de completado (`onComplete`).

````bash
16:54:54.196 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 1
16:54:54.199 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 2
16:54:54.199 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 3
16:54:54.199 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 4
16:54:54.201 INFO  [           main] d.m.a.common.DefaultSubscriber :  ¬°completado!
````

## Flux - Multiple Subscribers

Creamos un `Flux` que emite los n√∫meros del 1 al 4. Luego hay dos suscriptores distintos al mismo `Flux`.

1. El primer suscriptor (`sub1`) se suscribe a una versi√≥n filtrada del `Flux` (solo n√∫meros pares).
2. El segundo suscriptor (`sub2`) se suscribe al `Flux` sin filtro, por lo tanto, recibe todos los elementos.

- `Flux.just(...)` crea un `Cold Publisher`.
- Un `Cold Publisher` genera una secuencia cada vez que alguien se suscribe.
- Cada suscripci√≥n comienza desde el principio y no comparte el flujo con otros suscriptores.

Esto es √∫til cuando quieres que cada consumidor reciba la secuencia completa y pueda aplicar sus propias
transformaciones.

````java
public class Lec02MultipleSubscribers {
    public static void main(String[] args) {
        Flux<Integer> numbers = Flux.just(1, 2, 3, 4);

        numbers
                .filter(value -> value % 2 == 0)
                .subscribe(Util.subscriber("sub1"));

        numbers.subscribe(Util.subscriber("sub2"));
    }
}
````

Cuando se tiene m√°s de un `Subscriber` suscrito al mismo `Flux`, cada suscriptor recibe su propia instancia de la
secuencia de datos.

````bash
17:00:41.794 INFO  [           main] d.m.a.common.DefaultSubscriber : sub1 recibido: 2
17:00:41.796 INFO  [           main] d.m.a.common.DefaultSubscriber : sub1 recibido: 4
17:00:41.799 INFO  [           main] d.m.a.common.DefaultSubscriber : sub1 ¬°completado!
17:00:41.800 INFO  [           main] d.m.a.common.DefaultSubscriber : sub2 recibido: 1
17:00:41.800 INFO  [           main] d.m.a.common.DefaultSubscriber : sub2 recibido: 2
17:00:41.800 INFO  [           main] d.m.a.common.DefaultSubscriber : sub2 recibido: 3
17:00:41.800 INFO  [           main] d.m.a.common.DefaultSubscriber : sub2 recibido: 4
17:00:41.800 INFO  [           main] d.m.a.common.DefaultSubscriber : sub2 ¬°completado!
````

## Flux - From Array / List

Este tema es fundamental porque muestra c√≥mo crear un `Flux` a partir de estructuras de datos ya existentes, como
`listas` o `arrays`.

- `Flux.fromIterable(Iterable<T>)`: Crea un `Flux` que emite todos los elementos de una colecci√≥n (por ejemplo, `List`,
  `Set`, etc.).
- `Flux.fromArray(T[])`: Crea un `Flux` a partir de un arreglo de cualquier tipo.

Ambos son m√©todos est√°ticos de f√°brica utilizados para `convertir fuentes de datos existentes en secuencias reactivas`.

````java
public class Lec03FluxFromIterableOrArray {
    public static void main(String[] args) {
        List<String> letters = List.of("a", "b", "c");
        Flux.fromIterable(letters)
                .subscribe(Util.subscriber());

        Integer[] ages = {18, 20, 25};
        Flux.fromArray(ages)
                .subscribe(Util.subscriber());
    }
}
````

Al ejecutar la clase anterior, observamos el siguiente resultado.

````bash
17:13:08.170 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: a
17:13:08.172 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: b
17:13:08.172 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: c
17:13:08.175 INFO  [           main] d.m.a.common.DefaultSubscriber :  ¬°completado!
17:13:08.176 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 18
17:13:08.176 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 20
17:13:08.176 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 25
17:13:08.176 INFO  [           main] d.m.a.common.DefaultSubscriber :  ¬°completado!
````

## Flux - From Stream

`Flux.fromStream(Stream<T>)` permite convertir un `java.util.stream.Stream` en un `Flux`, para emitir sus elementos de
forma reactiva.

````java
public class Lec04FluxFromStream {
    public static void main(String[] args) {
        List<Integer> numbers = List.of(1, 2, 3);
        Stream<Integer> stream = numbers.stream();

        Flux<Integer> flux = Flux.fromStream(stream);

        flux.subscribe(Util.subscriber("sub1"));
    }
}
````

Si ejecutamos el c√≥digo anterior veremos que todo est√° funcionando correctamente.

````bash
17:31:08.222 INFO  [           main] d.m.a.common.DefaultSubscriber : sub1 recibido: 1
17:31:08.224 INFO  [           main] d.m.a.common.DefaultSubscriber : sub1 recibido: 2
17:31:08.224 INFO  [           main] d.m.a.common.DefaultSubscriber : sub1 recibido: 3
17:31:08.226 INFO  [           main] d.m.a.common.DefaultSubscriber : sub1 ¬°completado!
````

Sin embargo, es importante entender que los `Streams` en Java son de un solo uso. Esto significa que, una vez consumido
un stream, no puede volver a ser reutilizado (intentar hacerlo lanza una excepci√≥n).

En ese sentido, si intentamos utilizar el `Flux.fromStream(stream)` con varias suscripciones, veremos que en el
resultado nos muestra un error.

````java
public class Lec04FluxFromStream {
    public static void main(String[] args) {
        List<Integer> numbers = List.of(1, 2, 3);
        Stream<Integer> stream = numbers.stream();

        Flux<Integer> flux = Flux.fromStream(stream);

        flux.subscribe(Util.subscriber("sub1")); // OK
        flux.subscribe(Util.subscriber("sub2")); // ERROR: el stream ya fue usado
    }
}
````

Este error no es del `Flux`, sino del propio `stream` de java. Si se reutiliza un `stream` ya consumido, se obtiene una
excepci√≥n.

````bash
17:32:06.467 INFO  [           main] d.m.a.common.DefaultSubscriber : sub1 recibido: 1
17:32:06.469 INFO  [           main] d.m.a.common.DefaultSubscriber : sub1 recibido: 2
17:32:06.469 INFO  [           main] d.m.a.common.DefaultSubscriber : sub1 recibido: 3
17:32:06.471 INFO  [           main] d.m.a.common.DefaultSubscriber : sub1 ¬°completado!
17:32:06.473 ERROR [           main] d.m.a.common.DefaultSubscriber : sub2 error: stream has already been operated upon or closed
````

### ‚úÖ Soluci√≥n: usar un Stream Supplier

La manera correcta de trabajar con m√∫ltiples suscripciones es usando un `Supplier` que crea un nuevo `stream` cada vez.
Esto garantiza que `cada suscriptor reciba su propio stream nuevo`, evitando el error de reutilizaci√≥n.

````java
public class Lec04FluxFromStream {
    public static void main(String[] args) {
        List<Integer> numbers = List.of(1, 2, 3);

        Flux<Integer> flux = Flux.fromStream(() -> numbers.stream());

        flux.subscribe(Util.subscriber("sub1"));
        flux.subscribe(Util.subscriber("sub2"));
    }
}
````

Ahora, si volvemos a ejecutar la aplicaci√≥n veremos que todos los suscribers est√°n recibiendo sus datos.

````bash
17:34:37.380 INFO  [           main] d.m.a.common.DefaultSubscriber : sub1 recibido: 1
17:34:37.382 INFO  [           main] d.m.a.common.DefaultSubscriber : sub1 recibido: 2
17:34:37.382 INFO  [           main] d.m.a.common.DefaultSubscriber : sub1 recibido: 3
17:34:37.385 INFO  [           main] d.m.a.common.DefaultSubscriber : sub1 ¬°completado!
17:34:37.385 INFO  [           main] d.m.a.common.DefaultSubscriber : sub2 recibido: 1
17:34:37.385 INFO  [           main] d.m.a.common.DefaultSubscriber : sub2 recibido: 2
17:34:37.385 INFO  [           main] d.m.a.common.DefaultSubscriber : sub2 recibido: 3
17:34:37.385 INFO  [           main] d.m.a.common.DefaultSubscriber : sub2 ¬°completado!
````

## Flux - Range

El operador `range` en `Flux` crea una secuencia de n√∫meros dentro de un rango espec√≠fico, generando un `Flux` con un
flujo de n√∫meros enteros. Es √∫til cuando necesitas producir una secuencia de n√∫meros consecutivos en un rango
determinado.

En el siguiente ejemplo, el `Flux.range(3, 4)` genera un `Flux` que emitir√° los n√∫meros `3, 4, 5, 6`. El primer
par√°metro es el `n√∫mero inicial` y el segundo par√°metro es la `cantidad de n√∫meros a emitir`.

Aprovechamos que vamos a emitir 4 elementos para que en cada uno de ellos obtengamos un nombre aleatorio a partir del
`Util.faker().name().firstName()`. Le damos un formato y lo pasamos al `subscriber` para ser procesado.

````java
public class Lec05FluxRange {
    public static void main(String[] args) {
        Flux.range(3, 4)
                .map(i -> String.format("%d¬∞: %s", i, Util.faker().name().firstName()))
                .subscribe(Util.subscriber());
    }
}
````

````bash
17:54:29.879 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 3¬∞: Marquita
17:54:29.883 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 4¬∞: Brenton
17:54:29.883 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 5¬∞: Maria
17:54:29.883 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 6¬∞: Carmelita
17:54:29.887 INFO  [           main] d.m.a.common.DefaultSubscriber :  ¬°completado!
````

## Log Operator

El operador `log()` en `Project Reactor` se utiliza para registrar (`loggear`) los eventos del flujo reactivo.
Es una herramienta muy √∫til para el desarrollo y depuraci√≥n, ya que muestra en consola los eventos que ocurren
dentro de un `Flux` o `Mono`.

Este operador permite ver en tiempo real:

- Cu√°ndo se suscribe un `Subscriber`
- Cu√°ndo se hace una solicitud (`request`)
- Los elementos emitidos (`onNext`)
- Si ocurre un error (`onError`)
- Cuando el flujo se completa (`onComplete`)
- Informaci√≥n del tipo de suscripci√≥n (por ejemplo, si es `synchronous fuseable`)

El siguiente c√≥digo genera un `Flux` que emite los n√∫meros del `1 al 5`. Al usar `.log()`, se imprimen en consola todos
los eventos que ocurren en ese flujo.

````java
public class Lec06Log {
    public static void main(String[] args) {
        Flux.range(1, 5)
                .log()
                .subscribe(Util.subscriber());
    }
}
````

Salida t√≠pica en consola.

````bash
main] reactor.Flux.Range.1           : | onSubscribe([Synchronous Fuseable] FluxRange.RangeSubscription)  // el subscriber se ha suscrito al flujo
main] reactor.Flux.Range.1           : | request(unbounded)                                               // El subscriber solicita una cantidad ilimitada de datos
main] reactor.Flux.Range.1           : | onNext(1)                                                        // El publisher emite el valor 1
main] d.m.a.common.DefaultSubscriber :  recibido: 1                                                       // El subscriber recibe y procesa el valor 1
main] reactor.Flux.Range.1           : | onNext(2)
main] d.m.a.common.DefaultSubscriber :  recibido: 2
main] reactor.Flux.Range.1           : | onNext(3)
main] d.m.a.common.DefaultSubscriber :  recibido: 3
main] reactor.Flux.Range.1           : | onNext(4)
main] d.m.a.common.DefaultSubscriber :  recibido: 4
main] reactor.Flux.Range.1           : | onNext(5)
main] d.m.a.common.DefaultSubscriber :  recibido: 5
main] reactor.Flux.Range.1           : | onComplete()                                                     // El flujo se completa
main] d.m.a.common.DefaultSubscriber :  ¬°completado!                                                      // El subscriber muestra que termin√≥
````

üß† Notas importantes

- Podemos pasarle un nombre de categor√≠a al m√©todo `log("miCategoria")` si deseamos identificar el flujo en los logs.
- Tambi√©n podemos controlar qu√© eventos `loggear` usando una sobrecarga de `log()` con `SignalType`
  (ej. `log("miCategoria", Level.INFO, SignalType.ON_NEXT)`).
- El operador `log()` es solo para depuraci√≥n, `no afecta el comportamiento del flujo`.

## Flux vs List

Para realizar la comparaci√≥n entre `Flux` y `List` vamos a crear la siguiente clase que nos permitir√° ejemplificar mejor
las diferencias.

````java
public class NameGenerator {

    private NameGenerator() {
    }

    public static List<String> getNamesList(int count) {
        return IntStream.rangeClosed(1, count)
                .mapToObj(value -> generateName())
                .toList();
    }

    public static Flux<String> getNamesFlux(int count) {
        return Flux.range(1, count)
                .map(value -> generateName());
    }

    private static String generateName() {
        Util.sleepSeconds(1);
        return Util.faker().name().firstName();
    }
}
````

La clase `NameGenerator` encapsula dos m√©todos clave:

- `getNamesList(int count)` ‚Üí genera una `lista` s√≠ncrona de nombres.
- `getNamesFlux(int count)` ‚Üí genera un `Flux` (flujo reactivo) de nombres.

Ambos usan un m√©todo privado `generateName()` que simula una operaci√≥n costosa con `sleepSeconds(1)` para representar
un tiempo de espera (como si fuera una llamada a una API, base de datos, etc.).

A continuaci√≥n se muestra la clase principal cuyo objetivo es entender las diferencias clave entre trabajar con
colecciones tradicionales como `List` (enfoque `imperativo/s√≠ncrono`) y flujos reactivos como `Flux`
(enfoque `reactivo/as√≠ncrono/no bloqueante`).

````java
public class Lec07FluxVsList {

    private static final Logger log = LoggerFactory.getLogger(Lec07FluxVsList.class);

    public static void main(String[] args) {
        // Lista tradicional
        List<String> namesList = NameGenerator.getNamesList(5); //Somos bloqueados por 5 segundos. Retorna la cantidad solicitada o nada
        log.info(String.valueOf(namesList));

        // Flujo reactivo
        Flux<String> namesFlux = NameGenerator.getNamesFlux(5); //Aqu√≠ f√°cilmente se puede cancelar luego del primer resultado
        namesFlux.subscribe(Util.subscriber());
    }
}
````

### üîç ¬øQu√© pasa internamente?

1. `getNamesList(5)`:
    - Se ejecuta una operaci√≥n bloqueante (1 segundo por nombre).
    - Se espera 5 segundos para obtener toda la lista.
    - Una vez lista, se imprime toda junta.

2. `getNamesFlux(5)`:
    - Los nombres se emiten uno por uno cada segundo.
    - Se pueden procesar a medida que llegan (en tiempo real).
    - Ventaja: puedes cancelar el `subscribe()` si ya no necesitas m√°s elementos.

````bash
// List
10:40:01.953 INFO  [           main] d.m.app.sec03.Lec07FluxVsList  : [Lekisha, Kiyoko, Tanner, Gita, Terrance]

// Flux
10:40:03.017 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Leif
10:40:04.034 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Yong
10:40:05.041 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Justa
10:40:06.049 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Emily
10:40:07.059 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Dorian
10:40:07.065 INFO  [           main] d.m.a.common.DefaultSubscriber :  ¬°completado!
````

### ‚úÖ Conclusi√≥n

- Si necesitas todos los datos antes de continuar (modo tradicional), una `List` puede funcionar, pero bloquea el hilo.
- Si quieres emitir, transformar o consumir datos a medida que est√°n disponibles, `Flux` es la opci√≥n ideal, m√°s
  escalable y eficiente en sistemas reactivos.
- En entornos de alta concurrencia o I/O intensivo, `Flux` supera ampliamente a `List` por su naturaleza no bloqueante
  y capacidad de cancelaci√≥n.

## Preguntas frecuentes: ¬øMono y Flux son estructuras de datos?

Aunque en un principio uno puede pensar que `Mono<T>` y `Flux<T>` son estructuras de datos como `List<T>` o `Set<T>`,
en realidad no lo son.

- `List<T>, Set<T>, ...`, representan los `datos en la memoria`. Son almacenes, son como bodegas llenas de objetos que
  ya est√°n all√≠ y nosotros solo los vamos a buscar.
- `Flux<T>, Mono<T>`, representa un `tunel/tuber√≠a` a trav√©s de la cual se pueden transferir los datos de un lugar a
  otro, una tuber√≠a por donde `los datos fluyen` bajo demanda. Su prop√≥sito `no es almacenar datos`, sino producir y
  transformar flujos de datos.

## Flux - Interval

Crea un `Flux` que emite valores largos, comenzando en `0` y aumentando a intervalos de tiempo espec√≠ficos en el
temporizador global. El primer elemento se emite tras un retraso inicial igual al per√≠odo. Si la demanda no se
produce a tiempo, se generar√° un `onError` con un `IllegalStateException` por desbordamiento que detalla el tick que
no se pudo emitir. En condiciones normales, el `Flux` nunca se completar√°.
Se ejecuta en el Scheduler `Schedulers.parallel()`.

- `Flux.interval(Duration)` es un operador que emite valores tipo Long empezando desde 0 y se incrementa con cada
  intervalo.
- Este operador es `as√≠ncrono` y `no bloqueante`. Utiliza un `Scheduler` (por defecto `Schedulers.parallel()`).
- `No se detiene por s√≠ solo`, a menos que se cancele, se agregue un l√≠mite (como `take(n)`), o finalice el programa.

````java
public class Lec09FluxInterval {
    public static void main(String[] args) {
        Flux.interval(Duration.ofMillis(500)) // Cada 500 milisegundos
                .map(i -> Util.faker().name().firstName()) // Transforma el n√∫mero en un nombre aleatorio
                .subscribe(Util.subscriber());

        Util.sleepSeconds(5); // Mantiene vivo el h ilo principal por 5 segundos
    }
}
````

### üìå Explicaci√≥n

- Se crea un `Flux` que emite un valor cada `500 milisegundos`.
- Cada valor se transforma con `map` usando `faker()` para obtener un nombre aleatorio.
- Se suscribe al `Flux` usando un `subscriber` personalizado (`Util.subscriber()`).
- Se duerme el hilo principal por 5 segundos para permitir que se emitan valores, ya que interval corre en otro hilo.

````bash
12:05:45.873 INFO  [     parallel-1] d.m.a.common.DefaultSubscriber :  recibido: Rosia
12:05:46.263 INFO  [     parallel-1] d.m.a.common.DefaultSubscriber :  recibido: Max
12:05:46.760 INFO  [     parallel-1] d.m.a.common.DefaultSubscriber :  recibido: Kieth
12:05:47.255 INFO  [     parallel-1] d.m.a.common.DefaultSubscriber :  recibido: Dannie
12:05:47.754 INFO  [     parallel-1] d.m.a.common.DefaultSubscriber :  recibido: Micah
12:05:48.269 INFO  [     parallel-1] d.m.a.common.DefaultSubscriber :  recibido: Kendrick
12:05:48.754 INFO  [     parallel-1] d.m.a.common.DefaultSubscriber :  recibido: Allene
12:05:49.265 INFO  [     parallel-1] d.m.a.common.DefaultSubscriber :  recibido: Zola
12:05:49.764 INFO  [     parallel-1] d.m.a.common.DefaultSubscriber :  recibido: Estelle
12:05:50.261 INFO  [     parallel-1] d.m.a.common.DefaultSubscriber :  recibido: Wilson
````

## Flux - Empty/Error

1. `Flux.empty()`
    - Crea un `Flux` que no emite ning√∫n elemento, pero s√≠ completa exitosamente.
    - √ötil cuando queremos devolver un flujo vac√≠o sin error (equivalente a un List vac√≠o).


2. `Flux.error(ThrowableSupplier)`
    - Crea un `Flux` que inmediatamente emite un error y no emite ning√∫n valor.
    - √ötil para simular o propagar fallos.

````java
public class Lec10FluxEmptyError {
    public static void main(String[] args) {
        Flux.empty()
                .subscribe(Util.subscriber());

        Flux.error(() -> new RuntimeException("Ocurri√≥ un error"))
                .subscribe(Util.subscriber());
    }
}
````

````bash
// empty flux
12:28:03.644 INFO  [           main] d.m.a.common.DefaultSubscriber :  ¬°completado!

// error flux
12:28:03.647 ERROR [           main] d.m.a.common.DefaultSubscriber :  error: Ocurri√≥ un error
````