# Sección 3: Flux

---

## Flux

- `Flux<T>` representa una secuencia reactiva que puede emitir `0 a N elementos`.
- Puede terminar con una señal de éxito (`onComplete`) o error (`onError`).

## Flux - Just

Crea un `Flux` que emite los elementos proporcionados y luego se completa.

````java
public class Lec01FluxJust {
    public static void main(String[] args) {
        Flux.just(1, 2, 3, 4)
                .subscribe(Util.subscriber());
    }
}
````

Este `Flux` emitirá los elementos 1, 2, 3, 4 uno tras otro, y luego enviará una señal de completado (`onComplete`).

````bash
16:54:54.196 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 1
16:54:54.199 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 2
16:54:54.199 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 3
16:54:54.199 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 4
16:54:54.201 INFO  [           main] d.m.a.common.DefaultSubscriber :  ¡completado!
````

## Flux - Multiple Subscribers

Creamos un `Flux` que emite los números del 1 al 4. Luego hay dos suscriptores distintos al mismo `Flux`.

1. El primer suscriptor (`sub1`) se suscribe a una versión filtrada del `Flux` (solo números pares).
2. El segundo suscriptor (`sub2`) se suscribe al `Flux` sin filtro, por lo tanto, recibe todos los elementos.

- `Flux.just(...)` crea un `Cold Publisher`.
- Un `Cold Publisher` genera una secuencia cada vez que alguien se suscribe.
- Cada suscripción comienza desde el principio y no comparte el flujo con otros suscriptores.

Esto es útil cuando quieres que cada consumidor reciba la secuencia completa y pueda aplicar sus propias
transformaciones.

````java
public class Lec02MultipleSubscribers {
    public static void main(String[] args) {
        Flux<Integer> numbers = Flux.just(1, 2, 3, 4);

        numbers
                .filter(value -> value % 2 == 0)
                .subscribe(Util.subscriber("sub1"));

        numbers.subscribe(Util.subscriber("sub2"));
    }
}
````

Cuando se tiene más de un `Subscriber` suscrito al mismo `Flux`, cada suscriptor recibe su propia instancia de la
secuencia de datos.

````bash
17:00:41.794 INFO  [           main] d.m.a.common.DefaultSubscriber : sub1 recibido: 2
17:00:41.796 INFO  [           main] d.m.a.common.DefaultSubscriber : sub1 recibido: 4
17:00:41.799 INFO  [           main] d.m.a.common.DefaultSubscriber : sub1 ¡completado!
17:00:41.800 INFO  [           main] d.m.a.common.DefaultSubscriber : sub2 recibido: 1
17:00:41.800 INFO  [           main] d.m.a.common.DefaultSubscriber : sub2 recibido: 2
17:00:41.800 INFO  [           main] d.m.a.common.DefaultSubscriber : sub2 recibido: 3
17:00:41.800 INFO  [           main] d.m.a.common.DefaultSubscriber : sub2 recibido: 4
17:00:41.800 INFO  [           main] d.m.a.common.DefaultSubscriber : sub2 ¡completado!
````

## Flux - From Array / List

Este tema es fundamental porque muestra cómo crear un `Flux` a partir de estructuras de datos ya existentes, como
`listas` o `arrays`.

- `Flux.fromIterable(Iterable<T>)`: Crea un `Flux` que emite todos los elementos de una colección (por ejemplo, `List`,
  `Set`, etc.).
- `Flux.fromArray(T[])`: Crea un `Flux` a partir de un arreglo de cualquier tipo.

Ambos son métodos estáticos de fábrica utilizados para `convertir fuentes de datos existentes en secuencias reactivas`.

````java
public class Lec03FluxFromIterableOrArray {
    public static void main(String[] args) {
        List<String> letters = List.of("a", "b", "c");
        Flux.fromIterable(letters)
                .subscribe(Util.subscriber());

        Integer[] ages = {18, 20, 25};
        Flux.fromArray(ages)
                .subscribe(Util.subscriber());
    }
}
````

Al ejecutar la clase anterior, observamos el siguiente resultado.

````bash
17:13:08.170 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: a
17:13:08.172 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: b
17:13:08.172 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: c
17:13:08.175 INFO  [           main] d.m.a.common.DefaultSubscriber :  ¡completado!
17:13:08.176 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 18
17:13:08.176 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 20
17:13:08.176 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 25
17:13:08.176 INFO  [           main] d.m.a.common.DefaultSubscriber :  ¡completado!
````

## Flux - From Stream

`Flux.fromStream(Stream<T>)` permite convertir un `java.util.stream.Stream` en un `Flux`, para emitir sus elementos de
forma reactiva.

````java
public class Lec04FluxFromStream {
    public static void main(String[] args) {
        List<Integer> numbers = List.of(1, 2, 3);
        Stream<Integer> stream = numbers.stream();

        Flux<Integer> flux = Flux.fromStream(stream);

        flux.subscribe(Util.subscriber("sub1"));
    }
}
````

Si ejecutamos el código anterior veremos que todo está funcionando correctamente.

````bash
17:31:08.222 INFO  [           main] d.m.a.common.DefaultSubscriber : sub1 recibido: 1
17:31:08.224 INFO  [           main] d.m.a.common.DefaultSubscriber : sub1 recibido: 2
17:31:08.224 INFO  [           main] d.m.a.common.DefaultSubscriber : sub1 recibido: 3
17:31:08.226 INFO  [           main] d.m.a.common.DefaultSubscriber : sub1 ¡completado!
````

Sin embargo, es importante entender que los `Streams` en Java son de un solo uso. Esto significa que, una vez consumido
un stream, no puede volver a ser reutilizado (intentar hacerlo lanza una excepción).

En ese sentido, si intentamos utilizar el `Flux.fromStream(stream)` con varias suscripciones, veremos que en el
resultado nos muestra un error.

````java
public class Lec04FluxFromStream {
    public static void main(String[] args) {
        List<Integer> numbers = List.of(1, 2, 3);
        Stream<Integer> stream = numbers.stream();

        Flux<Integer> flux = Flux.fromStream(stream);

        flux.subscribe(Util.subscriber("sub1")); // OK
        flux.subscribe(Util.subscriber("sub2")); // ERROR: el stream ya fue usado
    }
}
````

Este error no es del `Flux`, sino del propio `stream` de java. Si se reutiliza un `stream` ya consumido, se obtiene una
excepción.

````bash
17:32:06.467 INFO  [           main] d.m.a.common.DefaultSubscriber : sub1 recibido: 1
17:32:06.469 INFO  [           main] d.m.a.common.DefaultSubscriber : sub1 recibido: 2
17:32:06.469 INFO  [           main] d.m.a.common.DefaultSubscriber : sub1 recibido: 3
17:32:06.471 INFO  [           main] d.m.a.common.DefaultSubscriber : sub1 ¡completado!
17:32:06.473 ERROR [           main] d.m.a.common.DefaultSubscriber : sub2 error: stream has already been operated upon or closed
````

### ✅ Solución: usar un Stream Supplier

La manera correcta de trabajar con múltiples suscripciones es usando un `Supplier` que crea un nuevo `stream` cada vez.
Esto garantiza que `cada suscriptor reciba su propio stream nuevo`, evitando el error de reutilización.

````java
public class Lec04FluxFromStream {
    public static void main(String[] args) {
        List<Integer> numbers = List.of(1, 2, 3);

        Flux<Integer> flux = Flux.fromStream(() -> numbers.stream());

        flux.subscribe(Util.subscriber("sub1"));
        flux.subscribe(Util.subscriber("sub2"));
    }
}
````

Ahora, si volvemos a ejecutar la aplicación veremos que todos los suscribers están recibiendo sus datos.

````bash
17:34:37.380 INFO  [           main] d.m.a.common.DefaultSubscriber : sub1 recibido: 1
17:34:37.382 INFO  [           main] d.m.a.common.DefaultSubscriber : sub1 recibido: 2
17:34:37.382 INFO  [           main] d.m.a.common.DefaultSubscriber : sub1 recibido: 3
17:34:37.385 INFO  [           main] d.m.a.common.DefaultSubscriber : sub1 ¡completado!
17:34:37.385 INFO  [           main] d.m.a.common.DefaultSubscriber : sub2 recibido: 1
17:34:37.385 INFO  [           main] d.m.a.common.DefaultSubscriber : sub2 recibido: 2
17:34:37.385 INFO  [           main] d.m.a.common.DefaultSubscriber : sub2 recibido: 3
17:34:37.385 INFO  [           main] d.m.a.common.DefaultSubscriber : sub2 ¡completado!
````

## Flux - Range

El operador `range` en `Flux` crea una secuencia de números dentro de un rango específico, generando un `Flux` con un
flujo de números enteros. Es útil cuando necesitas producir una secuencia de números consecutivos en un rango
determinado.

En el siguiente ejemplo, el `Flux.range(3, 4)` genera un `Flux` que emitirá los números `3, 4, 5, 6`. El primer
parámetro es el `número inicial` y el segundo parámetro es la `cantidad de números a emitir`.

Aprovechamos que vamos a emitir 4 elementos para que en cada uno de ellos obtengamos un nombre aleatorio a partir del
`Util.faker().name().firstName()`. Le damos un formato y lo pasamos al `subscriber` para ser procesado.

````java
public class Lec05FluxRange {
    public static void main(String[] args) {
        Flux.range(3, 4)
                .map(i -> String.format("%d°: %s", i, Util.faker().name().firstName()))
                .subscribe(Util.subscriber());
    }
}
````

````bash
17:54:29.879 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 3°: Marquita
17:54:29.883 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 4°: Brenton
17:54:29.883 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 5°: Maria
17:54:29.883 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 6°: Carmelita
17:54:29.887 INFO  [           main] d.m.a.common.DefaultSubscriber :  ¡completado!
````

## Log Operator

El operador `log()` en `Project Reactor` se utiliza para registrar (`loggear`) los eventos del flujo reactivo.
Es una herramienta muy útil para el desarrollo y depuración, ya que muestra en consola los eventos que ocurren
dentro de un `Flux` o `Mono`.

Este operador permite ver en tiempo real:

- Cuándo se suscribe un `Subscriber`
- Cuándo se hace una solicitud (`request`)
- Los elementos emitidos (`onNext`)
- Si ocurre un error (`onError`)
- Cuando el flujo se completa (`onComplete`)
- Información del tipo de suscripción (por ejemplo, si es `synchronous fuseable`)

El siguiente código genera un `Flux` que emite los números del `1 al 5`. Al usar `.log()`, se imprimen en consola todos
los eventos que ocurren en ese flujo.

````java
public class Lec06Log {
    public static void main(String[] args) {
        Flux.range(1, 5)
                .log()
                .subscribe(Util.subscriber());
    }
}
````

Salida típica en consola.

````bash
main] reactor.Flux.Range.1           : | onSubscribe([Synchronous Fuseable] FluxRange.RangeSubscription)  // el subscriber se ha suscrito al flujo
main] reactor.Flux.Range.1           : | request(unbounded)                                               // El subscriber solicita una cantidad ilimitada de datos
main] reactor.Flux.Range.1           : | onNext(1)                                                        // El publisher emite el valor 1
main] d.m.a.common.DefaultSubscriber :  recibido: 1                                                       // El subscriber recibe y procesa el valor 1
main] reactor.Flux.Range.1           : | onNext(2)
main] d.m.a.common.DefaultSubscriber :  recibido: 2
main] reactor.Flux.Range.1           : | onNext(3)
main] d.m.a.common.DefaultSubscriber :  recibido: 3
main] reactor.Flux.Range.1           : | onNext(4)
main] d.m.a.common.DefaultSubscriber :  recibido: 4
main] reactor.Flux.Range.1           : | onNext(5)
main] d.m.a.common.DefaultSubscriber :  recibido: 5
main] reactor.Flux.Range.1           : | onComplete()                                                     // El flujo se completa
main] d.m.a.common.DefaultSubscriber :  ¡completado!                                                      // El subscriber muestra que terminó
````

🧠 Notas importantes

- Podemos pasarle un nombre de categoría al método `log("miCategoria")` si deseamos identificar el flujo en los logs.
- También podemos controlar qué eventos `loggear` usando una sobrecarga de `log()` con `SignalType`
  (ej. `log("miCategoria", Level.INFO, SignalType.ON_NEXT)`).
- El operador `log()` es solo para depuración, `no afecta el comportamiento del flujo`.

## Flux vs List

Para realizar la comparación entre `Flux` y `List` vamos a crear la siguiente clase que nos permitirá ejemplificar mejor
las diferencias.

````java
public class NameGenerator {

    private NameGenerator() {
    }

    public static List<String> getNamesList(int count) {
        return IntStream.rangeClosed(1, count)
                .mapToObj(value -> generateName())
                .toList();
    }

    public static Flux<String> getNamesFlux(int count) {
        return Flux.range(1, count)
                .map(value -> generateName());
    }

    private static String generateName() {
        Util.sleepSeconds(1);
        return Util.faker().name().firstName();
    }
}
````

La clase `NameGenerator` encapsula dos métodos clave:

- `getNamesList(int count)` → genera una `lista` síncrona de nombres.
- `getNamesFlux(int count)` → genera un `Flux` (flujo reactivo) de nombres.

Ambos usan un método privado `generateName()` que simula una operación costosa con `sleepSeconds(1)` para representar
un tiempo de espera (como si fuera una llamada a una API, base de datos, etc.).

A continuación se muestra la clase principal cuyo objetivo es entender las diferencias clave entre trabajar con
colecciones tradicionales como `List` (enfoque `imperativo/síncrono`) y flujos reactivos como `Flux`
(enfoque `reactivo/asíncrono/no bloqueante`).

````java
public class Lec07FluxVsList {

    private static final Logger log = LoggerFactory.getLogger(Lec07FluxVsList.class);

    public static void main(String[] args) {
        // Lista tradicional
        List<String> namesList = NameGenerator.getNamesList(5); //Somos bloqueados por 5 segundos. Retorna la cantidad solicitada o nada
        log.info(String.valueOf(namesList));

        // Flujo reactivo
        Flux<String> namesFlux = NameGenerator.getNamesFlux(5); //Aquí fácilmente se puede cancelar luego del primer resultado
        namesFlux.subscribe(Util.subscriber());
    }
}
````

### 🔍 ¿Qué pasa internamente?

1. `getNamesList(5)`:
    - Se ejecuta una operación bloqueante (1 segundo por nombre).
    - Se espera 5 segundos para obtener toda la lista.
    - Una vez lista, se imprime toda junta.

2. `getNamesFlux(5)`:
    - Los nombres se emiten uno por uno cada segundo.
    - Se pueden procesar a medida que llegan (en tiempo real).
    - Ventaja: puedes cancelar el `subscribe()` si ya no necesitas más elementos.

````bash
// List
10:40:01.953 INFO  [           main] d.m.app.sec03.Lec07FluxVsList  : [Lekisha, Kiyoko, Tanner, Gita, Terrance]

// Flux
10:40:03.017 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Leif
10:40:04.034 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Yong
10:40:05.041 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Justa
10:40:06.049 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Emily
10:40:07.059 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Dorian
10:40:07.065 INFO  [           main] d.m.a.common.DefaultSubscriber :  ¡completado!
````

### ✅ Conclusión

- Si necesitas todos los datos antes de continuar (modo tradicional), una `List` puede funcionar, pero bloquea el hilo.
- Si quieres emitir, transformar o consumir datos a medida que están disponibles, `Flux` es la opción ideal, más
  escalable y eficiente en sistemas reactivos.
- En entornos de alta concurrencia o I/O intensivo, `Flux` supera ampliamente a `List` por su naturaleza no bloqueante
  y capacidad de cancelación.
