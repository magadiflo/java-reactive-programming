# Sección 3: Flux

---

## Flux

- `Flux<T>` representa una secuencia reactiva que puede emitir `0 a N elementos`.
- Puede terminar con una señal de éxito (`onComplete`) o error (`onError`).

## Flux - Just

Crea un `Flux` que emite los elementos proporcionados y luego se completa.

````java
public class Lec01FluxJust {
    public static void main(String[] args) {
        Flux.just(1, 2, 3, 4)
                .subscribe(Util.subscriber());
    }
}
````

Este `Flux` emitirá los elementos 1, 2, 3, 4 uno tras otro, y luego enviará una señal de completado (`onComplete`).

````bash
16:54:54.196 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 1
16:54:54.199 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 2
16:54:54.199 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 3
16:54:54.199 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 4
16:54:54.201 INFO  [           main] d.m.a.common.DefaultSubscriber :  ¡completado!
````

## Flux - Multiple Subscribers

Creamos un `Flux` que emite los números del 1 al 4. Luego hay dos suscriptores distintos al mismo `Flux`.

1. El primer suscriptor (`sub1`) se suscribe a una versión filtrada del `Flux` (solo números pares).
2. El segundo suscriptor (`sub2`) se suscribe al `Flux` sin filtro, por lo tanto, recibe todos los elementos.

- `Flux.just(...)` crea un `Cold Publisher`.
- Un `Cold Publisher` genera una secuencia cada vez que alguien se suscribe.
- Cada suscripción comienza desde el principio y no comparte el flujo con otros suscriptores.

Esto es útil cuando quieres que cada consumidor reciba la secuencia completa y pueda aplicar sus propias
transformaciones.

````java
public class Lec02MultipleSubscribers {
    public static void main(String[] args) {
        Flux<Integer> numbers = Flux.just(1, 2, 3, 4);

        numbers
                .filter(value -> value % 2 == 0)
                .subscribe(Util.subscriber("sub1"));

        numbers.subscribe(Util.subscriber("sub2"));
    }
}
````

Cuando se tiene más de un `Subscriber` suscrito al mismo `Flux`, cada suscriptor recibe su propia instancia de la
secuencia de datos.

````bash
17:00:41.794 INFO  [           main] d.m.a.common.DefaultSubscriber : sub1 recibido: 2
17:00:41.796 INFO  [           main] d.m.a.common.DefaultSubscriber : sub1 recibido: 4
17:00:41.799 INFO  [           main] d.m.a.common.DefaultSubscriber : sub1 ¡completado!
17:00:41.800 INFO  [           main] d.m.a.common.DefaultSubscriber : sub2 recibido: 1
17:00:41.800 INFO  [           main] d.m.a.common.DefaultSubscriber : sub2 recibido: 2
17:00:41.800 INFO  [           main] d.m.a.common.DefaultSubscriber : sub2 recibido: 3
17:00:41.800 INFO  [           main] d.m.a.common.DefaultSubscriber : sub2 recibido: 4
17:00:41.800 INFO  [           main] d.m.a.common.DefaultSubscriber : sub2 ¡completado!
````

## Flux - From Array / List

Este tema es fundamental porque muestra cómo crear un `Flux` a partir de estructuras de datos ya existentes, como
`listas` o `arrays`.

- `Flux.fromIterable(Iterable<T>)`: Crea un `Flux` que emite todos los elementos de una colección (por ejemplo, `List`,
  `Set`, etc.).
- `Flux.fromArray(T[])`: Crea un `Flux` a partir de un arreglo de cualquier tipo.

Ambos son métodos estáticos de fábrica utilizados para `convertir fuentes de datos existentes en secuencias reactivas`.

````java
public class Lec03FluxFromIterableOrArray {
    public static void main(String[] args) {
        List<String> letters = List.of("a", "b", "c");
        Flux.fromIterable(letters)
                .subscribe(Util.subscriber());

        Integer[] ages = {18, 20, 25};
        Flux.fromArray(ages)
                .subscribe(Util.subscriber());
    }
}
````

Al ejecutar la clase anterior, observamos el siguiente resultado.

````bash
17:13:08.170 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: a
17:13:08.172 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: b
17:13:08.172 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: c
17:13:08.175 INFO  [           main] d.m.a.common.DefaultSubscriber :  ¡completado!
17:13:08.176 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 18
17:13:08.176 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 20
17:13:08.176 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 25
17:13:08.176 INFO  [           main] d.m.a.common.DefaultSubscriber :  ¡completado!
````

## Flux - From Stream

`Flux.fromStream(Stream<T>)` permite convertir un `java.util.stream.Stream` en un `Flux`, para emitir sus elementos de
forma reactiva.

````java
public class Lec04FluxFromStream {
    public static void main(String[] args) {
        List<Integer> numbers = List.of(1, 2, 3);
        Stream<Integer> stream = numbers.stream();

        Flux<Integer> flux = Flux.fromStream(stream);

        flux.subscribe(Util.subscriber("sub1"));
    }
}
````

Si ejecutamos el código anterior veremos que todo está funcionando correctamente.

````bash
17:31:08.222 INFO  [           main] d.m.a.common.DefaultSubscriber : sub1 recibido: 1
17:31:08.224 INFO  [           main] d.m.a.common.DefaultSubscriber : sub1 recibido: 2
17:31:08.224 INFO  [           main] d.m.a.common.DefaultSubscriber : sub1 recibido: 3
17:31:08.226 INFO  [           main] d.m.a.common.DefaultSubscriber : sub1 ¡completado!
````

Sin embargo, es importante entender que los `Streams` en Java son de un solo uso. Esto significa que, una vez consumido
un stream, no puede volver a ser reutilizado (intentar hacerlo lanza una excepción).

En ese sentido, si intentamos utilizar el `Flux.fromStream(stream)` con varias suscripciones, veremos que en el
resultado nos muestra un error.

````java
public class Lec04FluxFromStream {
    public static void main(String[] args) {
        List<Integer> numbers = List.of(1, 2, 3);
        Stream<Integer> stream = numbers.stream();

        Flux<Integer> flux = Flux.fromStream(stream);

        flux.subscribe(Util.subscriber("sub1")); // OK
        flux.subscribe(Util.subscriber("sub2")); // ERROR: el stream ya fue usado
    }
}
````

Este error no es del `Flux`, sino del propio `stream` de java. Si se reutiliza un `stream` ya consumido, se obtiene una
excepción.

````bash
17:32:06.467 INFO  [           main] d.m.a.common.DefaultSubscriber : sub1 recibido: 1
17:32:06.469 INFO  [           main] d.m.a.common.DefaultSubscriber : sub1 recibido: 2
17:32:06.469 INFO  [           main] d.m.a.common.DefaultSubscriber : sub1 recibido: 3
17:32:06.471 INFO  [           main] d.m.a.common.DefaultSubscriber : sub1 ¡completado!
17:32:06.473 ERROR [           main] d.m.a.common.DefaultSubscriber : sub2 error: stream has already been operated upon or closed
````

### ✅ Solución: usar un Stream Supplier

La manera correcta de trabajar con múltiples suscripciones es usando un `Supplier` que crea un nuevo `stream` cada vez.
Esto garantiza que `cada suscriptor reciba su propio stream nuevo`, evitando el error de reutilización.

````java
public class Lec04FluxFromStream {
    public static void main(String[] args) {
        List<Integer> numbers = List.of(1, 2, 3);

        Flux<Integer> flux = Flux.fromStream(() -> numbers.stream());

        flux.subscribe(Util.subscriber("sub1"));
        flux.subscribe(Util.subscriber("sub2"));
    }
}
````

Ahora, si volvemos a ejecutar la aplicación veremos que todos los suscribers están recibiendo sus datos.

````bash
17:34:37.380 INFO  [           main] d.m.a.common.DefaultSubscriber : sub1 recibido: 1
17:34:37.382 INFO  [           main] d.m.a.common.DefaultSubscriber : sub1 recibido: 2
17:34:37.382 INFO  [           main] d.m.a.common.DefaultSubscriber : sub1 recibido: 3
17:34:37.385 INFO  [           main] d.m.a.common.DefaultSubscriber : sub1 ¡completado!
17:34:37.385 INFO  [           main] d.m.a.common.DefaultSubscriber : sub2 recibido: 1
17:34:37.385 INFO  [           main] d.m.a.common.DefaultSubscriber : sub2 recibido: 2
17:34:37.385 INFO  [           main] d.m.a.common.DefaultSubscriber : sub2 recibido: 3
17:34:37.385 INFO  [           main] d.m.a.common.DefaultSubscriber : sub2 ¡completado!
````

## Flux - Range

El operador `range` en `Flux` crea una secuencia de números dentro de un rango específico, generando un `Flux` con un
flujo de números enteros. Es útil cuando necesitas producir una secuencia de números consecutivos en un rango
determinado.

En el siguiente ejemplo, el `Flux.range(3, 4)` genera un `Flux` que emitirá los números `3, 4, 5, 6`. El primer
parámetro es el `número inicial` y el segundo parámetro es la `cantidad de números a emitir`.

Aprovechamos que vamos a emitir 4 elementos para que en cada uno de ellos obtengamos un nombre aleatorio a partir del
`Util.faker().name().firstName()`. Le damos un formato y lo pasamos al `subscriber` para ser procesado.

````java
public class Lec05FluxRange {
    public static void main(String[] args) {
        Flux.range(3, 4)
                .map(i -> String.format("%d°: %s", i, Util.faker().name().firstName()))
                .subscribe(Util.subscriber());
    }
}
````

````bash
17:54:29.879 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 3°: Marquita
17:54:29.883 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 4°: Brenton
17:54:29.883 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 5°: Maria
17:54:29.883 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 6°: Carmelita
17:54:29.887 INFO  [           main] d.m.a.common.DefaultSubscriber :  ¡completado!
````

## Log Operator

El operador `log()` en `Project Reactor` se utiliza para registrar (`loggear`) los eventos del flujo reactivo.
Es una herramienta muy útil para el desarrollo y depuración, ya que muestra en consola los eventos que ocurren
dentro de un `Flux` o `Mono`.

Este operador permite ver en tiempo real:

- Cuándo se suscribe un `Subscriber`
- Cuándo se hace una solicitud (`request`)
- Los elementos emitidos (`onNext`)
- Si ocurre un error (`onError`)
- Cuando el flujo se completa (`onComplete`)
- Información del tipo de suscripción (por ejemplo, si es `synchronous fuseable`)

El siguiente código genera un `Flux` que emite los números del `1 al 5`. Al usar `.log()`, se imprimen en consola todos
los eventos que ocurren en ese flujo.

````java
public class Lec06Log {
    public static void main(String[] args) {
        Flux.range(1, 5)
                .log()
                .subscribe(Util.subscriber());
    }
}
````

Salida típica en consola.

````bash
main] reactor.Flux.Range.1           : | onSubscribe([Synchronous Fuseable] FluxRange.RangeSubscription)  // el subscriber se ha suscrito al flujo
main] reactor.Flux.Range.1           : | request(unbounded)                                               // El subscriber solicita una cantidad ilimitada de datos
main] reactor.Flux.Range.1           : | onNext(1)                                                        // El publisher emite el valor 1
main] d.m.a.common.DefaultSubscriber :  recibido: 1                                                       // El subscriber recibe y procesa el valor 1
main] reactor.Flux.Range.1           : | onNext(2)
main] d.m.a.common.DefaultSubscriber :  recibido: 2
main] reactor.Flux.Range.1           : | onNext(3)
main] d.m.a.common.DefaultSubscriber :  recibido: 3
main] reactor.Flux.Range.1           : | onNext(4)
main] d.m.a.common.DefaultSubscriber :  recibido: 4
main] reactor.Flux.Range.1           : | onNext(5)
main] d.m.a.common.DefaultSubscriber :  recibido: 5
main] reactor.Flux.Range.1           : | onComplete()                                                     // El flujo se completa
main] d.m.a.common.DefaultSubscriber :  ¡completado!                                                      // El subscriber muestra que terminó
````

🧠 Notas importantes

- Podemos pasarle un nombre de categoría al método `log("miCategoria")` si deseamos identificar el flujo en los logs.
- También podemos controlar qué eventos `loggear` usando una sobrecarga de `log()` con `SignalType`
  (ej. `log("miCategoria", Level.INFO, SignalType.ON_NEXT)`).
- El operador `log()` es solo para depuración, `no afecta el comportamiento del flujo`.

## Flux vs List

Para realizar la comparación entre `Flux` y `List` vamos a crear la siguiente clase que nos permitirá ejemplificar mejor
las diferencias.

````java
public class NameGenerator {

    private NameGenerator() {
    }

    public static List<String> getNamesList(int count) {
        return IntStream.rangeClosed(1, count)
                .mapToObj(value -> generateName())
                .toList();
    }

    public static Flux<String> getNamesFlux(int count) {
        return Flux.range(1, count)
                .map(value -> generateName());
    }

    private static String generateName() {
        Util.sleepSeconds(1);
        return Util.faker().name().firstName();
    }
}
````

La clase `NameGenerator` encapsula dos métodos clave:

- `getNamesList(int count)` → genera una `lista` síncrona de nombres.
- `getNamesFlux(int count)` → genera un `Flux` (flujo reactivo) de nombres.

Ambos usan un método privado `generateName()` que simula una operación costosa con `sleepSeconds(1)` para representar
un tiempo de espera (como si fuera una llamada a una API, base de datos, etc.).

A continuación se muestra la clase principal cuyo objetivo es entender las diferencias clave entre trabajar con
colecciones tradicionales como `List` (enfoque `imperativo/síncrono`) y flujos reactivos como `Flux`
(enfoque `reactivo/asíncrono/no bloqueante`).

````java
public class Lec07FluxVsList {

    private static final Logger log = LoggerFactory.getLogger(Lec07FluxVsList.class);

    public static void main(String[] args) {
        // Lista tradicional
        List<String> namesList = NameGenerator.getNamesList(5); //Somos bloqueados por 5 segundos. Retorna la cantidad solicitada o nada
        log.info(String.valueOf(namesList));

        // Flujo reactivo
        Flux<String> namesFlux = NameGenerator.getNamesFlux(5); //Aquí fácilmente se puede cancelar luego del primer resultado
        namesFlux.subscribe(Util.subscriber());
    }
}
````

### 🔍 ¿Qué pasa internamente?

1. `getNamesList(5)`:
    - Se ejecuta una operación bloqueante (1 segundo por nombre).
    - Se espera 5 segundos para obtener toda la lista.
    - Una vez lista, se imprime toda junta.

2. `getNamesFlux(5)`:
    - Los nombres se emiten uno por uno cada segundo.
    - Se pueden procesar a medida que llegan (en tiempo real).
    - Ventaja: puedes cancelar el `subscribe()` si ya no necesitas más elementos.

````bash
// List
10:40:01.953 INFO  [           main] d.m.app.sec03.Lec07FluxVsList  : [Lekisha, Kiyoko, Tanner, Gita, Terrance]

// Flux
10:40:03.017 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Leif
10:40:04.034 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Yong
10:40:05.041 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Justa
10:40:06.049 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Emily
10:40:07.059 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Dorian
10:40:07.065 INFO  [           main] d.m.a.common.DefaultSubscriber :  ¡completado!
````

### ✅ Conclusión

- Si necesitas todos los datos antes de continuar (modo tradicional), una `List` puede funcionar, pero bloquea el hilo.
- Si quieres emitir, transformar o consumir datos a medida que están disponibles, `Flux` es la opción ideal, más
  escalable y eficiente en sistemas reactivos.
- En entornos de alta concurrencia o I/O intensivo, `Flux` supera ampliamente a `List` por su naturaleza no bloqueante
  y capacidad de cancelación.

## Preguntas frecuentes: ¿Mono y Flux son estructuras de datos?

Aunque en un principio uno puede pensar que `Mono<T>` y `Flux<T>` son estructuras de datos como `List<T>` o `Set<T>`,
en realidad no lo son.

- `List<T>, Set<T>, ...`, representan los `datos en la memoria`. Son almacenes, son como bodegas llenas de objetos que
  ya están allí y nosotros solo los vamos a buscar.
- `Flux<T>, Mono<T>`, representa un `tunel/tubería` a través de la cual se pueden transferir los datos de un lugar a
  otro, una tubería por donde `los datos fluyen` bajo demanda. Su propósito `no es almacenar datos`, sino producir y
  transformar flujos de datos.

## Flux - Interval

Crea un `Flux` que emite valores largos, comenzando en `0` y aumentando a intervalos de tiempo específicos en el
temporizador global. El primer elemento se emite tras un retraso inicial igual al período. Si la demanda no se
produce a tiempo, se generará un `onError` con un `IllegalStateException` por desbordamiento que detalla el tick que
no se pudo emitir. En condiciones normales, el `Flux` nunca se completará.
Se ejecuta en el Scheduler `Schedulers.parallel()`.

- `Flux.interval(Duration)` es un operador que emite valores tipo Long empezando desde 0 y se incrementa con cada
  intervalo.
- Este operador es `asíncrono` y `no bloqueante`. Utiliza un `Scheduler` (por defecto `Schedulers.parallel()`).
- `No se detiene por sí solo`, a menos que se cancele, se agregue un límite (como `take(n)`), o finalice el programa.

````java
public class Lec09FluxInterval {
    public static void main(String[] args) {
        Flux.interval(Duration.ofMillis(500)) // Cada 500 milisegundos
                .map(i -> Util.faker().name().firstName()) // Transforma el número en un nombre aleatorio
                .subscribe(Util.subscriber());

        Util.sleepSeconds(5); // Mantiene vivo el h ilo principal por 5 segundos
    }
}
````

### 📌 Explicación

- Se crea un `Flux` que emite un valor cada `500 milisegundos`.
- Cada valor se transforma con `map` usando `faker()` para obtener un nombre aleatorio.
- Se suscribe al `Flux` usando un `subscriber` personalizado (`Util.subscriber()`).
- Se duerme el hilo principal por 5 segundos para permitir que se emitan valores, ya que interval corre en otro hilo.

````bash
12:05:45.873 INFO  [     parallel-1] d.m.a.common.DefaultSubscriber :  recibido: Rosia
12:05:46.263 INFO  [     parallel-1] d.m.a.common.DefaultSubscriber :  recibido: Max
12:05:46.760 INFO  [     parallel-1] d.m.a.common.DefaultSubscriber :  recibido: Kieth
12:05:47.255 INFO  [     parallel-1] d.m.a.common.DefaultSubscriber :  recibido: Dannie
12:05:47.754 INFO  [     parallel-1] d.m.a.common.DefaultSubscriber :  recibido: Micah
12:05:48.269 INFO  [     parallel-1] d.m.a.common.DefaultSubscriber :  recibido: Kendrick
12:05:48.754 INFO  [     parallel-1] d.m.a.common.DefaultSubscriber :  recibido: Allene
12:05:49.265 INFO  [     parallel-1] d.m.a.common.DefaultSubscriber :  recibido: Zola
12:05:49.764 INFO  [     parallel-1] d.m.a.common.DefaultSubscriber :  recibido: Estelle
12:05:50.261 INFO  [     parallel-1] d.m.a.common.DefaultSubscriber :  recibido: Wilson
````

## Flux - Empty/Error

1. `Flux.empty()`
    - Crea un `Flux` que no emite ningún elemento, pero sí completa exitosamente.
    - Útil cuando queremos devolver un flujo vacío sin error (equivalente a un List vacío).


2. `Flux.error(ThrowableSupplier)`
    - Crea un `Flux` que inmediatamente emite un error y no emite ningún valor.
    - Útil para simular o propagar fallos.

````java
public class Lec10FluxEmptyError {
    public static void main(String[] args) {
        Flux.empty()
                .subscribe(Util.subscriber());

        Flux.error(() -> new RuntimeException("Ocurrió un error"))
                .subscribe(Util.subscriber());
    }
}
````

````bash
// empty flux
12:28:03.644 INFO  [           main] d.m.a.common.DefaultSubscriber :  ¡completado!

// error flux
12:28:03.647 ERROR [           main] d.m.a.common.DefaultSubscriber :  error: Ocurrió un error
````