# Secci√≥n 4: Flux - Emitiendo items program√°ticamente

---

## Flux.create() ‚Äì Emisi√≥n imperativa de elementos

En la secci√≥n anterior, hab√≠amos hablado de algunas opciones para crear un flujo, por ejemplo a partir de una lista, un
arreglo, etc. Eso es bueno cuando ya tenemos esos tipos en alg√∫n lugar del c√≥digo y podemos crear un flujo a partir de
ah√≠. Pero probablemente nos falte algo, es decir, nosotros como desarrolladores, necesitamos la capacidad de emitir
un elemento mediante programaci√≥n, seguir emitiendo datos hasta que se cumpla alguna condici√≥n. Para ese escenario
`Reactor` ofrece un par de opciones, eso es lo que veremos en este apartado.

A continuaci√≥n demostramos c√≥mo crear un `Flux` que emite elementos manualmente mediante programaci√≥n,
en lugar de usar datos ya existentes.

````java
public class Lec01FluxCreate {
    public static void main(String[] args) {
        Flux.create(fluxSink -> {
            String country;
            do {
                country = Util.faker().country().name();    // genera un pa√≠s aleatorio
                fluxSink.next(country);                     // emite el pa√≠s al Flux
            } while (!country.equalsIgnoreCase("Peru"));    // sigue hasta que se emita "Peru"

            fluxSink.complete();                            // indica que el flujo ha terminado
        }).subscribe(Util.subscriber());
    }
}
````

### Donde

- `Flux.create(...)`, crea un `Flux` manualmente usando un `FluxSink`. Nosotros decidimos cu√°ndo y qu√© emitir.
- `FluxSink<T>`, es una interfaz que act√∫a como puente entre tu c√≥digo imperativo y el mundo reactivo. Es el objeto que
  recibimos en el lambda de `Flux.create()`, y nos permite emitir elementos manualmente a un `Flux`.
- `FluxSink` nos da el control manual de cu√°ndo y c√≥mo se emiten los elementos en un `Flux`.
- `fluxSink.next(...)`, emite un nuevo valor al flujo.
- `fluxSink.complete()`, finaliza la emisi√≥n (completa el flujo).

El ejemplo muestra c√≥mo `Flux.create()` da control completo sobre el proceso de emisi√≥n. Adem√°s, es ideal para demostrar
c√≥mo simular condiciones de parada en flujos program√°ticos.

````bash
18:05:44.769 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Guinea-Bissau
18:05:44.769 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Venezuela (Bolivarian Republic of)
18:05:44.769 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Guinea-Bissau
18:05:44.769 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Samoa
18:05:44.769 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Egypt
18:05:44.769 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Egypt
18:05:44.770 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Greece
18:05:44.770 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Tajikistan
18:05:44.770 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Peru
18:05:44.774 INFO  [           main] d.m.a.common.DefaultSubscriber :  ¬°completado!
````

## Flux Create - Refactor

Podemos refactorizar el c√≥digo anterior implementando el consumer en una clase concreta, tal como se muestra a
continuaci√≥n.

````java
public class NameGenerator implements Consumer<FluxSink<String>> {

    private FluxSink<String> fluxSink;

    @Override
    public void accept(FluxSink<String> fluxSink) {
        this.fluxSink = fluxSink;
    }

    public void generate() {
        this.fluxSink.next(Util.faker().country().name());
    }

    public void complete() {
        this.fluxSink.complete();
    }
}
````

Luego, en nuestra clase principal podemos realizar la siguiente implementaci√≥n donde al `Flux.create(...)` le pasamos
la clase concreta que creamos anteriormente.

````java
public class Lec02FluxCreateRefactor {
    public static void main(String[] args) {
        NameGenerator nameGenerator = new NameGenerator();
        Flux<String> stringFlux = Flux.create(nameGenerator);
        stringFlux.subscribe(Util.subscriber());

        for (int i = 0; i < 10; i++) {
            nameGenerator.generate();
        }
        nameGenerator.complete();
    }
}
````

Si ejecutamos la aplicaci√≥n, obtendremos un resultado similar al siguiente.

````bash
10:30:57.323 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Eritrea
10:30:57.326 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Hungary
10:30:57.327 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Estonia
10:30:57.327 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Syrian Arab Republic
10:30:57.327 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Cambodia
10:30:57.327 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Jamaica
10:30:57.327 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Luxembourg
10:30:57.328 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: India
10:30:57.328 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Seychelles
10:30:57.328 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Finland
10:30:57.331 INFO  [           main] d.m.a.common.DefaultSubscriber :  ¬°completado!
````

## FluxSink - Seguridad del hilo (Thread Safety)

### Demostrando algo que `No es Thread Safe`

Antes de hacer una demostraci√≥n de la seguridad de los hilos de sincronizaci√≥n de flujo, me gustar√≠a hacer una
`demostraci√≥n de algo que NO ES SEGURO para los HILOS`.

````java
public class Lec03FluxSinkThreadSafety {

    private static final Logger log = LoggerFactory.getLogger(Lec03FluxSinkThreadSafety.class);

    public static void main(String[] args) {
        notThreadSafe();
    }

    private static void notThreadSafe() {
        // Un arrayList no es seguro para hilos
        List<Integer> list = new ArrayList<>();

        // Un Runnable es una tarea
        Runnable runnable = () -> {
            for (int i = 0; i < 1000; i++) {
                list.add(i);
            }
        };

        for (int i = 0; i < 10; i++) {
            // En java 17
            // new Thread(runnable).start();

            // En java 21
            Thread.ofPlatform().start(runnable);
        }
        // Como estamos creando m√∫ltiples hilos, puede que tengamos que bloquear el hilo principal durante
        // unos segundos para que todos los hilos puedan hacer su trabajo
        Util.sleepSeconds(3);
        log.info("Tama√±o de la lista: {}", list.size());
    }
}
````

Al ejecutar la aplicaci√≥n vemos el siguiente resultado.

````bash
//10:54:07.056 INFO  [           main] .a.s.Lec03FluxSinkThreadSafety : Tama√±o de la lista: 9147
````

Se supone que deber√≠amos tener `10,000` elementos en la lista, ya que se lanzan `10 hilos`, y cada hilo a√±ade `1,000`
elementos. Sin embargo, al ejecutar la aplicaci√≥n, observamos que el tama√±o de la lista var√≠a: en una ejecuci√≥n puede
mostrar `9147`, en otra `8830`, y as√≠ sucesivamente.

Esto demuestra que obtenemos resultados inconsistentes en cada ejecuci√≥n. La raz√≥n es que `ArrayList`
`no es seguro para m√∫ltiples hilos`, lo cual genera `condiciones de carrera` cuando varios hilos intentan modificar la
lista al mismo tiempo.

### ¬øPor qu√© var√≠a el resultado y es menor?

Cuando varios hilos acceden simult√°neamente a un `ArrayList` y modifican su contenido (por ejemplo, agregando elementos
con `add`), pueden ocurrir `condiciones de carrera` (race conditions).

### ¬øQu√© es una condici√≥n de carrera en este contexto?

Imagina que dos hilos (Hilo A y Hilo B) intentan ejecutar `list.add(i)` casi al mismo tiempo. Internamente, `ArrayList`:

1. Verifica si hay espacio en el arreglo interno.

2. Si hay espacio, coloca el nuevo elemento en la posici√≥n correspondiente.

3. Aumenta el contador de tama√±o (`size++`).

Estos pasos no son at√≥micos, y al no estar sincronizados, pueden interrumpirse mutuamente.

Ejemplo de problema:

- Hilo A y Hilo B verifican al mismo tiempo que hay espacio en la posici√≥n 999.
- Ambos intentan insertar su valor en esa posici√≥n.
- Ambos incrementan el contador `size`.
- Resultado: se perdi√≥ un elemento (uno sobrescribi√≥ al otro), pero el contador `size` puede haberse incrementado
  incorrectamente, o incluso no incrementarse correctamente.

Este tipo de errores hace que:

- Algunos elementos no se agreguen.
- El tama√±o de la lista no refleje la cantidad esperada de elementos.

Y como los hilos se ejecutan en orden impredecible cada vez que corres la app, los errores tambi√©n var√≠an: a veces m√°s,
a veces menos.

### Demostrando lo que `es Thread Safe`

En la demostraci√≥n anterior vimos que un `ArrayList` `no es seguro para m√∫ltiples hilos` (`not thread-safe`). A pesar de
ello, en este ejemplo volveremos a utilizar `ArrayList`, pero esta vez nos aseguraremos de que el acceso concurrente sea
seguro, de forma que al final obtengamos la cantidad esperada de elementos en la lista.

Para lograr esto, utilizamos un `FluxSink`, que es una forma de emitir datos hacia un Flux desde m√∫ltiples hilos. En
implementaciones anteriores creamos un `NameGenerator` que act√∫a como puente entre los productores (los hilos) y los
consumidores (el Flux que agrega los elementos a la lista).

De esta manera, todos los datos se transfieren de forma controlada y segura, utilizando el mecanismo de Reactor. Cada
vez que se genera un dato, se emite de forma secuencial a trav√©s del `FluxSink`, evitando `condiciones de carrera`.

````java
public class Lec03FluxSinkThreadSafety {
    private static final Logger log = LoggerFactory.getLogger(Lec03FluxSinkThreadSafety.class);

    public static void main(String[] args) {
        threadSafe();
    }

    private static void threadSafe() {
        List<String> list = new ArrayList<>();
        NameGenerator nameGenerator = new NameGenerator();
        Flux<String> stringFlux = Flux.create(nameGenerator);
        stringFlux.subscribe(list::add);

        Runnable runnable = () -> {
            for (int i = 0; i < 1000; i++) {
                nameGenerator.generate();
            }
        };

        for (int i = 0; i < 10; i++) {
            Thread.ofPlatform().start(runnable);
        }

        Util.sleepSeconds(3);
        log.info("Tama√±o del list: {}", list.size());
    }
}
````

Cada vez que ejecutemos esta aplicaci√≥n, la lista debe contener exactamente `10,000` elementos:

````bash
11:33:21.545 INFO  [           main] .a.s.Lec03FluxSinkThreadSafety : Tama√±o del list: 10000
````

## Flux Create - Comportamiento predeterminado

`FluxSink` tiene un comportamiento interesante que puede que no nos guste, pero as√≠ es por dise√±o. As√≠ que primero
demostraremos el comportamiento por defecto y luego veremos c√≥mo podemos arreglarlo si queremos cambiar ese
comportamiento.

En el siguiente ejemplo veremos c√≥mo es que el publisher produce todos los elementos por adelantado. Lo que har√° es que
cualquier cosa que hagamos o le demos al m√©todo `next()`, todo ser√° almacenado dentro de una cola ilimitada. Luego, el
subscriber puede obtener esos elementos cuando quiera.

````java
public class Lec04FluxCreateDownstreamDemand {
    private static final Logger log = LoggerFactory.getLogger(Lec04FluxCreateDownstreamDemand.class);

    public static void main(String[] args) {
        produceEarlyDefault();
    }

    private static void produceEarlyDefault() {
        SubscriberImpl subscriber = new SubscriberImpl();

        Flux.<String>create(fluxSink -> {
            for (int i = 0; i < 10; i++) {
                String name = Util.faker().name().firstName();
                log.info("generado: {}", name);
                fluxSink.next(name);
            }
            fluxSink.complete();
        }).subscribe(subscriber);
    }
}
````

Lo que observamos en esta ejecuci√≥n es una demostraci√≥n clara del comportamiento por defecto de `Flux.create()`,
y m√°s espec√≠ficamente, del uso de `FluxSink` cuando no hay una demanda expl√≠cita (`request(n)`) del `Subscriber`.

````bash
11:54:25.406 INFO  [           main] ec04FluxCreateDownstreamDemand : generado: Lupe
11:54:25.410 INFO  [           main] ec04FluxCreateDownstreamDemand : generado: Antione
11:54:25.411 INFO  [           main] ec04FluxCreateDownstreamDemand : generado: Refugio
11:54:25.411 INFO  [           main] ec04FluxCreateDownstreamDemand : generado: Karl
11:54:25.411 INFO  [           main] ec04FluxCreateDownstreamDemand : generado: Chelsea
11:54:25.412 INFO  [           main] ec04FluxCreateDownstreamDemand : generado: Lizeth
11:54:25.412 INFO  [           main] ec04FluxCreateDownstreamDemand : generado: Wes
11:54:25.412 INFO  [           main] ec04FluxCreateDownstreamDemand : generado: Willene
11:54:25.413 INFO  [           main] ec04FluxCreateDownstreamDemand : generado: Titus
11:54:25.413 INFO  [           main] ec04FluxCreateDownstreamDemand : generado: Tami
````

### ¬øQu√© est√° pasando?

- El `publisher` (en este caso el `Flux.create(...)`) emite 10 elementos inmediatamente, sin esperar a que el
  `Subscriber` los solicite.
- Todos estos elementos `se almacenan internamente en una cola sin l√≠mites` (esto es por dise√±o en `Reactor`).
- El `SubscriberImpl` implementa `Subscriber`, pero no llama a `subscription.request(n)` en `onSubscribe(...)`,
  por lo tanto, no hay demanda registrada, y por eso no se procesan los elementos.

El resultado es que vemos, por ejemplo `generado: Lupe` en consola (porque el `publisher` sigue produciendo),
pero no aparece ning√∫n `recibido:` (mensaje del `SubscriberImpl`), ya que el `subscriber` nunca solicit√≥ elementos.
Esto simula un caso real en programaci√≥n reactiva donde si no hay demanda, no se emiten elementos al consumidor.

Este comportamiento ilustra c√≥mo `Reactor` es `push-pull`, es decir, aunque el productor pueda emitir libremente, si el
consumidor no est√° listo (no ha hecho `request()`), los datos se acumulan, pero no se consumen.

Ahora realizamos la solicitud de elementos a consumir `subscription.request(n)`.

````java
public class Lec04FluxCreateDownstreamDemand {
    private static final Logger log = LoggerFactory.getLogger(Lec04FluxCreateDownstreamDemand.class);

    public static void main(String[] args) {
        produceEarlyDefault();
    }

    private static void produceEarlyDefault() {
        SubscriberImpl subscriber = new SubscriberImpl();

        Flux.<String>create(fluxSink -> {
            for (int i = 0; i < 10; i++) {
                String name = Util.faker().name().firstName();
                log.info("generado: {}", name);
                fluxSink.next(name);
            }
            fluxSink.complete();
        }).subscribe(subscriber);

        Util.sleepSeconds(2);
        subscriber.getSubscription().request(2);

        Util.sleepSeconds(2);
        subscriber.getSubscription().request(2);

        Util.sleepSeconds(2);
        subscriber.getSubscription().request(2);
        subscriber.getSubscription().cancel();
    }
}
````

1. El `Publisher` sigue produciendo de inmediato:
    - Aunque el `Subscriber` a√∫n no ha pedido nada, el publisher genera los 10 nombres y los almacena en una cola
      interna.

2. El `Subscriber` **empieza a recibir elementos solo cuando los solicita expl√≠citamente:**
    - Con cada llamada a `subscription.request(n)`, se consumen `n` elementos de la cola.

3. Esto demuestra que la estrategia de `FluxSink` es `push`, pero el consumo es `pull`:
    - El `publisher` empuja datos, pero no se env√≠an al `subscriber` hasta que este los solicita, garantizando control
      sobre el flujo y evitando desbordamientos.

5. El uso de `cancel()` detiene el flujo:
    - Aunque todav√≠a hab√≠a elementos en la cola, se detiene la suscripci√≥n, y ya no se entregar√°n m√°s datos.

Como resultado vemos que cuando se le solicita la cantidad de elementos, el `subscriber` reci√©n las empieza a
obtener desde la cola donde las almacen√≥ previamente.

````bash
12:02:12.042 INFO  [           main] ec04FluxCreateDownstreamDemand : generado: Cole
12:02:12.049 INFO  [           main] ec04FluxCreateDownstreamDemand : generado: Reynaldo
12:02:12.049 INFO  [           main] ec04FluxCreateDownstreamDemand : generado: Vincenzo
12:02:12.049 INFO  [           main] ec04FluxCreateDownstreamDemand : generado: Estefana
12:02:12.050 INFO  [           main] ec04FluxCreateDownstreamDemand : generado: Del
12:02:12.050 INFO  [           main] ec04FluxCreateDownstreamDemand : generado: Margery
12:02:12.050 INFO  [           main] ec04FluxCreateDownstreamDemand : generado: Berniece
12:02:12.050 INFO  [           main] ec04FluxCreateDownstreamDemand : generado: Doyle
12:02:12.051 INFO  [           main] ec04FluxCreateDownstreamDemand : generado: Waltraud
12:02:12.051 INFO  [           main] ec04FluxCreateDownstreamDemand : generado: Sherryl
12:02:14.067 INFO  [           main] d.m.a.p.s.SubscriberImpl       : recibido: Cole
12:02:14.068 INFO  [           main] d.m.a.p.s.SubscriberImpl       : recibido: Reynaldo
12:02:16.081 INFO  [           main] d.m.a.p.s.SubscriberImpl       : recibido: Vincenzo
12:02:16.081 INFO  [           main] d.m.a.p.s.SubscriberImpl       : recibido: Estefana
12:02:18.086 INFO  [           main] d.m.a.p.s.SubscriberImpl       : recibido: Del
12:02:18.086 INFO  [           main] d.m.a.p.s.SubscriberImpl       : recibido: Margery
````

Este patr√≥n es muy √∫til en sistemas que necesitan manejar vol√∫menes altos de datos sin saturar consumidores lentos.
Tambi√©n es clave en la arquitectura reactiva para mantener la estabilidad del sistema.

## Flux Create - Emitir a demanda

En el apartado anterior vimos que el `Flux.create` produce los elementos sin que alguien los haya solicitado,
simplemente los produce y los almacena en una cola. Posteriormente, cuando un `Suscriber` los solicita, pues las obtiene
de la cola previamente almacenada.

En este apartado cambiaremos ese comportamiento por defecto para que el `publisher` √∫nicamente produzca los elementos
bajo demanda, es decir, cuando realmente se le haya solicitado. Para eso realizamos el siguiente ejemplo.

````java
public class Lec04FluxCreateDownstreamDemand {
    private static final Logger log = LoggerFactory.getLogger(Lec04FluxCreateDownstreamDemand.class);

    public static void main(String[] args) {
        produceOnDemand();
    }

    private static void produceOnDemand() {
        SubscriberImpl subscriber = new SubscriberImpl();

        Flux<String> fluxCreate = Flux.create(fluxSink -> {
            fluxSink.onRequest(value -> {
                for (int i = 0; i < value && !fluxSink.isCancelled(); i++) {
                    String name = Util.faker().name().firstName();
                    log.info("generado-onDemand: {}", name);
                    fluxSink.next(name);
                }
            });
        });

        fluxCreate.subscribe(subscriber);
    }
}
````

### Lo que logras con `fluxSink.onRequest(...)`:

1. Desactivamos el comportamiento predeterminado de `‚Äúpre-emisi√≥n‚Äù`:
    - Ya no se generan elementos de inmediato. En cambio, el `Publisher` espera a que el `Subscriber` haga una solicitud
      expl√≠cita (`request(n)`).


2. Producci√≥n bajo demanda real:
    - Tu c√≥digo en `onRequest(value -> {...})` se ejecuta solo cuando hay una solicitud de `n elementos`.
    - Dentro del `loop for (int i = 0; i < value; i++)`, est√°s generando exactamente la cantidad solicitada.


3. Chequeo de cancelaci√≥n:
    - `fluxSink.isCancelled()` asegura que dejes de emitir si el `Subscriber` cancela la suscripci√≥n. Este es un buen
      patr√≥n para evitar trabajo innecesario.


4. Resultado esperado:
    - Como a√∫n no has llamado a `subscriber.getSubscription().request(n)`, el `Publisher` no genera nada, y por eso la
      consola no muestra nada.

Este patr√≥n es ideal para escenarios en los que:

- El costo de producir elementos es alto.
- No quieres desperdiciar recursos generando datos que tal vez nunca ser√°n consumidos.
- Quieres que el `Subscriber` tenga control completo del ritmo del flujo.

Si ejecutamos el c√≥digo anterior, no veremos ninguna salida en consola, eso significa que el `Flux.create()` no est√°
produciendo ning√∫n elemento dado que no se le ha solicitado a√∫n.

````bash
Process finished with exit code 0
````

Si ahora solicitamos elementos, vemos que el `Flux.create(...)` reci√©n empezar√° a producir elementos y los subscribers
a consumirlos.

````java
public class Lec04FluxCreateDownstreamDemand {
    private static final Logger log = LoggerFactory.getLogger(Lec04FluxCreateDownstreamDemand.class);

    public static void main(String[] args) {
        produceOnDemand();
    }

    private static void produceOnDemand() {
        SubscriberImpl subscriber = new SubscriberImpl();

        Flux<String> fluxCreate = Flux.create(fluxSink -> {
            fluxSink.onRequest(value -> {
                for (int i = 0; i < value && !fluxSink.isCancelled(); i++) {
                    String name = Util.faker().name().firstName();
                    log.info("generado-onDemand: {}", name);
                    fluxSink.next(name);
                }
            });
        });

        fluxCreate.subscribe(subscriber);
        subscriber.getSubscription().request(2);
        subscriber.getSubscription().request(2);
        subscriber.getSubscription().cancel();
    }
}
````

1. `request(n)` ‚Üí producci√≥n y consumo inmediato:
    - Cuando el `subscriber` hace una solicitud, `fluxSink.onRequest(...)` se dispara.
    - Se generan exactamente `n elementos` (en tu caso, 2 y luego otros 2).
    - Inmediatamente despu√©s de ser emitidos, los elementos son entregados al `subscriber`, quien los consume uno por
      uno.


2. No hay almacenamiento en buffer:
    - A diferencia del caso anterior (con producci√≥n anticipada), aqu√≠ no se encola nada.
    - Si no hay solicitud, no hay producci√≥n.


3. Cancelaci√≥n efectiva:
    - Tras llamar a `subscriber.getSubscription().cancel()`, cualquier llamada posterior a `request(n)` ser√° ignorada
      porque la suscripci√≥n est√° cancelada.
    - Adem√°s, el `fluxSink.isCancelled()` detiene cualquier producci√≥n en curso si ocurre una cancelaci√≥n en medio de un
      bucle de emisi√≥n.

En el resultado observamos que el elemento generado bajo demanda es autom√°ticamente consumido por el `subscriber`.
Lo que estamos viendo en esta ejecuci√≥n es un comportamiento de `reactive pull`, donde el `subscriber` controla
completamente cu√°ndo y cu√°ntos elementos desea recibir.

````bash
12:51:15.495 INFO  [           main] ec04FluxCreateDownstreamDemand : generado-onDemand: Ira
12:51:15.500 INFO  [           main] d.m.a.p.s.SubscriberImpl       : recibido: Ira
12:51:15.501 INFO  [           main] ec04FluxCreateDownstreamDemand : generado-onDemand: Rosella
12:51:15.501 INFO  [           main] d.m.a.p.s.SubscriberImpl       : recibido: Rosella
12:51:15.502 INFO  [           main] ec04FluxCreateDownstreamDemand : generado-onDemand: Joya
12:51:15.502 INFO  [           main] d.m.a.p.s.SubscriberImpl       : recibido: Joya
12:51:15.502 INFO  [           main] ec04FluxCreateDownstreamDemand : generado-onDemand: Daren
12:51:15.502 INFO  [           main] d.m.a.p.s.SubscriberImpl       : recibido: Daren
````

## FluxSink - Casos de uso

En este apartado hablaremos de algunos aspectos importantes sobre `Flex.create(...)` y `FluxSink`.

- Est√° dise√±ado para usarse con `un √∫nico suscriptor`.
- `FluxSink` es `seguro para subprocesos` (`thread-safe`).
- Podemos seguir emitiendo datos sin preocuparnos por la demanda del suscriptor.
- `FluxSink` entregar√° todos los elementos de forma segura al suscriptor.

### Ejemplo simple de uso de FluxSink

A continuaci√≥n, se muestra un ejemplo sencillo donde m√∫ltiples hilos generan datos aleatorios y los emiten de forma
segura usando `FluxSink`:

````java
public class FluxSinkUseCase {
    public static void main(String[] args) {
        Flux<String> flux = Flux.create(fluxSink -> {
            Runnable runnable = () -> {
                for (int i = 0; i < 5; i++) {
                    fluxSink.next(Thread.currentThread().getName() + " - valor " + i);
                }
            };

            for (int i = 0; i < 3; i++) {
                Thread.ofPlatform().start(runnable);
            }

            // Esperamos un poco para que los hilos terminen de emitir
            try {
                Thread.sleep(1000);
                fluxSink.complete();
            } catch (InterruptedException e) {
                fluxSink.error(e);
            }
        });

        flux.subscribe(System.out::println);
    }
}
````

### ¬øQu√© muestra este ejemplo?

- Usamos `Flux.create(...)` con un `FluxSink` que recibe datos de varios hilos.
- Cada hilo emite 5 valores.
- Los datos se entregan al `suscriptor` en orden de llegada, sin fallos ni duplicados, demostrando que el `FluxSink`
  maneja correctamente la concurrencia.

## Take Operators

### Operador `take()`

El operador `take(n)` se utiliza para limitar la cantidad de elementos emitidos por un `Flux`. Una vez que el `Flux` ha
emitido `n elementos`, se cancela autom√°ticamente la suscripci√≥n aguas arriba (`upstream`), y se completa el flujo.

- Solo permite pasar los primeros `n elementos`.
- Luego de alcanzar ese l√≠mite, el flujo se completa autom√°ticamente.
- Es √∫til para cortar el flujo sin necesidad de condiciones complejas o l√≥gica adicional.

````java
public class Lec05TakeOperator {
    public static void main(String[] args) {
        take();
    }

    private static void take() {
        Flux.range(1, 10)                       // Emitimos los n√∫meros del 1 al 10
                .log("take")                    // Agregamos logging antes del operador
                .take(3)                        // Solo tomamos los primeros 3 elementos
                .log("subs")                    // Logging despu√©s del operador
                .subscribe(Util.subscriber());
    }
}
````

````bash
15:28:57.657 INFO  [           main] take                           : | onSubscribe([Synchronous Fuseable] FluxRange.RangeSubscription)
15:28:57.661 INFO  [           main] subs                           : onSubscribe(FluxLimitRequest.FluxLimitRequestSubscriber)
15:28:57.663 INFO  [           main] subs                           : request(unbounded)
15:28:57.664 INFO  [           main] take                           : | request(3)        // Se solicitan 3 elementos
15:28:57.664 INFO  [           main] take                           : | onNext(1)         // Se emite el primer valor
15:28:57.664 INFO  [           main] subs                           : onNext(1)
15:28:57.664 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 1
15:28:57.664 INFO  [           main] take                           : | onNext(2)         // Segundo valor
15:28:57.665 INFO  [           main] subs                           : onNext(2)
15:28:57.665 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 2
15:28:57.665 INFO  [           main] take                           : | onNext(3)         // Tercer valor
15:28:57.665 INFO  [           main] subs                           : onNext(3)
15:28:57.665 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 3
15:28:57.666 INFO  [           main] take                           : | cancel()          // Al llegar a 3, se cancela la suscripci√≥n upstream
15:28:57.666 INFO  [           main] subs                           : onComplete()        // El flujo se completa
15:28:57.669 INFO  [           main] d.m.a.common.DefaultSubscriber :  ¬°completado!
````

El operador `take(n)` es una forma segura y eficiente de limitar el n√∫mero de elementos que deseamos procesar de un
flujo. No solo detiene la emisi√≥n despu√©s del l√≠mite, sino que tambi√©n libera recursos al cancelar la suscripci√≥n hacia
el origen de datos.

### Operador `takeWhile()`

El operador `takeWhile` permite emitir elementos de un `Flux` mientras se cumpla una condici√≥n determinada.
En cuanto un elemento no cumple la condici√≥n, el flujo se detiene inmediatamente y se cancela la suscripci√≥n.

````java
public class Lec05TakeOperator {
    public static void main(String[] args) {
        takeWhile();
    }

    private static void takeWhile() {
        Flux.range(1, 10)
                .log("take")
                .takeWhile(i -> i < 3)
                .log("subs")
                .subscribe(Util.subscriber());
    }
}
````

- Se genera un `Flux` con los n√∫meros del `1 al 10`.
- Se emiten los elementos `mientras sean menores que 3`.
- Al llegar al n√∫mero 3, como `no cumple la condici√≥n` `i < 3`, el flujo `se cancela inmediatamente`, y no se emiten m√°s
  elementos, incluso si hay m√°s disponibles.
- Se genera el evento `onComplete()` justo despu√©s de cancelar la emisi√≥n.

````bash
15:40:11.549 INFO  [           main] take                           : | onSubscribe([Synchronous Fuseable] FluxRange.RangeSubscription)
15:40:11.552 INFO  [           main] subs                           : onSubscribe(FluxTakeWhile.TakeWhileSubscriber)
15:40:11.553 INFO  [           main] subs                           : request(unbounded)
15:40:11.553 INFO  [           main] take                           : | request(unbounded)
15:40:11.553 INFO  [           main] take                           : | onNext(1)
15:40:11.554 INFO  [           main] subs                           : onNext(1)
15:40:11.554 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 1
15:40:11.554 INFO  [           main] take                           : | onNext(2)
15:40:11.554 INFO  [           main] subs                           : onNext(2)
15:40:11.554 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 2
15:40:11.554 INFO  [           main] take                           : | onNext(3)
15:40:11.554 INFO  [           main] take                           : | cancel()
15:40:11.555 INFO  [           main] subs                           : onComplete()
15:40:11.558 INFO  [           main] d.m.a.common.DefaultSubscriber :  ¬°completado!
````

A diferencia del operador `take(n)`, que limita la cantidad de elementos emitidos, `takeWhile` eval√∫a cada elemento
individualmente en funci√≥n de la condici√≥n, deteni√©ndose en cuanto uno no cumpla.

### Operador `takeUntil()`

El operador `takeUntil` en `Project Reactor` permite emitir elementos desde el `Publisher` original hasta que se cumpla
una condici√≥n booleana (`inclusive`). A diferencia de `takeWhile`, que detiene la emisi√≥n al encontrar un valor que no
cumpla la condici√≥n, `takeUntil` contin√∫a emitiendo hasta que el predicado retorne `true` por primera vez,
e `incluye ese elemento en la secuencia`.

````java
public class Lec05TakeOperator {
    public static void main(String[] args) {
        takeUntil();
    }

    private static void takeUntil() {
        Flux.range(1, 10)
                .log("take")
                .takeUntil(i -> i == 1)
                .log("subs")
                .subscribe(Util.subscriber());
    }
}
````

Vemos que en la salida tenemos al `1` c√≥mo √∫nico elemento emitido del conjunto de elementos que nos proporciona el
`range()`. Esto sucede porque `takeUntil(i -> i == 1)` seguir√° emitiendo hasta que el valor sea `1`, lo incluir√°, y
luego cancelar√° la suscripci√≥n.

````bash
15:47:02.876 INFO  [           main] take                           : | onSubscribe([Synchronous Fuseable] FluxRange.RangeSubscription)
15:47:02.879 INFO  [           main] subs                           : onSubscribe(FluxTakeUntil.TakeUntilPredicateSubscriber)
15:47:02.880 INFO  [           main] subs                           : request(unbounded)
15:47:02.881 INFO  [           main] take                           : | request(unbounded)
15:47:02.881 INFO  [           main] take                           : | onNext(1)
15:47:02.881 INFO  [           main] subs                           : onNext(1)
15:47:02.881 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 1
15:47:02.882 INFO  [           main] take                           : | cancel()
15:47:02.883 INFO  [           main] subs                           : onComplete()
15:47:02.885 INFO  [           main] d.m.a.common.DefaultSubscriber :  ¬°completado!
````

## Flux Generate

`Flux.generate()` es un generador `s√≠ncrono` de datos en `Project Reactor`. Est√° dise√±ado para emitir
`un solo elemento por iteraci√≥n` y es √∫til cuando deseamos tener un control fino sobre qu√© se emite y cu√°ndo se
completa el flujo.

### Restricci√≥n clave:

- Invoca la expresi√≥n lambda dada una y otra vez seg√∫n la demanda posterior.
- Solo se permite una llamada a `.next()` por iteraci√≥n.
- Se detendr√° al invocar el m√©todo `complete`.
- Se detendr√° al invocar el m√©todo de `error`.
- Detendr√° las cancelaciones posteriores.
- Si se intenta emitir m√°s de un valor en una sola llamada (como en el ejemplo), se lanza una excepci√≥n con el mensaje:
  `error: More than one call to onNext`.

Veamos el siguiente ejemplo donde hacemos uso del `Flux.generate()` y tratamos de emitir dos veces usando el `.next()`.

````java
public class Lec06FluxGenerate {
    public static void main(String[] args) {
        Flux.generate(synchronousSink -> {
            synchronousSink.next(1);    // OK
            synchronousSink.next(2);    // ERROR> no est√° permitido
            synchronousSink.complete(); // no se alcanza
        }).subscribe(Util.subscriber());
    }
}
````

Como resultado obtenemos un error al tratar de emitir el segundo elemento con `.next()`.

````bash
16:21:38.731 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 1
16:21:38.736 ERROR [           main] d.m.a.common.DefaultSubscriber :  error: More than one call to onNext
````

Ahora, solo usamos una √∫nica vez el `.next()`.

````java
public class Lec06FluxGenerate {
    public static void main(String[] args) {
        Flux.generate(synchronousSink -> {
            synchronousSink.next(1);
            synchronousSink.complete();
        }).subscribe(Util.subscriber());
    }
}
````

Obtenemos correctamente la emisi√≥n del dato y finalmente el flujo se completa.

````bash
16:22:02.268 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 1
16:22:02.273 INFO  [           main] d.m.a.common.DefaultSubscriber :  ¬°completado!
````

### üìå Comparaci√≥n inicial: Flux.create() vs Flux.generate()

Cuando trabajamos con `Flux.create()`, nosotros controlamos la iteraci√≥n manualmente. Por ejemplo, usamos un bucle for
para emitir un n√∫mero determinado de elementos en funci√≥n de la demanda.

En cambio, con `Flux.generate()` el bucle es gestionado internamente por `Project Reactor`, por lo tanto, *solo se
permite emitir un √∫nico elemento por invocaci√≥n de la funci√≥n lambda*. Esta funci√≥n se ejecuta repetidamente en funci√≥n
de la demanda del suscriptor (`request(n)`).

Veamos el siguiente ejemplo del comportamiento repetitivo controlado por la demanda.

````java
public class Lec06FluxGenerate {
    private static final Logger log = LoggerFactory.getLogger(Lec06FluxGenerate.class);

    public static void main(String[] args) {
        example2();
    }

    private static void example2() {
        Flux.generate(synchronousSink -> {
            log.info("Invocado");
            synchronousSink.next(1);
        }).subscribe(Util.subscriber());
    }
}
````

### üß† Comportamiento

- `Flux.generate()` est√° dise√±ado para emitir **exactamente un elemento por invocaci√≥n de la funci√≥n lambda**.
- No emite autom√°ticamente varios elementos. Cada invocaci√≥n responde a una unidad de demanda (`request(1)`) del
  suscriptor.
- En este caso, `Util.subscriber()` solicita `Long.MAX_VALUE` elementos (demanda infinita), por lo tanto, el generador
  se ejecuta indefinidamente.
- La llamada repetida a `.next(1)` hace que se emita el valor `1` una y otra vez, mientras haya demanda.
- Como no se llama a `complete()`, el flujo nunca termina, y sigue emitiendo.

### ‚ö†Ô∏è Consideraciones

- Si no se controla manualmente un l√≠mite o condici√≥n de parada, el flujo ser√° infinito.
- Ideal para flujos que necesitan una l√≥gica de generaci√≥n personalizada, pero siempre limitada a un solo `onNext()`
  por ciclo.

````bash
3:03.987 INFO  [           main] d.m.a.sec04.Lec06FluxGenerate  : Invocado
16:43:03.987 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 1
16:43:03.987 INFO  [           main] d.m.a.sec04.Lec06FluxGenerate  : Invocado
16:43:03.987 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 1
16:43:03.987 INFO  [           main] d.m.a.sec04.Lec06FluxGenerate  : Invocado
16:43:03.987 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 1
...
````

## Flux Generate - Emitir hasta

En la clase `Lec01FluxCreate` definimos un ejercicio usando `Flux.create()`, el cual consist√≠a en emitir los pa√≠ses de
manera aleatoria hasta que se emita `Per√∫`, cuando eso suceda se debe completar el flujo.

En este apartado realizaremos el mismo ejercicio pero usando el `Flux.generate()`. `Flux.generate()` permite emitir un
√∫nico elemento por iteraci√≥n del `synchronousSink`. Internamente, Reactor gestiona el bucle y solo vuelve a invocar
la lambda cuando el `Subscriber` hace una nueva solicitud (`request(n)`).

El `takeUntil(predicate)` escucha los elementos emitidos y completa el flujo inmediatamente cuando se cumple la
condici√≥n del predicado (en este caso, cuando el pa√≠s es `Per√∫`).

````java
public class Lec07FluxGenerateUntil {
    private static final Logger log = LoggerFactory.getLogger(Lec07FluxGenerateUntil.class);

    public static void main(String[] args) {
        example1();
    }


    private static void example1() {
        Flux<String> generate = Flux.<String>generate(synchronousSink -> {
            String country = Util.faker().country().name();
            synchronousSink.next(country);
        });
        generate.takeUntil(country -> country.equalsIgnoreCase("peru"))
                .subscribe(Util.subscriber());
    }
}
````

### ‚ö†Ô∏è Consideraciones clave

- El `synchronousSink.next(...)` no puede llamarse m√°s de una vez por iteraci√≥n, o se lanza una excepci√≥n.
- Si se usa generate sin condiciones de parada (como `takeUntil` o `complete()`), el flujo ser√° potencialmente infinito
  si el valor de corte nunca se genera.

Si ejecutamos la aplicaci√≥n anterior vemos que por cada iteraci√≥n genera un pa√≠s, luego lo env√≠a por el
`synchronousSink.next(country)`, es decir se est√° haciendo un solo uso de ese m√©todo. La emisi√≥n del flujo finaliza
dado que se cumple la condici√≥n del `takeUntil`.

````bash
17:10:18.134 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Uzbekistan
17:10:18.134 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Iceland
17:10:18.134 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Poland
17:10:18.134 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Peru
17:10:18.138 INFO  [           main] d.m.a.common.DefaultSubscriber :  ¬°completado!
````

Este patr√≥n es √∫til cuando necesitamos generar elementos de manera controlada, uno por uno, en funci√≥n de una condici√≥n
que determine cu√°ndo finalizar la secuencia.

### ‚úÖ Control expl√≠cito del flujo con synchronousSink.complete()

En este segundo enfoque, en lugar de usar el operador `takeUntil`, la finalizaci√≥n del flujo se maneja directamente
dentro de la funci√≥n lambda de `Flux.generate()`.

- Aqu√≠ se evita el uso de `takeUntil`.
- El flujo se completa manualmente cuando se genera el pa√≠s `Per√∫` mediante `synchronousSink.complete()`.

````java
public class Lec07FluxGenerateUntil {
    private static final Logger log = LoggerFactory.getLogger(Lec07FluxGenerateUntil.class);

    public static void main(String[] args) {
        example2();
    }

    private static void example2() {
        Flux.<String>generate(synchronousSink -> {
            String country = Util.faker().country().name();
            synchronousSink.next(country);
            if (country.equalsIgnoreCase("peru")) {
                synchronousSink.complete();
            }

        }).subscribe(Util.subscriber());
    }
}
````

Obtenemos el mismo resultado, se obtiene Peru y se completa el flujo.

````bash
17:22:02.200 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Togo
17:22:02.200 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Egypt
17:22:02.200 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Peru
17:22:02.204 INFO  [           main] d.m.a.common.DefaultSubscriber :  ¬°completado!
````

## Flux Generate - Con proveedor de estado

En ciertos casos, es √∫til mantener un `estado mutable` durante la generaci√≥n de elementos. Para ello, `Reactor`
provee una versi√≥n sobrecargada del m√©todo `Flux.generate()` que permite usar un estado de control.

Esta versi√≥n recibe tres par√°metros:

1. `Supplier<T>` ‚Äì Proporciona un `estado inicial`. Se ejecuta una sola vez, al comenzar el flujo.

2. `BiFunction<T, SynchronousSink<U>, T>` ‚Äì Define la l√≥gica para emitir elementos (`.next()`) y modificar el estado.
   Se ejecuta por cada solicitud de elemento del `Subscriber`.

3. `Consumer<T>` ‚Äì Recibe el √∫ltimo valor del estado cuando el flujo `se completa, cancela o lanza error`. Tambi√©n se
   ejecuta una sola vez.

> üí° `Nota`: El estado puede ser cualquier tipo de objeto, no necesariamente un n√∫mero. Puedes usar colecciones,
> estructuras complejas o clases propias, seg√∫n el requerimiento del flujo.

````java
public class Lec08GenerateWithState {
    private static final Logger log = LoggerFactory.getLogger(Lec08GenerateWithState.class);

    public static void main(String[] args) {
        Flux.generate(
                () -> 0, // Estado inicial: contador = 0
                (counter, synchronousSink) -> {
                    String country = Util.faker().country().name();
                    synchronousSink.next(country);
                    counter++;
                    if (counter == 10 || country.equalsIgnoreCase("peru")) {
                        synchronousSink.complete();
                    }
                    return counter; // Se retorna el nuevo estado
                },
                counter -> log.info("√öltimo valor del contador: {}", counter) // Acci√≥n final con el estado
        ).subscribe(Util.subscriber());
    }
}
````

Una de las condiciones para que se complete el flujo es que se emitan 10 elementos o que el pa√≠s a emitir sea peru, as√≠
que en este caso se cumpli√≥ la primera condici√≥n por eso finaliz√≥ el flujo.

````bash
17:40:50.305 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Russian Federation
17:40:50.309 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Dominica
17:40:50.309 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Iraq
17:40:50.309 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Marshall Islands
17:40:50.310 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: India
17:40:50.310 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: South Africa
17:40:50.310 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: United States of America
17:40:50.310 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Bahamas
17:40:50.310 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Panama
17:40:50.310 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Belgium
17:40:50.313 INFO  [           main] d.m.a.common.DefaultSubscriber :  ¬°completado!
17:40:50.313 INFO  [           main] d.m.a.s.Lec08GenerateWithState : √öltimo valor del contador: 10
````

Esta variante de `generate()` permite controlar la emisi√≥n en funci√≥n de un estado mutable, lo que es √∫til en casos
donde necesitamos realizar un seguimiento, como conteos, acumulaciones o condiciones personalizadas de parada. Adem√°s,
la flexibilidad de permitir cualquier tipo de estado lo hace muy potente para representar l√≥gica compleja de emisi√≥n.

## Tarea asignada

Como parte del ejercicio, se debe implementar la siguiente interfaz:

````java
public interface FileReaderService {
    Flux<String> read(Path path);
}
````

El objetivo es leer el contenido de un archivo y emitirlo l√≠nea por l√≠nea como parte de un flujo `Flux`.

### Consideraciones importantes:

- El procesamiento debe iniciarse solo cuando haya una suscripci√≥n activa.
- El archivo debe leerse en funci√≥n de la demanda del suscriptor.
- La producci√≥n debe detenerse si el suscriptor cancela la suscripci√≥n.
- Se deben emitir √∫nicamente los elementos solicitados.
- El archivo debe cerrarse correctamente una vez finalizado el flujo.

A continuaci√≥n se muestra la soluci√≥n implementada.

````java
public class FileReaderServiceImpl implements FileReaderService {

    private static final Logger log = LoggerFactory.getLogger(FileReaderServiceImpl.class);

    @Override
    public Flux<String> read(Path path) {
        return Flux.generate(
                () -> this.openFile(path),
                this::readFile,
                this::closeFile
        );
    }

    private BufferedReader openFile(Path path) throws IOException {
        log.info("Abriendo archivo");
        return Files.newBufferedReader(path);
    }

    private BufferedReader readFile(BufferedReader reader, SynchronousSink<String> synchronousSink) {
        try {
            String line = reader.readLine();
            log.info("Leyendo l√≠nea: {}", line);

            if (Objects.isNull(line)) {
                synchronousSink.complete();
            } else {
                synchronousSink.next(line);
            }

        } catch (IOException e) {
            synchronousSink.error(e);
        }
        return reader;
    }

    private void closeFile(BufferedReader reader) {
        try {
            log.info("Cerrando archivo");
            reader.close();
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }
}
````

La siguiente clase es la que ejecuta la aplicaci√≥n.

````java
public class Lec09Assignment {
    public static void main(String[] args) {
        Path path = Path.of("src/main/resources/sec04/file.txt");
        FileReaderService fileReaderService = new FileReaderServiceImpl();
        fileReaderService.read(path)
                .take(6)
                .subscribe(Util.subscriber());
    }
}
````

A continuaci√≥n ejecutamos la aplicaci√≥n para que lea el archivo `file.txt` que contiene un total del `500 l√≠neas`,
pero como estamos definiendo el m√©todo `take(6)`, se procesar√°n √∫nicamente 6 l√≠neas.

````bash
10:33:00.317 INFO  [           main] .m.a.s.a.FileReaderServiceImpl : Abriendo archivo
10:33:00.320 INFO  [           main] .m.a.s.a.FileReaderServiceImpl : Leyendo l√≠nea: Line_1
10:33:00.321 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Line_1
10:33:00.321 INFO  [           main] .m.a.s.a.FileReaderServiceImpl : Leyendo l√≠nea: Line_2
10:33:00.321 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Line_2
10:33:00.321 INFO  [           main] .m.a.s.a.FileReaderServiceImpl : Leyendo l√≠nea: Line_3
10:33:00.321 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Line_3
10:33:00.321 INFO  [           main] .m.a.s.a.FileReaderServiceImpl : Leyendo l√≠nea: Line_4
10:33:00.321 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Line_4
10:33:00.321 INFO  [           main] .m.a.s.a.FileReaderServiceImpl : Leyendo l√≠nea: Line_5
10:33:00.321 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Line_5
10:33:00.321 INFO  [           main] .m.a.s.a.FileReaderServiceImpl : Leyendo l√≠nea: Line_6
10:33:00.322 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Line_6
10:33:00.326 INFO  [           main] d.m.a.common.DefaultSubscriber :  ¬°completado!
10:33:00.326 INFO  [           main] .m.a.s.a.FileReaderServiceImpl : Cerrando archivo
````

## Resumen: Flux - create/generate

| Create                                                                                               | Generate                                                                         |
|------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------|
| Acepta un `Consumer<FluxSink<T>>`                                                                    | Acepta un `Consumer<SynchronousSink<T>>`                                         |
| El consumidor se invoca solo una vez.                                                                | El consumidor es invocado una y otra vez.                                        |
| El consumidor puede emitir `0..N elementos` inmediatamente sin preocuparse por la demanda posterior. | El consumidor solo puede emitir un elemento. ¬°Se respeta la demanda aguas abajo! |
| Seguro para subprocesos (`Thread-safe`).                                                             | N/A                                                                              |
