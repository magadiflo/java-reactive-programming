# Sección 4: Flux - Emitiendo items programáticamente

---

## Flux.create() – Emisión imperativa de elementos

En la sección anterior, habíamos hablado de algunas opciones para crear un flujo, por ejemplo a partir de una lista, un
arreglo, etc. Eso es bueno cuando ya tenemos esos tipos en algún lugar del código y podemos crear un flujo a partir de
ahí. Pero probablemente nos falte algo, es decir, nosotros como desarrolladores, necesitamos la capacidad de emitir
un elemento mediante programación, seguir emitiendo datos hasta que se cumpla alguna condición. Para ese escenario
`Reactor` ofrece un par de opciones, eso es lo que veremos en este apartado.

A continuación demostramos cómo crear un `Flux` que emite elementos manualmente mediante programación,
en lugar de usar datos ya existentes.

````java
public class Lec01FluxCreate {
    public static void main(String[] args) {
        Flux.create(fluxSink -> {
            String country;
            do {
                country = Util.faker().country().name();    // genera un país aleatorio
                fluxSink.next(country);                     // emite el país al Flux
            } while (!country.equalsIgnoreCase("Peru"));    // sigue hasta que se emita "Peru"

            fluxSink.complete();                            // indica que el flujo ha terminado
        }).subscribe(Util.subscriber());
    }
}
````

### Donde

- `Flux.create(...)`, crea un `Flux` manualmente usando un `FluxSink`. Nosotros decidimos cuándo y qué emitir.
- `FluxSink<T>`, es una interfaz que actúa como puente entre tu código imperativo y el mundo reactivo. Es el objeto que
  recibimos en el lambda de `Flux.create()`, y nos permite emitir elementos manualmente a un `Flux`.
- `FluxSink` nos da el control manual de cuándo y cómo se emiten los elementos en un `Flux`.
- `fluxSink.next(...)`, emite un nuevo valor al flujo.
- `fluxSink.complete()`, finaliza la emisión (completa el flujo).

El ejemplo muestra cómo `Flux.create()` da control completo sobre el proceso de emisión. Además, es ideal para demostrar
cómo simular condiciones de parada en flujos programáticos.

````bash
18:05:44.769 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Guinea-Bissau
18:05:44.769 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Venezuela (Bolivarian Republic of)
18:05:44.769 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Guinea-Bissau
18:05:44.769 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Samoa
18:05:44.769 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Egypt
18:05:44.769 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Egypt
18:05:44.770 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Greece
18:05:44.770 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Tajikistan
18:05:44.770 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Peru
18:05:44.774 INFO  [           main] d.m.a.common.DefaultSubscriber :  ¡completado!
````

## Flux Create - Refactor

Podemos refactorizar el código anterior implementando el consumer en una clase concreta, tal como se muestra a
continuación.

````java
public class NameGenerator implements Consumer<FluxSink<String>> {

    private FluxSink<String> fluxSink;

    @Override
    public void accept(FluxSink<String> fluxSink) {
        this.fluxSink = fluxSink;
    }

    public void generate() {
        this.fluxSink.next(Util.faker().country().name());
    }

    public void complete() {
        this.fluxSink.complete();
    }
}
````

Luego, en nuestra clase principal podemos realizar la siguiente implementación donde al `Flux.create(...)` le pasamos
la clase concreta que creamos anteriormente.

````java
public class Lec02FluxCreateRefactor {
    public static void main(String[] args) {
        NameGenerator nameGenerator = new NameGenerator();
        Flux<String> stringFlux = Flux.create(nameGenerator);
        stringFlux.subscribe(Util.subscriber());

        for (int i = 0; i < 10; i++) {
            nameGenerator.generate();
        }
        nameGenerator.complete();
    }
}
````

Si ejecutamos la aplicación, obtendremos un resultado similar al siguiente.

````bash
10:30:57.323 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Eritrea
10:30:57.326 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Hungary
10:30:57.327 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Estonia
10:30:57.327 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Syrian Arab Republic
10:30:57.327 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Cambodia
10:30:57.327 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Jamaica
10:30:57.327 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Luxembourg
10:30:57.328 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: India
10:30:57.328 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Seychelles
10:30:57.328 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Finland
10:30:57.331 INFO  [           main] d.m.a.common.DefaultSubscriber :  ¡completado!
````

## FluxSink - Seguridad del hilo (Thread Safety)

### Demostrando algo que `No es Thread Safe`

Antes de hacer una demostración de la seguridad de los hilos de sincronización de flujo, me gustaría hacer una
`demostración de algo que NO ES SEGURO para los HILOS`.

````java
public class Lec03FluxSinkThreadSafety {

    private static final Logger log = LoggerFactory.getLogger(Lec03FluxSinkThreadSafety.class);

    public static void main(String[] args) {
        notThreadSafe();
    }

    private static void notThreadSafe() {
        // Un arrayList no es seguro para hilos
        List<Integer> list = new ArrayList<>();

        // Un Runnable es una tarea
        Runnable runnable = () -> {
            for (int i = 0; i < 1000; i++) {
                list.add(i);
            }
        };

        for (int i = 0; i < 10; i++) {
            // En java 17
            // new Thread(runnable).start();

            // En java 21
            Thread.ofPlatform().start(runnable);
        }
        // Como estamos creando múltiples hilos, puede que tengamos que bloquear el hilo principal durante
        // unos segundos para que todos los hilos puedan hacer su trabajo
        Util.sleepSeconds(3);
        log.info("Tamaño de la lista: {}", list.size());
    }
}
````

Al ejecutar la aplicación vemos el siguiente resultado.

````bash
//10:54:07.056 INFO  [           main] .a.s.Lec03FluxSinkThreadSafety : Tamaño de la lista: 9147
````

Se supone que deberíamos tener `10,000` elementos en la lista, ya que se lanzan `10 hilos`, y cada hilo añade `1,000`
elementos. Sin embargo, al ejecutar la aplicación, observamos que el tamaño de la lista varía: en una ejecución puede
mostrar `9147`, en otra `8830`, y así sucesivamente.

Esto demuestra que obtenemos resultados inconsistentes en cada ejecución. La razón es que `ArrayList`
`no es seguro para múltiples hilos`, lo cual genera `condiciones de carrera` cuando varios hilos intentan modificar la
lista al mismo tiempo.

### ¿Por qué varía el resultado y es menor?

Cuando varios hilos acceden simultáneamente a un `ArrayList` y modifican su contenido (por ejemplo, agregando elementos
con `add`), pueden ocurrir `condiciones de carrera` (race conditions).

### ¿Qué es una condición de carrera en este contexto?

Imagina que dos hilos (Hilo A y Hilo B) intentan ejecutar `list.add(i)` casi al mismo tiempo. Internamente, `ArrayList`:

1. Verifica si hay espacio en el arreglo interno.

2. Si hay espacio, coloca el nuevo elemento en la posición correspondiente.

3. Aumenta el contador de tamaño (`size++`).

Estos pasos no son atómicos, y al no estar sincronizados, pueden interrumpirse mutuamente.

Ejemplo de problema:

- Hilo A y Hilo B verifican al mismo tiempo que hay espacio en la posición 999.
- Ambos intentan insertar su valor en esa posición.
- Ambos incrementan el contador `size`.
- Resultado: se perdió un elemento (uno sobrescribió al otro), pero el contador `size` puede haberse incrementado
  incorrectamente, o incluso no incrementarse correctamente.

Este tipo de errores hace que:

- Algunos elementos no se agreguen.
- El tamaño de la lista no refleje la cantidad esperada de elementos.

Y como los hilos se ejecutan en orden impredecible cada vez que corres la app, los errores también varían: a veces más,
a veces menos.

### Demostrando lo que `es Thread Safe`

En la demostración anterior vimos que un `ArrayList` `no es seguro para múltiples hilos` (`not thread-safe`). A pesar de
ello, en este ejemplo volveremos a utilizar `ArrayList`, pero esta vez nos aseguraremos de que el acceso concurrente sea
seguro, de forma que al final obtengamos la cantidad esperada de elementos en la lista.

Para lograr esto, utilizamos un `FluxSink`, que es una forma de emitir datos hacia un Flux desde múltiples hilos. En
implementaciones anteriores creamos un `NameGenerator` que actúa como puente entre los productores (los hilos) y los
consumidores (el Flux que agrega los elementos a la lista).

De esta manera, todos los datos se transfieren de forma controlada y segura, utilizando el mecanismo de Reactor. Cada
vez que se genera un dato, se emite de forma secuencial a través del `FluxSink`, evitando `condiciones de carrera`.

````java
public class Lec03FluxSinkThreadSafety {
    private static final Logger log = LoggerFactory.getLogger(Lec03FluxSinkThreadSafety.class);

    public static void main(String[] args) {
        threadSafe();
    }

    private static void threadSafe() {
        List<String> list = new ArrayList<>();
        NameGenerator nameGenerator = new NameGenerator();
        Flux<String> stringFlux = Flux.create(nameGenerator);
        stringFlux.subscribe(list::add);

        Runnable runnable = () -> {
            for (int i = 0; i < 1000; i++) {
                nameGenerator.generate();
            }
        };

        for (int i = 0; i < 10; i++) {
            Thread.ofPlatform().start(runnable);
        }

        Util.sleepSeconds(3);
        log.info("Tamaño del list: {}", list.size());
    }
}
````

Cada vez que ejecutemos esta aplicación, la lista debe contener exactamente `10,000` elementos:

````bash
11:33:21.545 INFO  [           main] .a.s.Lec03FluxSinkThreadSafety : Tamaño del list: 10000
````

## Flux Create - Comportamiento predeterminado

`FluxSink` tiene un comportamiento interesante que puede que no nos guste, pero así es por diseño. Así que primero
demostraremos el comportamiento por defecto y luego veremos cómo podemos arreglarlo si queremos cambiar ese
comportamiento.

En el siguiente ejemplo veremos cómo es que el publisher produce todos los elementos por adelantado. Lo que hará es que
cualquier cosa que hagamos o le demos al método `next()`, todo será almacenado dentro de una cola ilimitada. Luego, el
subscriber puede obtener esos elementos cuando quiera.

````java
public class Lec04FluxCreateDownstreamDemand {
    private static final Logger log = LoggerFactory.getLogger(Lec04FluxCreateDownstreamDemand.class);

    public static void main(String[] args) {
        produceEarlyDefault();
    }

    private static void produceEarlyDefault() {
        SubscriberImpl subscriber = new SubscriberImpl();

        Flux.<String>create(fluxSink -> {
            for (int i = 0; i < 10; i++) {
                String name = Util.faker().name().firstName();
                log.info("generado: {}", name);
                fluxSink.next(name);
            }
            fluxSink.complete();
        }).subscribe(subscriber);
    }
}
````

Lo que observamos en esta ejecución es una demostración clara del comportamiento por defecto de `Flux.create()`,
y más específicamente, del uso de `FluxSink` cuando no hay una demanda explícita (`request(n)`) del `Subscriber`.

````bash
11:54:25.406 INFO  [           main] ec04FluxCreateDownstreamDemand : generado: Lupe
11:54:25.410 INFO  [           main] ec04FluxCreateDownstreamDemand : generado: Antione
11:54:25.411 INFO  [           main] ec04FluxCreateDownstreamDemand : generado: Refugio
11:54:25.411 INFO  [           main] ec04FluxCreateDownstreamDemand : generado: Karl
11:54:25.411 INFO  [           main] ec04FluxCreateDownstreamDemand : generado: Chelsea
11:54:25.412 INFO  [           main] ec04FluxCreateDownstreamDemand : generado: Lizeth
11:54:25.412 INFO  [           main] ec04FluxCreateDownstreamDemand : generado: Wes
11:54:25.412 INFO  [           main] ec04FluxCreateDownstreamDemand : generado: Willene
11:54:25.413 INFO  [           main] ec04FluxCreateDownstreamDemand : generado: Titus
11:54:25.413 INFO  [           main] ec04FluxCreateDownstreamDemand : generado: Tami
````

### ¿Qué está pasando?

- El `publisher` (en este caso el `Flux.create(...)`) emite 10 elementos inmediatamente, sin esperar a que el
  `Subscriber` los solicite.
- Todos estos elementos `se almacenan internamente en una cola sin límites` (esto es por diseño en `Reactor`).
- El `SubscriberImpl` implementa `Subscriber`, pero no llama a `subscription.request(n)` en `onSubscribe(...)`,
  por lo tanto, no hay demanda registrada, y por eso no se procesan los elementos.

El resultado es que vemos, por ejemplo `generado: Lupe` en consola (porque el `publisher` sigue produciendo),
pero no aparece ningún `recibido:` (mensaje del `SubscriberImpl`), ya que el `subscriber` nunca solicitó elementos.
Esto simula un caso real en programación reactiva donde si no hay demanda, no se emiten elementos al consumidor.

Este comportamiento ilustra cómo `Reactor` es `push-pull`, es decir, aunque el productor pueda emitir libremente, si el
consumidor no está listo (no ha hecho `request()`), los datos se acumulan, pero no se consumen.

Ahora realizamos la solicitud de elementos a consumir `subscription.request(n)`.

````java
public class Lec04FluxCreateDownstreamDemand {
    private static final Logger log = LoggerFactory.getLogger(Lec04FluxCreateDownstreamDemand.class);

    public static void main(String[] args) {
        produceEarlyDefault();
    }

    private static void produceEarlyDefault() {
        SubscriberImpl subscriber = new SubscriberImpl();

        Flux.<String>create(fluxSink -> {
            for (int i = 0; i < 10; i++) {
                String name = Util.faker().name().firstName();
                log.info("generado: {}", name);
                fluxSink.next(name);
            }
            fluxSink.complete();
        }).subscribe(subscriber);

        Util.sleepSeconds(2);
        subscriber.getSubscription().request(2);

        Util.sleepSeconds(2);
        subscriber.getSubscription().request(2);

        Util.sleepSeconds(2);
        subscriber.getSubscription().request(2);
        subscriber.getSubscription().cancel();
    }
}
````

1. El `Publisher` sigue produciendo de inmediato:
    - Aunque el `Subscriber` aún no ha pedido nada, el publisher genera los 10 nombres y los almacena en una cola
      interna.

2. El `Subscriber` **empieza a recibir elementos solo cuando los solicita explícitamente:**
    - Con cada llamada a `subscription.request(n)`, se consumen `n` elementos de la cola.

3. Esto demuestra que la estrategia de `FluxSink` es `push`, pero el consumo es `pull`:
    - El `publisher` empuja datos, pero no se envían al `subscriber` hasta que este los solicita, garantizando control
      sobre el flujo y evitando desbordamientos.

5. El uso de `cancel()` detiene el flujo:
    - Aunque todavía había elementos en la cola, se detiene la suscripción, y ya no se entregarán más datos.

Como resultado vemos que cuando se le solicita la cantidad de elementos, el `subscriber` recién las empieza a
obtener desde la cola donde las almacenó previamente.

````bash
12:02:12.042 INFO  [           main] ec04FluxCreateDownstreamDemand : generado: Cole
12:02:12.049 INFO  [           main] ec04FluxCreateDownstreamDemand : generado: Reynaldo
12:02:12.049 INFO  [           main] ec04FluxCreateDownstreamDemand : generado: Vincenzo
12:02:12.049 INFO  [           main] ec04FluxCreateDownstreamDemand : generado: Estefana
12:02:12.050 INFO  [           main] ec04FluxCreateDownstreamDemand : generado: Del
12:02:12.050 INFO  [           main] ec04FluxCreateDownstreamDemand : generado: Margery
12:02:12.050 INFO  [           main] ec04FluxCreateDownstreamDemand : generado: Berniece
12:02:12.050 INFO  [           main] ec04FluxCreateDownstreamDemand : generado: Doyle
12:02:12.051 INFO  [           main] ec04FluxCreateDownstreamDemand : generado: Waltraud
12:02:12.051 INFO  [           main] ec04FluxCreateDownstreamDemand : generado: Sherryl
12:02:14.067 INFO  [           main] d.m.a.p.s.SubscriberImpl       : recibido: Cole
12:02:14.068 INFO  [           main] d.m.a.p.s.SubscriberImpl       : recibido: Reynaldo
12:02:16.081 INFO  [           main] d.m.a.p.s.SubscriberImpl       : recibido: Vincenzo
12:02:16.081 INFO  [           main] d.m.a.p.s.SubscriberImpl       : recibido: Estefana
12:02:18.086 INFO  [           main] d.m.a.p.s.SubscriberImpl       : recibido: Del
12:02:18.086 INFO  [           main] d.m.a.p.s.SubscriberImpl       : recibido: Margery
````

Este patrón es muy útil en sistemas que necesitan manejar volúmenes altos de datos sin saturar consumidores lentos.
También es clave en la arquitectura reactiva para mantener la estabilidad del sistema.

## Flux Create - Emitir a demanda

En el apartado anterior vimos que el `Flux.create` produce los elementos sin que alguien los haya solicitado,
simplemente los produce y los almacena en una cola. Posteriormente, cuando un `Suscriber` los solicita, pues las obtiene
de la cola previamente almacenada.

En este apartado cambiaremos ese comportamiento por defecto para que el `publisher` únicamente produzca los elementos
bajo demanda, es decir, cuando realmente se le haya solicitado. Para eso realizamos el siguiente ejemplo.

````java
public class Lec04FluxCreateDownstreamDemand {
    private static final Logger log = LoggerFactory.getLogger(Lec04FluxCreateDownstreamDemand.class);

    public static void main(String[] args) {
        produceOnDemand();
    }

    private static void produceOnDemand() {
        SubscriberImpl subscriber = new SubscriberImpl();

        Flux<String> fluxCreate = Flux.create(fluxSink -> {
            fluxSink.onRequest(value -> {
                for (int i = 0; i < value && !fluxSink.isCancelled(); i++) {
                    String name = Util.faker().name().firstName();
                    log.info("generado-onDemand: {}", name);
                    fluxSink.next(name);
                }
            });
        });

        fluxCreate.subscribe(subscriber);
    }
}
````

### Lo que logras con `fluxSink.onRequest(...)`:

1. Desactivamos el comportamiento predeterminado de `“pre-emisión”`:
    - Ya no se generan elementos de inmediato. En cambio, el `Publisher` espera a que el `Subscriber` haga una solicitud
      explícita (`request(n)`).


2. Producción bajo demanda real:
    - Tu código en `onRequest(value -> {...})` se ejecuta solo cuando hay una solicitud de `n elementos`.
    - Dentro del `loop for (int i = 0; i < value; i++)`, estás generando exactamente la cantidad solicitada.


3. Chequeo de cancelación:
    - `fluxSink.isCancelled()` asegura que dejes de emitir si el `Subscriber` cancela la suscripción. Este es un buen
      patrón para evitar trabajo innecesario.


4. Resultado esperado:
    - Como aún no has llamado a `subscriber.getSubscription().request(n)`, el `Publisher` no genera nada, y por eso la
      consola no muestra nada.

Este patrón es ideal para escenarios en los que:

- El costo de producir elementos es alto.
- No quieres desperdiciar recursos generando datos que tal vez nunca serán consumidos.
- Quieres que el `Subscriber` tenga control completo del ritmo del flujo.

Si ejecutamos el código anterior, no veremos ninguna salida en consola, eso significa que el `Flux.create()` no está
produciendo ningún elemento dado que no se le ha solicitado aún.

````bash
Process finished with exit code 0
````

Si ahora solicitamos elementos, vemos que el `Flux.create(...)` recién empezará a producir elementos y los subscribers
a consumirlos.

````java
public class Lec04FluxCreateDownstreamDemand {
    private static final Logger log = LoggerFactory.getLogger(Lec04FluxCreateDownstreamDemand.class);

    public static void main(String[] args) {
        produceOnDemand();
    }

    private static void produceOnDemand() {
        SubscriberImpl subscriber = new SubscriberImpl();

        Flux<String> fluxCreate = Flux.create(fluxSink -> {
            fluxSink.onRequest(value -> {
                for (int i = 0; i < value && !fluxSink.isCancelled(); i++) {
                    String name = Util.faker().name().firstName();
                    log.info("generado-onDemand: {}", name);
                    fluxSink.next(name);
                }
            });
        });

        fluxCreate.subscribe(subscriber);
        subscriber.getSubscription().request(2);
        subscriber.getSubscription().request(2);
        subscriber.getSubscription().cancel();
    }
}
````

1. `request(n)` → producción y consumo inmediato:
    - Cuando el `subscriber` hace una solicitud, `fluxSink.onRequest(...)` se dispara.
    - Se generan exactamente `n elementos` (en tu caso, 2 y luego otros 2).
    - Inmediatamente después de ser emitidos, los elementos son entregados al `subscriber`, quien los consume uno por
      uno.


2. No hay almacenamiento en buffer:
    - A diferencia del caso anterior (con producción anticipada), aquí no se encola nada.
    - Si no hay solicitud, no hay producción.


3. Cancelación efectiva:
    - Tras llamar a `subscriber.getSubscription().cancel()`, cualquier llamada posterior a `request(n)` será ignorada
      porque la suscripción está cancelada.
    - Además, el `fluxSink.isCancelled()` detiene cualquier producción en curso si ocurre una cancelación en medio de un
      bucle de emisión.

En el resultado observamos que el elemento generado bajo demanda es automáticamente consumido por el `subscriber`.
Lo que estamos viendo en esta ejecución es un comportamiento de `reactive pull`, donde el `subscriber` controla
completamente cuándo y cuántos elementos desea recibir.

````bash
12:51:15.495 INFO  [           main] ec04FluxCreateDownstreamDemand : generado-onDemand: Ira
12:51:15.500 INFO  [           main] d.m.a.p.s.SubscriberImpl       : recibido: Ira
12:51:15.501 INFO  [           main] ec04FluxCreateDownstreamDemand : generado-onDemand: Rosella
12:51:15.501 INFO  [           main] d.m.a.p.s.SubscriberImpl       : recibido: Rosella
12:51:15.502 INFO  [           main] ec04FluxCreateDownstreamDemand : generado-onDemand: Joya
12:51:15.502 INFO  [           main] d.m.a.p.s.SubscriberImpl       : recibido: Joya
12:51:15.502 INFO  [           main] ec04FluxCreateDownstreamDemand : generado-onDemand: Daren
12:51:15.502 INFO  [           main] d.m.a.p.s.SubscriberImpl       : recibido: Daren
````

## FluxSink - Casos de uso

En este apartado hablaremos de algunos aspectos importantes sobre `Flex.create(...)` y `FluxSink`.

- Está diseñado para usarse con `un único suscriptor`.
- `FluxSink` es `seguro para subprocesos` (`thread-safe`).
- Podemos seguir emitiendo datos sin preocuparnos por la demanda del suscriptor.
- `FluxSink` entregará todos los elementos de forma segura al suscriptor.

### Ejemplo simple de uso de FluxSink

A continuación, se muestra un ejemplo sencillo donde múltiples hilos generan datos aleatorios y los emiten de forma
segura usando `FluxSink`:

````java
public class FluxSinkUseCase {
    public static void main(String[] args) {
        Flux<String> flux = Flux.create(fluxSink -> {
            Runnable runnable = () -> {
                for (int i = 0; i < 5; i++) {
                    fluxSink.next(Thread.currentThread().getName() + " - valor " + i);
                }
            };

            for (int i = 0; i < 3; i++) {
                Thread.ofPlatform().start(runnable);
            }

            // Esperamos un poco para que los hilos terminen de emitir
            try {
                Thread.sleep(1000);
                fluxSink.complete();
            } catch (InterruptedException e) {
                fluxSink.error(e);
            }
        });

        flux.subscribe(System.out::println);
    }
}
````

### ¿Qué muestra este ejemplo?

- Usamos `Flux.create(...)` con un `FluxSink` que recibe datos de varios hilos.
- Cada hilo emite 5 valores.
- Los datos se entregan al `suscriptor` en orden de llegada, sin fallos ni duplicados, demostrando que el `FluxSink`
  maneja correctamente la concurrencia.

## Take Operators

### Operador `take()`

El operador `take(n)` se utiliza para limitar la cantidad de elementos emitidos por un `Flux`. Una vez que el `Flux` ha
emitido `n elementos`, se cancela automáticamente la suscripción aguas arriba (`upstream`), y se completa el flujo.

- Solo permite pasar los primeros `n elementos`.
- Luego de alcanzar ese límite, el flujo se completa automáticamente.
- Es útil para cortar el flujo sin necesidad de condiciones complejas o lógica adicional.

````java
public class Lec05TakeOperator {
    public static void main(String[] args) {
        take();
    }

    private static void take() {
        Flux.range(1, 10)                       // Emitimos los números del 1 al 10
                .log("take")                    // Agregamos logging antes del operador
                .take(3)                        // Solo tomamos los primeros 3 elementos
                .log("subs")                    // Logging después del operador
                .subscribe(Util.subscriber());
    }
}
````

````bash
15:28:57.657 INFO  [           main] take                           : | onSubscribe([Synchronous Fuseable] FluxRange.RangeSubscription)
15:28:57.661 INFO  [           main] subs                           : onSubscribe(FluxLimitRequest.FluxLimitRequestSubscriber)
15:28:57.663 INFO  [           main] subs                           : request(unbounded)
15:28:57.664 INFO  [           main] take                           : | request(3)        // Se solicitan 3 elementos
15:28:57.664 INFO  [           main] take                           : | onNext(1)         // Se emite el primer valor
15:28:57.664 INFO  [           main] subs                           : onNext(1)
15:28:57.664 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 1
15:28:57.664 INFO  [           main] take                           : | onNext(2)         // Segundo valor
15:28:57.665 INFO  [           main] subs                           : onNext(2)
15:28:57.665 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 2
15:28:57.665 INFO  [           main] take                           : | onNext(3)         // Tercer valor
15:28:57.665 INFO  [           main] subs                           : onNext(3)
15:28:57.665 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 3
15:28:57.666 INFO  [           main] take                           : | cancel()          // Al llegar a 3, se cancela la suscripción upstream
15:28:57.666 INFO  [           main] subs                           : onComplete()        // El flujo se completa
15:28:57.669 INFO  [           main] d.m.a.common.DefaultSubscriber :  ¡completado!
````

El operador `take(n)` es una forma segura y eficiente de limitar el número de elementos que deseamos procesar de un
flujo. No solo detiene la emisión después del límite, sino que también libera recursos al cancelar la suscripción hacia
el origen de datos.

### Operador `takeWhile()`

El operador `takeWhile` permite emitir elementos de un `Flux` mientras se cumpla una condición determinada.
En cuanto un elemento no cumple la condición, el flujo se detiene inmediatamente y se cancela la suscripción.

````java
public class Lec05TakeOperator {
    public static void main(String[] args) {
        takeWhile();
    }

    private static void takeWhile() {
        Flux.range(1, 10)
                .log("take")
                .takeWhile(i -> i < 3)
                .log("subs")
                .subscribe(Util.subscriber());
    }
}
````

- Se genera un `Flux` con los números del `1 al 10`.
- Se emiten los elementos `mientras sean menores que 3`.
- Al llegar al número 3, como `no cumple la condición` `i < 3`, el flujo `se cancela inmediatamente`, y no se emiten más
  elementos, incluso si hay más disponibles.
- Se genera el evento `onComplete()` justo después de cancelar la emisión.

````bash
15:40:11.549 INFO  [           main] take                           : | onSubscribe([Synchronous Fuseable] FluxRange.RangeSubscription)
15:40:11.552 INFO  [           main] subs                           : onSubscribe(FluxTakeWhile.TakeWhileSubscriber)
15:40:11.553 INFO  [           main] subs                           : request(unbounded)
15:40:11.553 INFO  [           main] take                           : | request(unbounded)
15:40:11.553 INFO  [           main] take                           : | onNext(1)
15:40:11.554 INFO  [           main] subs                           : onNext(1)
15:40:11.554 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 1
15:40:11.554 INFO  [           main] take                           : | onNext(2)
15:40:11.554 INFO  [           main] subs                           : onNext(2)
15:40:11.554 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 2
15:40:11.554 INFO  [           main] take                           : | onNext(3)
15:40:11.554 INFO  [           main] take                           : | cancel()
15:40:11.555 INFO  [           main] subs                           : onComplete()
15:40:11.558 INFO  [           main] d.m.a.common.DefaultSubscriber :  ¡completado!
````

A diferencia del operador `take(n)`, que limita la cantidad de elementos emitidos, `takeWhile` evalúa cada elemento
individualmente en función de la condición, deteniéndose en cuanto uno no cumpla.
