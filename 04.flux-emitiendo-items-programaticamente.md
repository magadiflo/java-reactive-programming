# Sección 4: Flux - Emitiendo items programáticamente

---

## Flux.create() – Emisión imperativa de elementos

En la sección anterior, habíamos hablado de algunas opciones para crear un flujo, por ejemplo a partir de una lista, un
arreglo, etc. Eso es bueno cuando ya tenemos esos tipos en algún lugar del código y podemos crear un flujo a partir de
ahí. Pero probablemente nos falte algo, es decir, nosotros como desarrolladores, necesitamos la capacidad de emitir
un elemento mediante programación, seguir emitiendo datos hasta que se cumpla alguna condición. Para ese escenario
`Reactor` ofrece un par de opciones, eso es lo que veremos en este apartado.

A continuación demostramos cómo crear un `Flux` que emite elementos manualmente mediante programación,
en lugar de usar datos ya existentes.

````java
public class Lec01FluxCreate {
    public static void main(String[] args) {
        Flux.create(fluxSink -> {
            String country;
            do {
                country = Util.faker().country().name();    // genera un país aleatorio
                fluxSink.next(country);                     // emite el país al Flux
            } while (!country.equalsIgnoreCase("Peru"));    // sigue hasta que se emita "Peru"

            fluxSink.complete();                            // indica que el flujo ha terminado
        }).subscribe(Util.subscriber());
    }
}
````

### Donde

- `Flux.create(...)`, crea un `Flux` manualmente usando un `FluxSink`. Nosotros decidimos cuándo y qué emitir.
- `FluxSink<T>`, es una interfaz que actúa como puente entre tu código imperativo y el mundo reactivo. Es el objeto que
  recibimos en el lambda de `Flux.create()`, y nos permite emitir elementos manualmente a un `Flux`.
- `FluxSink` nos da el control manual de cuándo y cómo se emiten los elementos en un `Flux`.
- `fluxSink.next(...)`, emite un nuevo valor al flujo.
- `fluxSink.complete()`, finaliza la emisión (completa el flujo).

El ejemplo muestra cómo `Flux.create()` da control completo sobre el proceso de emisión. Además, es ideal para demostrar
cómo simular condiciones de parada en flujos programáticos.

````bash
18:05:44.769 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Guinea-Bissau
18:05:44.769 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Venezuela (Bolivarian Republic of)
18:05:44.769 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Guinea-Bissau
18:05:44.769 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Samoa
18:05:44.769 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Egypt
18:05:44.769 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Egypt
18:05:44.770 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Greece
18:05:44.770 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Tajikistan
18:05:44.770 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Peru
18:05:44.774 INFO  [           main] d.m.a.common.DefaultSubscriber :  ¡completado!
````

## Flux Create - Refactor

Podemos refactorizar el código anterior implementando el consumer en una clase concreta, tal como se muestra a
continuación.

````java
public class NameGenerator implements Consumer<FluxSink<String>> {

    private FluxSink<String> fluxSink;

    @Override
    public void accept(FluxSink<String> fluxSink) {
        this.fluxSink = fluxSink;
    }

    public void generate() {
        this.fluxSink.next(Util.faker().country().name());
    }

    public void complete() {
        this.fluxSink.complete();
    }
}
````

Luego, en nuestra clase principal podemos realizar la siguiente implementación donde al `Flux.create(...)` le pasamos
la clase concreta que creamos anteriormente.

````java
public class Lec02FluxCreateRefactor {
    public static void main(String[] args) {
        NameGenerator nameGenerator = new NameGenerator();
        Flux<String> stringFlux = Flux.create(nameGenerator);
        stringFlux.subscribe(Util.subscriber());

        for (int i = 0; i < 10; i++) {
            nameGenerator.generate();
        }
        nameGenerator.complete();
    }
}
````

Si ejecutamos la aplicación, obtendremos un resultado similar al siguiente.

````bash
10:30:57.323 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Eritrea
10:30:57.326 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Hungary
10:30:57.327 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Estonia
10:30:57.327 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Syrian Arab Republic
10:30:57.327 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Cambodia
10:30:57.327 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Jamaica
10:30:57.327 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Luxembourg
10:30:57.328 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: India
10:30:57.328 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Seychelles
10:30:57.328 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Finland
10:30:57.331 INFO  [           main] d.m.a.common.DefaultSubscriber :  ¡completado!
````

## FluxSink - Seguridad del hilo (Thread Safety)

Antes de hacer una demostración de la seguridad de los hilos de sincronización de flujo, me gustaría hacer una
`demostración de algo que NO ES SEGURO para los HILOS`.

````java
public class Lec03FluxSinkThreadSafety {

    private static final Logger log = LoggerFactory.getLogger(Lec03FluxSinkThreadSafety.class);

    public static void main(String[] args) {
        notThreadSafe();
    }

    private static void notThreadSafe() {
        // Un arrayList no es seguro para hilos
        List<Integer> list = new ArrayList<>();

        // Un Runnable es una tarea
        Runnable runnable = () -> {
            for (int i = 0; i < 1000; i++) {
                list.add(i);
            }
        };

        for (int i = 0; i < 10; i++) {
            // En java 17
            // new Thread(runnable).start();

            // En java 21
            Thread.ofPlatform().start(runnable);
        }
        // Como estamos creando múltiples hilos, puede que tengamos que bloquear el hilo principal durante
        // unos segundos para que todos los hilos puedan hacer su trabajo
        Util.sleepSeconds(3);
        log.info("Tamaño de la lista: {}", list.size());
    }
}
````

Al ejecutar la aplicación vemos el siguiente resultado.

````bash
//10:54:07.056 INFO  [           main] .a.s.Lec03FluxSinkThreadSafety : Tamaño de la lista: 9147
````

Se supone que deberíamos tener `10,000` elementos en la lista, ya que se lanzan `10 hilos`, y cada hilo añade `1,000`
elementos. Sin embargo, al ejecutar la aplicación, observamos que el tamaño de la lista varía: en una ejecución puede
mostrar `9147`, en otra `8830`, y así sucesivamente.

Esto demuestra que obtenemos resultados inconsistentes en cada ejecución. La razón es que `ArrayList`
`no es seguro para múltiples hilos`, lo cual genera `condiciones de carrera` cuando varios hilos intentan modificar la
lista al mismo tiempo.

### ¿Por qué varía el resultado y es menor?

Cuando varios hilos acceden simultáneamente a un `ArrayList` y modifican su contenido (por ejemplo, agregando elementos
con `add`), pueden ocurrir `condiciones de carrera` (race conditions).

### ¿Qué es una condición de carrera en este contexto?

Imagina que dos hilos (Hilo A y Hilo B) intentan ejecutar `list.add(i)` casi al mismo tiempo. Internamente, `ArrayList`:

1. Verifica si hay espacio en el arreglo interno.

2. Si hay espacio, coloca el nuevo elemento en la posición correspondiente.

3. Aumenta el contador de tamaño (`size++`).

Estos pasos no son atómicos, y al no estar sincronizados, pueden interrumpirse mutuamente.

Ejemplo de problema:

- Hilo A y Hilo B verifican al mismo tiempo que hay espacio en la posición 999.
- Ambos intentan insertar su valor en esa posición.
- Ambos incrementan el contador `size`.
- Resultado: se perdió un elemento (uno sobrescribió al otro), pero el contador `size` puede haberse incrementado
  incorrectamente, o incluso no incrementarse correctamente.

Este tipo de errores hace que:

- Algunos elementos no se agreguen.
- El tamaño de la lista no refleje la cantidad esperada de elementos.

Y como los hilos se ejecutan en orden impredecible cada vez que corres la app, los errores también varían: a veces más,
a veces menos.
