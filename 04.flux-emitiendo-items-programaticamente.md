# Sección 4: Flux - Emitiendo items programáticamente

---

## Flux.create() – Emisión imperativa de elementos

En la sección anterior, habíamos hablado de algunas opciones para crear un flujo, por ejemplo a partir de una lista, un
arreglo, etc. Eso es bueno cuando ya tenemos esos tipos en algún lugar del código y podemos crear un flujo a partir de
ahí. Pero probablemente nos falte algo, es decir, nosotros como desarrolladores, necesitamos la capacidad de emitir
un elemento mediante programación, seguir emitiendo datos hasta que se cumpla alguna condición. Para ese escenario
`Reactor` ofrece un par de opciones, eso es lo que veremos en este apartado.

A continuación demostramos cómo crear un `Flux` que emite elementos manualmente mediante programación,
en lugar de usar datos ya existentes.

````java
public class Lec01FluxCreate {
    public static void main(String[] args) {
        Flux.create(fluxSink -> {
            String country;
            do {
                country = Util.faker().country().name();    // genera un país aleatorio
                fluxSink.next(country);                     // emite el país al Flux
            } while (!country.equalsIgnoreCase("Peru"));    // sigue hasta que se emita "Peru"

            fluxSink.complete();                            // indica que el flujo ha terminado
        }).subscribe(Util.subscriber());
    }
}
````

### Donde

- `Flux.create(...)`, crea un `Flux` manualmente usando un `FluxSink`. Nosotros decidimos cuándo y qué emitir.
- `FluxSink<T>`, es una interfaz que actúa como puente entre tu código imperativo y el mundo reactivo. Es el objeto que
  recibimos en el lambda de `Flux.create()`, y nos permite emitir elementos manualmente a un `Flux`.
- `FluxSink` nos da el control manual de cuándo y cómo se emiten los elementos en un `Flux`.
- `fluxSink.next(...)`, emite un nuevo valor al flujo.
- `fluxSink.complete()`, finaliza la emisión (completa el flujo).

El ejemplo muestra cómo `Flux.create()` da control completo sobre el proceso de emisión. Además, es ideal para demostrar
cómo simular condiciones de parada en flujos programáticos.

````bash
18:05:44.769 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Guinea-Bissau
18:05:44.769 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Venezuela (Bolivarian Republic of)
18:05:44.769 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Guinea-Bissau
18:05:44.769 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Samoa
18:05:44.769 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Egypt
18:05:44.769 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Egypt
18:05:44.770 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Greece
18:05:44.770 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Tajikistan
18:05:44.770 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Peru
18:05:44.774 INFO  [           main] d.m.a.common.DefaultSubscriber :  ¡completado!
````

## Flux Create - Refactor

Podemos refactorizar el código anterior implementando el consumer en una clase concreta, tal como se muestra a
continuación.

````java
public class NameGenerator implements Consumer<FluxSink<String>> {

    private FluxSink<String> fluxSink;

    @Override
    public void accept(FluxSink<String> fluxSink) {
        this.fluxSink = fluxSink;
    }

    public void generate() {
        this.fluxSink.next(Util.faker().country().name());
    }

    public void complete() {
        this.fluxSink.complete();
    }
}
````

Luego, en nuestra clase principal podemos realizar la siguiente implementación donde al `Flux.create(...)` le pasamos
la clase concreta que creamos anteriormente.

````java
public class Lec02FluxCreateRefactor {
    public static void main(String[] args) {
        NameGenerator nameGenerator = new NameGenerator();
        Flux<String> stringFlux = Flux.create(nameGenerator);
        stringFlux.subscribe(Util.subscriber());

        for (int i = 0; i < 10; i++) {
            nameGenerator.generate();
        }
        nameGenerator.complete();
    }
}
````

Si ejecutamos la aplicación, obtendremos un resultado similar al siguiente.

````bash
10:30:57.323 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Eritrea
10:30:57.326 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Hungary
10:30:57.327 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Estonia
10:30:57.327 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Syrian Arab Republic
10:30:57.327 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Cambodia
10:30:57.327 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Jamaica
10:30:57.327 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Luxembourg
10:30:57.328 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: India
10:30:57.328 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Seychelles
10:30:57.328 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Finland
10:30:57.331 INFO  [           main] d.m.a.common.DefaultSubscriber :  ¡completado!
````

## FluxSink - Seguridad del hilo (Thread Safety)

### Demostrando algo que `No es Thread Safe`

Antes de hacer una demostración de la seguridad de los hilos de sincronización de flujo, me gustaría hacer una
`demostración de algo que NO ES SEGURO para los HILOS`.

````java
public class Lec03FluxSinkThreadSafety {

    private static final Logger log = LoggerFactory.getLogger(Lec03FluxSinkThreadSafety.class);

    public static void main(String[] args) {
        notThreadSafe();
    }

    private static void notThreadSafe() {
        // Un arrayList no es seguro para hilos
        List<Integer> list = new ArrayList<>();

        // Un Runnable es una tarea
        Runnable runnable = () -> {
            for (int i = 0; i < 1000; i++) {
                list.add(i);
            }
        };

        for (int i = 0; i < 10; i++) {
            // En java 17
            // new Thread(runnable).start();

            // En java 21
            Thread.ofPlatform().start(runnable);
        }
        // Como estamos creando múltiples hilos, puede que tengamos que bloquear el hilo principal durante
        // unos segundos para que todos los hilos puedan hacer su trabajo
        Util.sleepSeconds(3);
        log.info("Tamaño de la lista: {}", list.size());
    }
}
````

Al ejecutar la aplicación vemos el siguiente resultado.

````bash
//10:54:07.056 INFO  [           main] .a.s.Lec03FluxSinkThreadSafety : Tamaño de la lista: 9147
````

Se supone que deberíamos tener `10,000` elementos en la lista, ya que se lanzan `10 hilos`, y cada hilo añade `1,000`
elementos. Sin embargo, al ejecutar la aplicación, observamos que el tamaño de la lista varía: en una ejecución puede
mostrar `9147`, en otra `8830`, y así sucesivamente.

Esto demuestra que obtenemos resultados inconsistentes en cada ejecución. La razón es que `ArrayList`
`no es seguro para múltiples hilos`, lo cual genera `condiciones de carrera` cuando varios hilos intentan modificar la
lista al mismo tiempo.

### ¿Por qué varía el resultado y es menor?

Cuando varios hilos acceden simultáneamente a un `ArrayList` y modifican su contenido (por ejemplo, agregando elementos
con `add`), pueden ocurrir `condiciones de carrera` (race conditions).

### ¿Qué es una condición de carrera en este contexto?

Imagina que dos hilos (Hilo A y Hilo B) intentan ejecutar `list.add(i)` casi al mismo tiempo. Internamente, `ArrayList`:

1. Verifica si hay espacio en el arreglo interno.

2. Si hay espacio, coloca el nuevo elemento en la posición correspondiente.

3. Aumenta el contador de tamaño (`size++`).

Estos pasos no son atómicos, y al no estar sincronizados, pueden interrumpirse mutuamente.

Ejemplo de problema:

- Hilo A y Hilo B verifican al mismo tiempo que hay espacio en la posición 999.
- Ambos intentan insertar su valor en esa posición.
- Ambos incrementan el contador `size`.
- Resultado: se perdió un elemento (uno sobrescribió al otro), pero el contador `size` puede haberse incrementado
  incorrectamente, o incluso no incrementarse correctamente.

Este tipo de errores hace que:

- Algunos elementos no se agreguen.
- El tamaño de la lista no refleje la cantidad esperada de elementos.

Y como los hilos se ejecutan en orden impredecible cada vez que corres la app, los errores también varían: a veces más,
a veces menos.

### Demostrando lo que `es Thread Safe`

En la demostración anterior vimos que un `ArrayList` `no es seguro para múltiples hilos` (`not thread-safe`). A pesar de
ello, en este ejemplo volveremos a utilizar `ArrayList`, pero esta vez nos aseguraremos de que el acceso concurrente sea
seguro, de forma que al final obtengamos la cantidad esperada de elementos en la lista.

Para lograr esto, utilizamos un `FluxSink`, que es una forma de emitir datos hacia un Flux desde múltiples hilos. En
implementaciones anteriores creamos un `NameGenerator` que actúa como puente entre los productores (los hilos) y los
consumidores (el Flux que agrega los elementos a la lista).

De esta manera, todos los datos se transfieren de forma controlada y segura, utilizando el mecanismo de Reactor. Cada
vez que se genera un dato, se emite de forma secuencial a través del `FluxSink`, evitando `condiciones de carrera`.

````java
public class Lec03FluxSinkThreadSafety {
    private static final Logger log = LoggerFactory.getLogger(Lec03FluxSinkThreadSafety.class);

    public static void main(String[] args) {
        threadSafe();
    }

    private static void threadSafe() {
        List<String> list = new ArrayList<>();
        NameGenerator nameGenerator = new NameGenerator();
        Flux<String> stringFlux = Flux.create(nameGenerator);
        stringFlux.subscribe(list::add);

        Runnable runnable = () -> {
            for (int i = 0; i < 1000; i++) {
                nameGenerator.generate();
            }
        };

        for (int i = 0; i < 10; i++) {
            Thread.ofPlatform().start(runnable);
        }

        Util.sleepSeconds(3);
        log.info("Tamaño del list: {}", list.size());
    }
}
````

Cada vez que ejecutemos esta aplicación, la lista debe contener exactamente `10,000` elementos:

````bash
11:33:21.545 INFO  [           main] .a.s.Lec03FluxSinkThreadSafety : Tamaño del list: 10000
````

## Flux Create - Comportamiento predeterminado

`FluxSink` tiene un comportamiento interesante que puede que no nos guste, pero así es por diseño. Así que primero
demostraremos el comportamiento por defecto y luego veremos cómo podemos arreglarlo si queremos cambiar ese
comportamiento.

En el siguiente ejemplo veremos cómo es que el publisher produce todos los elementos por adelantado. Lo que hará es que
cualquier cosa que hagamos o le demos al método `next()`, todo será almacenado dentro de una cola ilimitada. Luego, el
subscriber puede obtener esos elementos cuando quiera.

````java
public class Lec04FluxCreateDownstreamDemand {
    private static final Logger log = LoggerFactory.getLogger(Lec04FluxCreateDownstreamDemand.class);

    public static void main(String[] args) {
        produceEarlyDefault();
    }

    private static void produceEarlyDefault() {
        SubscriberImpl subscriber = new SubscriberImpl();

        Flux.<String>create(fluxSink -> {
            for (int i = 0; i < 10; i++) {
                String name = Util.faker().name().firstName();
                log.info("generado: {}", name);
                fluxSink.next(name);
            }
            fluxSink.complete();
        }).subscribe(subscriber);
    }
}
````

Lo que observamos en esta ejecución es una demostración clara del comportamiento por defecto de `Flux.create()`,
y más específicamente, del uso de `FluxSink` cuando no hay una demanda explícita (`request(n)`) del `Subscriber`.

````bash
11:54:25.406 INFO  [           main] ec04FluxCreateDownstreamDemand : generado: Lupe
11:54:25.410 INFO  [           main] ec04FluxCreateDownstreamDemand : generado: Antione
11:54:25.411 INFO  [           main] ec04FluxCreateDownstreamDemand : generado: Refugio
11:54:25.411 INFO  [           main] ec04FluxCreateDownstreamDemand : generado: Karl
11:54:25.411 INFO  [           main] ec04FluxCreateDownstreamDemand : generado: Chelsea
11:54:25.412 INFO  [           main] ec04FluxCreateDownstreamDemand : generado: Lizeth
11:54:25.412 INFO  [           main] ec04FluxCreateDownstreamDemand : generado: Wes
11:54:25.412 INFO  [           main] ec04FluxCreateDownstreamDemand : generado: Willene
11:54:25.413 INFO  [           main] ec04FluxCreateDownstreamDemand : generado: Titus
11:54:25.413 INFO  [           main] ec04FluxCreateDownstreamDemand : generado: Tami
````

### ¿Qué está pasando?

- El `publisher` (en este caso el `Flux.create(...)`) emite 10 elementos inmediatamente, sin esperar a que el
  `Subscriber` los solicite.
- Todos estos elementos `se almacenan internamente en una cola sin límites` (esto es por diseño en `Reactor`).
- El `SubscriberImpl` implementa `Subscriber`, pero no llama a `subscription.request(n)` en `onSubscribe(...)`,
  por lo tanto, no hay demanda registrada, y por eso no se procesan los elementos.

El resultado es que vemos, por ejemplo `generado: Lupe` en consola (porque el `publisher` sigue produciendo),
pero no aparece ningún `recibido:` (mensaje del `SubscriberImpl`), ya que el `subscriber` nunca solicitó elementos.
Esto simula un caso real en programación reactiva donde si no hay demanda, no se emiten elementos al consumidor.

Este comportamiento ilustra cómo `Reactor` es `push-pull`, es decir, aunque el productor pueda emitir libremente, si el
consumidor no está listo (no ha hecho `request()`), los datos se acumulan, pero no se consumen.

Ahora realizamos la solicitud de elementos a consumir `subscription.request(n)`.

````java
public class Lec04FluxCreateDownstreamDemand {
    private static final Logger log = LoggerFactory.getLogger(Lec04FluxCreateDownstreamDemand.class);

    public static void main(String[] args) {
        produceEarlyDefault();
    }

    private static void produceEarlyDefault() {
        SubscriberImpl subscriber = new SubscriberImpl();

        Flux.<String>create(fluxSink -> {
            for (int i = 0; i < 10; i++) {
                String name = Util.faker().name().firstName();
                log.info("generado: {}", name);
                fluxSink.next(name);
            }
            fluxSink.complete();
        }).subscribe(subscriber);

        Util.sleepSeconds(2);
        subscriber.getSubscription().request(2);

        Util.sleepSeconds(2);
        subscriber.getSubscription().request(2);

        Util.sleepSeconds(2);
        subscriber.getSubscription().request(2);
        subscriber.getSubscription().cancel();
    }
}
````

1. El `Publisher` sigue produciendo de inmediato:
    - Aunque el `Subscriber` aún no ha pedido nada, el publisher genera los 10 nombres y los almacena en una cola
      interna.

2. El `Subscriber` **empieza a recibir elementos solo cuando los solicita explícitamente:**
    - Con cada llamada a `subscription.request(n)`, se consumen `n` elementos de la cola.

3. Esto demuestra que la estrategia de `FluxSink` es `push`, pero el consumo es `pull`:
    - El `publisher` empuja datos, pero no se envían al `subscriber` hasta que este los solicita, garantizando control
      sobre el flujo y evitando desbordamientos.

5. El uso de `cancel()` detiene el flujo:
    - Aunque todavía había elementos en la cola, se detiene la suscripción, y ya no se entregarán más datos.

Como resultado vemos que cuando se le solicita la cantidad de elementos, el `subscriber` recién las empieza a
obtener desde la cola donde las almacenó previamente.

````bash
12:02:12.042 INFO  [           main] ec04FluxCreateDownstreamDemand : generado: Cole
12:02:12.049 INFO  [           main] ec04FluxCreateDownstreamDemand : generado: Reynaldo
12:02:12.049 INFO  [           main] ec04FluxCreateDownstreamDemand : generado: Vincenzo
12:02:12.049 INFO  [           main] ec04FluxCreateDownstreamDemand : generado: Estefana
12:02:12.050 INFO  [           main] ec04FluxCreateDownstreamDemand : generado: Del
12:02:12.050 INFO  [           main] ec04FluxCreateDownstreamDemand : generado: Margery
12:02:12.050 INFO  [           main] ec04FluxCreateDownstreamDemand : generado: Berniece
12:02:12.050 INFO  [           main] ec04FluxCreateDownstreamDemand : generado: Doyle
12:02:12.051 INFO  [           main] ec04FluxCreateDownstreamDemand : generado: Waltraud
12:02:12.051 INFO  [           main] ec04FluxCreateDownstreamDemand : generado: Sherryl
12:02:14.067 INFO  [           main] d.m.a.p.s.SubscriberImpl       : recibido: Cole
12:02:14.068 INFO  [           main] d.m.a.p.s.SubscriberImpl       : recibido: Reynaldo
12:02:16.081 INFO  [           main] d.m.a.p.s.SubscriberImpl       : recibido: Vincenzo
12:02:16.081 INFO  [           main] d.m.a.p.s.SubscriberImpl       : recibido: Estefana
12:02:18.086 INFO  [           main] d.m.a.p.s.SubscriberImpl       : recibido: Del
12:02:18.086 INFO  [           main] d.m.a.p.s.SubscriberImpl       : recibido: Margery
````

Este patrón es muy útil en sistemas que necesitan manejar volúmenes altos de datos sin saturar consumidores lentos.
También es clave en la arquitectura reactiva para mantener la estabilidad del sistema.

## Flux Create - Emitir a demanda

En el apartado anterior vimos que el `Flux.create` produce los elementos sin que alguien los haya solicitado,
simplemente los produce y los almacena en una cola. Posteriormente, cuando un `Suscriber` los solicita, pues las obtiene
de la cola previamente almacenada.

En este apartado cambiaremos ese comportamiento por defecto para que el `publisher` únicamente produzca los elementos
bajo demanda, es decir, cuando realmente se le haya solicitado. Para eso realizamos el siguiente ejemplo.

````java
public class Lec04FluxCreateDownstreamDemand {
    private static final Logger log = LoggerFactory.getLogger(Lec04FluxCreateDownstreamDemand.class);

    public static void main(String[] args) {
        produceOnDemand();
    }

    private static void produceOnDemand() {
        SubscriberImpl subscriber = new SubscriberImpl();

        Flux<String> fluxCreate = Flux.create(fluxSink -> {
            fluxSink.onRequest(value -> {
                for (int i = 0; i < value && !fluxSink.isCancelled(); i++) {
                    String name = Util.faker().name().firstName();
                    log.info("generado-onDemand: {}", name);
                    fluxSink.next(name);
                }
            });
        });

        fluxCreate.subscribe(subscriber);
    }
}
````

### Lo que logras con `fluxSink.onRequest(...)`:

1. Desactivamos el comportamiento predeterminado de `“pre-emisión”`:
    - Ya no se generan elementos de inmediato. En cambio, el `Publisher` espera a que el `Subscriber` haga una solicitud
      explícita (`request(n)`).


2. Producción bajo demanda real:
    - Tu código en `onRequest(value -> {...})` se ejecuta solo cuando hay una solicitud de `n elementos`.
    - Dentro del `loop for (int i = 0; i < value; i++)`, estás generando exactamente la cantidad solicitada.


3. Chequeo de cancelación:
    - `fluxSink.isCancelled()` asegura que dejes de emitir si el `Subscriber` cancela la suscripción. Este es un buen
      patrón para evitar trabajo innecesario.


4. Resultado esperado:
    - Como aún no has llamado a `subscriber.getSubscription().request(n)`, el `Publisher` no genera nada, y por eso la
      consola no muestra nada.

Este patrón es ideal para escenarios en los que:

- El costo de producir elementos es alto.
- No quieres desperdiciar recursos generando datos que tal vez nunca serán consumidos.
- Quieres que el `Subscriber` tenga control completo del ritmo del flujo.

Si ejecutamos el código anterior, no veremos ninguna salida en consola, eso significa que el `Flux.create()` no está
produciendo ningún elemento dado que no se le ha solicitado aún.

````bash
Process finished with exit code 0
````

Si ahora solicitamos elementos, vemos que el `Flux.create(...)` recién empezará a producir elementos y los subscribers
a consumirlos.

````java
public class Lec04FluxCreateDownstreamDemand {
    private static final Logger log = LoggerFactory.getLogger(Lec04FluxCreateDownstreamDemand.class);

    public static void main(String[] args) {
        produceOnDemand();
    }

    private static void produceOnDemand() {
        SubscriberImpl subscriber = new SubscriberImpl();

        Flux<String> fluxCreate = Flux.create(fluxSink -> {
            fluxSink.onRequest(value -> {
                for (int i = 0; i < value && !fluxSink.isCancelled(); i++) {
                    String name = Util.faker().name().firstName();
                    log.info("generado-onDemand: {}", name);
                    fluxSink.next(name);
                }
            });
        });

        fluxCreate.subscribe(subscriber);
        subscriber.getSubscription().request(2);
        subscriber.getSubscription().request(2);
        subscriber.getSubscription().cancel();
    }
}
````

1. `request(n)` → producción y consumo inmediato:
    - Cuando el `subscriber` hace una solicitud, `fluxSink.onRequest(...)` se dispara.
    - Se generan exactamente `n elementos` (en tu caso, 2 y luego otros 2).
    - Inmediatamente después de ser emitidos, los elementos son entregados al `subscriber`, quien los consume uno por
      uno.


2. No hay almacenamiento en buffer:
    - A diferencia del caso anterior (con producción anticipada), aquí no se encola nada.
    - Si no hay solicitud, no hay producción.


3. Cancelación efectiva:
    - Tras llamar a `subscriber.getSubscription().cancel()`, cualquier llamada posterior a `request(n)` será ignorada
      porque la suscripción está cancelada.
    - Además, el `fluxSink.isCancelled()` detiene cualquier producción en curso si ocurre una cancelación en medio de un
      bucle de emisión.

En el resultado observamos que el elemento generado bajo demanda es automáticamente consumido por el `subscriber`.
Lo que estamos viendo en esta ejecución es un comportamiento de `reactive pull`, donde el `subscriber` controla
completamente cuándo y cuántos elementos desea recibir.

````bash
12:51:15.495 INFO  [           main] ec04FluxCreateDownstreamDemand : generado-onDemand: Ira
12:51:15.500 INFO  [           main] d.m.a.p.s.SubscriberImpl       : recibido: Ira
12:51:15.501 INFO  [           main] ec04FluxCreateDownstreamDemand : generado-onDemand: Rosella
12:51:15.501 INFO  [           main] d.m.a.p.s.SubscriberImpl       : recibido: Rosella
12:51:15.502 INFO  [           main] ec04FluxCreateDownstreamDemand : generado-onDemand: Joya
12:51:15.502 INFO  [           main] d.m.a.p.s.SubscriberImpl       : recibido: Joya
12:51:15.502 INFO  [           main] ec04FluxCreateDownstreamDemand : generado-onDemand: Daren
12:51:15.502 INFO  [           main] d.m.a.p.s.SubscriberImpl       : recibido: Daren
````

## FluxSink - Casos de uso

En este apartado hablaremos de algunos aspectos importantes sobre `Flex.create(...)` y `FluxSink`.

- Está diseñado para usarse con `un único suscriptor`.
- `FluxSink` es `seguro para subprocesos` (`thread-safe`).
- Podemos seguir emitiendo datos sin preocuparnos por la demanda del suscriptor.
- `FluxSink` entregará todos los elementos de forma segura al suscriptor.

### Ejemplo simple de uso de FluxSink

A continuación, se muestra un ejemplo sencillo donde múltiples hilos generan datos aleatorios y los emiten de forma
segura usando `FluxSink`:

````java
public class FluxSinkUseCase {
    public static void main(String[] args) {
        Flux<String> flux = Flux.create(fluxSink -> {
            Runnable runnable = () -> {
                for (int i = 0; i < 5; i++) {
                    fluxSink.next(Thread.currentThread().getName() + " - valor " + i);
                }
            };

            for (int i = 0; i < 3; i++) {
                Thread.ofPlatform().start(runnable);
            }

            // Esperamos un poco para que los hilos terminen de emitir
            try {
                Thread.sleep(1000);
                fluxSink.complete();
            } catch (InterruptedException e) {
                fluxSink.error(e);
            }
        });

        flux.subscribe(System.out::println);
    }
}
````

### ¿Qué muestra este ejemplo?

- Usamos `Flux.create(...)` con un `FluxSink` que recibe datos de varios hilos.
- Cada hilo emite 5 valores.
- Los datos se entregan al `suscriptor` en orden de llegada, sin fallos ni duplicados, demostrando que el `FluxSink`
  maneja correctamente la concurrencia.

## Take Operators

### Operador `take()`

El operador `take(n)` se utiliza para limitar la cantidad de elementos emitidos por un `Flux`. Una vez que el `Flux` ha
emitido `n elementos`, se cancela automáticamente la suscripción aguas arriba (`upstream`), y se completa el flujo.

- Solo permite pasar los primeros `n elementos`.
- Luego de alcanzar ese límite, el flujo se completa automáticamente.
- Es útil para cortar el flujo sin necesidad de condiciones complejas o lógica adicional.

````java
public class Lec05TakeOperator {
    public static void main(String[] args) {
        take();
    }

    private static void take() {
        Flux.range(1, 10)                       // Emitimos los números del 1 al 10
                .log("take")                    // Agregamos logging antes del operador
                .take(3)                        // Solo tomamos los primeros 3 elementos
                .log("subs")                    // Logging después del operador
                .subscribe(Util.subscriber());
    }
}
````

````bash
15:28:57.657 INFO  [           main] take                           : | onSubscribe([Synchronous Fuseable] FluxRange.RangeSubscription)
15:28:57.661 INFO  [           main] subs                           : onSubscribe(FluxLimitRequest.FluxLimitRequestSubscriber)
15:28:57.663 INFO  [           main] subs                           : request(unbounded)
15:28:57.664 INFO  [           main] take                           : | request(3)        // Se solicitan 3 elementos
15:28:57.664 INFO  [           main] take                           : | onNext(1)         // Se emite el primer valor
15:28:57.664 INFO  [           main] subs                           : onNext(1)
15:28:57.664 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 1
15:28:57.664 INFO  [           main] take                           : | onNext(2)         // Segundo valor
15:28:57.665 INFO  [           main] subs                           : onNext(2)
15:28:57.665 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 2
15:28:57.665 INFO  [           main] take                           : | onNext(3)         // Tercer valor
15:28:57.665 INFO  [           main] subs                           : onNext(3)
15:28:57.665 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 3
15:28:57.666 INFO  [           main] take                           : | cancel()          // Al llegar a 3, se cancela la suscripción upstream
15:28:57.666 INFO  [           main] subs                           : onComplete()        // El flujo se completa
15:28:57.669 INFO  [           main] d.m.a.common.DefaultSubscriber :  ¡completado!
````

El operador `take(n)` es una forma segura y eficiente de limitar el número de elementos que deseamos procesar de un
flujo. No solo detiene la emisión después del límite, sino que también libera recursos al cancelar la suscripción hacia
el origen de datos.

### Operador `takeWhile()`

El operador `takeWhile` permite emitir elementos de un `Flux` mientras se cumpla una condición determinada.
En cuanto un elemento no cumple la condición, el flujo se detiene inmediatamente y se cancela la suscripción.

````java
public class Lec05TakeOperator {
    public static void main(String[] args) {
        takeWhile();
    }

    private static void takeWhile() {
        Flux.range(1, 10)
                .log("take")
                .takeWhile(i -> i < 3)
                .log("subs")
                .subscribe(Util.subscriber());
    }
}
````

- Se genera un `Flux` con los números del `1 al 10`.
- Se emiten los elementos `mientras sean menores que 3`.
- Al llegar al número 3, como `no cumple la condición` `i < 3`, el flujo `se cancela inmediatamente`, y no se emiten más
  elementos, incluso si hay más disponibles.
- Se genera el evento `onComplete()` justo después de cancelar la emisión.

````bash
15:40:11.549 INFO  [           main] take                           : | onSubscribe([Synchronous Fuseable] FluxRange.RangeSubscription)
15:40:11.552 INFO  [           main] subs                           : onSubscribe(FluxTakeWhile.TakeWhileSubscriber)
15:40:11.553 INFO  [           main] subs                           : request(unbounded)
15:40:11.553 INFO  [           main] take                           : | request(unbounded)
15:40:11.553 INFO  [           main] take                           : | onNext(1)
15:40:11.554 INFO  [           main] subs                           : onNext(1)
15:40:11.554 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 1
15:40:11.554 INFO  [           main] take                           : | onNext(2)
15:40:11.554 INFO  [           main] subs                           : onNext(2)
15:40:11.554 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 2
15:40:11.554 INFO  [           main] take                           : | onNext(3)
15:40:11.554 INFO  [           main] take                           : | cancel()
15:40:11.555 INFO  [           main] subs                           : onComplete()
15:40:11.558 INFO  [           main] d.m.a.common.DefaultSubscriber :  ¡completado!
````

A diferencia del operador `take(n)`, que limita la cantidad de elementos emitidos, `takeWhile` evalúa cada elemento
individualmente en función de la condición, deteniéndose en cuanto uno no cumpla.

### Operador `takeUntil()`

El operador `takeUntil` en `Project Reactor` permite emitir elementos desde el `Publisher` original hasta que se cumpla
una condición booleana (`inclusive`). A diferencia de `takeWhile`, que detiene la emisión al encontrar un valor que no
cumpla la condición, `takeUntil` continúa emitiendo hasta que el predicado retorne `true` por primera vez,
e `incluye ese elemento en la secuencia`.

````java
public class Lec05TakeOperator {
    public static void main(String[] args) {
        takeUntil();
    }

    private static void takeUntil() {
        Flux.range(1, 10)
                .log("take")
                .takeUntil(i -> i == 1)
                .log("subs")
                .subscribe(Util.subscriber());
    }
}
````

Vemos que en la salida tenemos al `1` cómo único elemento emitido del conjunto de elementos que nos proporciona el
`range()`. Esto sucede porque `takeUntil(i -> i == 1)` seguirá emitiendo hasta que el valor sea `1`, lo incluirá, y
luego cancelará la suscripción.

````bash
15:47:02.876 INFO  [           main] take                           : | onSubscribe([Synchronous Fuseable] FluxRange.RangeSubscription)
15:47:02.879 INFO  [           main] subs                           : onSubscribe(FluxTakeUntil.TakeUntilPredicateSubscriber)
15:47:02.880 INFO  [           main] subs                           : request(unbounded)
15:47:02.881 INFO  [           main] take                           : | request(unbounded)
15:47:02.881 INFO  [           main] take                           : | onNext(1)
15:47:02.881 INFO  [           main] subs                           : onNext(1)
15:47:02.881 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 1
15:47:02.882 INFO  [           main] take                           : | cancel()
15:47:02.883 INFO  [           main] subs                           : onComplete()
15:47:02.885 INFO  [           main] d.m.a.common.DefaultSubscriber :  ¡completado!
````

## Flux Generate

`Flux.generate()` es un generador `síncrono` de datos en `Project Reactor`. Está diseñado para emitir
`un solo elemento por iteración` y es útil cuando deseamos tener un control fino sobre qué se emite y cuándo se
completa el flujo.

### Restricción clave:

- Invoca la expresión lambda dada una y otra vez según la demanda posterior.
- Solo se permite una llamada a `.next()` por iteración.
- Se detendrá al invocar el método `complete`.
- Se detendrá al invocar el método de `error`.
- Detendrá las cancelaciones posteriores.
- Si se intenta emitir más de un valor en una sola llamada (como en el ejemplo), se lanza una excepción con el mensaje:
  `error: More than one call to onNext`.

Veamos el siguiente ejemplo donde hacemos uso del `Flux.generate()` y tratamos de emitir dos veces usando el `.next()`.

````java
public class Lec06FluxGenerate {
    public static void main(String[] args) {
        Flux.generate(synchronousSink -> {
            synchronousSink.next(1);    // OK
            synchronousSink.next(2);    // ERROR> no está permitido
            synchronousSink.complete(); // no se alcanza
        }).subscribe(Util.subscriber());
    }
}
````

Como resultado obtenemos un error al tratar de emitir el segundo elemento con `.next()`.

````bash
16:21:38.731 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 1
16:21:38.736 ERROR [           main] d.m.a.common.DefaultSubscriber :  error: More than one call to onNext
````

Ahora, solo usamos una única vez el `.next()`.

````java
public class Lec06FluxGenerate {
    public static void main(String[] args) {
        Flux.generate(synchronousSink -> {
            synchronousSink.next(1);
            synchronousSink.complete();
        }).subscribe(Util.subscriber());
    }
}
````

Obtenemos correctamente la emisión del dato y finalmente el flujo se completa.

````bash
16:22:02.268 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 1
16:22:02.273 INFO  [           main] d.m.a.common.DefaultSubscriber :  ¡completado!
````

### 📌 Comparación inicial: Flux.create() vs Flux.generate()

Cuando trabajamos con `Flux.create()`, nosotros controlamos la iteración manualmente. Por ejemplo, usamos un bucle for
para emitir un número determinado de elementos en función de la demanda.

En cambio, con `Flux.generate()` el bucle es gestionado internamente por `Project Reactor`, por lo tanto, *solo se
permite emitir un único elemento por invocación de la función lambda*. Esta función se ejecuta repetidamente en función
de la demanda del suscriptor (`request(n)`).

Veamos el siguiente ejemplo del comportamiento repetitivo controlado por la demanda.

````java
public class Lec06FluxGenerate {
    private static final Logger log = LoggerFactory.getLogger(Lec06FluxGenerate.class);

    public static void main(String[] args) {
        example2();
    }

    private static void example2() {
        Flux.generate(synchronousSink -> {
            log.info("Invocado");
            synchronousSink.next(1);
        }).subscribe(Util.subscriber());
    }
}
````

### 🧠 Comportamiento

- `Flux.generate()` está diseñado para emitir **exactamente un elemento por invocación de la función lambda**.
- No emite automáticamente varios elementos. Cada invocación responde a una unidad de demanda (`request(1)`) del
  suscriptor.
- En este caso, `Util.subscriber()` solicita `Long.MAX_VALUE` elementos (demanda infinita), por lo tanto, el generador
  se ejecuta indefinidamente.
- La llamada repetida a `.next(1)` hace que se emita el valor `1` una y otra vez, mientras haya demanda.
- Como no se llama a `complete()`, el flujo nunca termina, y sigue emitiendo.

### ⚠️ Consideraciones

- Si no se controla manualmente un límite o condición de parada, el flujo será infinito.
- Ideal para flujos que necesitan una lógica de generación personalizada, pero siempre limitada a un solo `onNext()`
  por ciclo.

````bash
3:03.987 INFO  [           main] d.m.a.sec04.Lec06FluxGenerate  : Invocado
16:43:03.987 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 1
16:43:03.987 INFO  [           main] d.m.a.sec04.Lec06FluxGenerate  : Invocado
16:43:03.987 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 1
16:43:03.987 INFO  [           main] d.m.a.sec04.Lec06FluxGenerate  : Invocado
16:43:03.987 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: 1
...
````

## Flux Generate - Emitir hasta

En la clase `Lec01FluxCreate` definimos un ejercicio usando `Flux.create()`, el cual consistía en emitir los países de
manera aleatoria hasta que se emita `Perú`, cuando eso suceda se debe completar el flujo.

En este apartado realizaremos el mismo ejercicio pero usando el `Flux.generate()`. `Flux.generate()` permite emitir un
único elemento por iteración del `synchronousSink`. Internamente, Reactor gestiona el bucle y solo vuelve a invocar
la lambda cuando el `Subscriber` hace una nueva solicitud (`request(n)`).

El `takeUntil(predicate)` escucha los elementos emitidos y completa el flujo inmediatamente cuando se cumple la
condición del predicado (en este caso, cuando el país es `Perú`).

````java
public class Lec07FluxGenerateUntil {
    private static final Logger log = LoggerFactory.getLogger(Lec07FluxGenerateUntil.class);

    public static void main(String[] args) {
        example1();
    }


    private static void example1() {
        Flux<String> generate = Flux.<String>generate(synchronousSink -> {
            String country = Util.faker().country().name();
            synchronousSink.next(country);
        });
        generate.takeUntil(country -> country.equalsIgnoreCase("peru"))
                .subscribe(Util.subscriber());
    }
}
````

### ⚠️ Consideraciones clave

- El `synchronousSink.next(...)` no puede llamarse más de una vez por iteración, o se lanza una excepción.
- Si se usa generate sin condiciones de parada (como `takeUntil` o `complete()`), el flujo será potencialmente infinito
  si el valor de corte nunca se genera.

Si ejecutamos la aplicación anterior vemos que por cada iteración genera un país, luego lo envía por el
`synchronousSink.next(country)`, es decir se está haciendo un solo uso de ese método. La emisión del flujo finaliza
dado que se cumple la condición del `takeUntil`.

````bash
17:10:18.134 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Uzbekistan
17:10:18.134 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Iceland
17:10:18.134 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Poland
17:10:18.134 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Peru
17:10:18.138 INFO  [           main] d.m.a.common.DefaultSubscriber :  ¡completado!
````

Este patrón es útil cuando necesitamos generar elementos de manera controlada, uno por uno, en función de una condición
que determine cuándo finalizar la secuencia.

### ✅ Control explícito del flujo con synchronousSink.complete()

En este segundo enfoque, en lugar de usar el operador `takeUntil`, la finalización del flujo se maneja directamente
dentro de la función lambda de `Flux.generate()`.

- Aquí se evita el uso de `takeUntil`.
- El flujo se completa manualmente cuando se genera el país `Perú` mediante `synchronousSink.complete()`.

````java
public class Lec07FluxGenerateUntil {
    private static final Logger log = LoggerFactory.getLogger(Lec07FluxGenerateUntil.class);

    public static void main(String[] args) {
        example2();
    }

    private static void example2() {
        Flux.<String>generate(synchronousSink -> {
            String country = Util.faker().country().name();
            synchronousSink.next(country);
            if (country.equalsIgnoreCase("peru")) {
                synchronousSink.complete();
            }

        }).subscribe(Util.subscriber());
    }
}
````

Obtenemos el mismo resultado, se obtiene Peru y se completa el flujo.

````bash
17:22:02.200 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Togo
17:22:02.200 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Egypt
17:22:02.200 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Peru
17:22:02.204 INFO  [           main] d.m.a.common.DefaultSubscriber :  ¡completado!
````

## Flux Generate - Con proveedor de estado

En ciertos casos, es útil mantener un `estado mutable` durante la generación de elementos. Para ello, `Reactor`
provee una versión sobrecargada del método `Flux.generate()` que permite usar un estado de control.

Esta versión recibe tres parámetros:

1. `Supplier<T>` – Proporciona un `estado inicial`. Se ejecuta una sola vez, al comenzar el flujo.

2. `BiFunction<T, SynchronousSink<U>, T>` – Define la lógica para emitir elementos (`.next()`) y modificar el estado.
   Se ejecuta por cada solicitud de elemento del `Subscriber`.

3. `Consumer<T>` – Recibe el último valor del estado cuando el flujo `se completa, cancela o lanza error`. También se
   ejecuta una sola vez.

> 💡 `Nota`: El estado puede ser cualquier tipo de objeto, no necesariamente un número. Puedes usar colecciones,
> estructuras complejas o clases propias, según el requerimiento del flujo.

````java
public class Lec08GenerateWithState {
    private static final Logger log = LoggerFactory.getLogger(Lec08GenerateWithState.class);

    public static void main(String[] args) {
        Flux.generate(
                () -> 0, // Estado inicial: contador = 0
                (counter, synchronousSink) -> {
                    String country = Util.faker().country().name();
                    synchronousSink.next(country);
                    counter++;
                    if (counter == 10 || country.equalsIgnoreCase("peru")) {
                        synchronousSink.complete();
                    }
                    return counter; // Se retorna el nuevo estado
                },
                counter -> log.info("Último valor del contador: {}", counter) // Acción final con el estado
        ).subscribe(Util.subscriber());
    }
}
````

Una de las condiciones para que se complete el flujo es que se emitan 10 elementos o que el país a emitir sea peru, así
que en este caso se cumplió la primera condición por eso finalizó el flujo.

````bash
17:40:50.305 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Russian Federation
17:40:50.309 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Dominica
17:40:50.309 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Iraq
17:40:50.309 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Marshall Islands
17:40:50.310 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: India
17:40:50.310 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: South Africa
17:40:50.310 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: United States of America
17:40:50.310 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Bahamas
17:40:50.310 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Panama
17:40:50.310 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Belgium
17:40:50.313 INFO  [           main] d.m.a.common.DefaultSubscriber :  ¡completado!
17:40:50.313 INFO  [           main] d.m.a.s.Lec08GenerateWithState : Último valor del contador: 10
````

Esta variante de `generate()` permite controlar la emisión en función de un estado mutable, lo que es útil en casos
donde necesitamos realizar un seguimiento, como conteos, acumulaciones o condiciones personalizadas de parada. Además,
la flexibilidad de permitir cualquier tipo de estado lo hace muy potente para representar lógica compleja de emisión.

## Tarea asignada

Como parte del ejercicio, se debe implementar la siguiente interfaz:

````java
public interface FileReaderService {
    Flux<String> read(Path path);
}
````

El objetivo es leer el contenido de un archivo y emitirlo línea por línea como parte de un flujo `Flux`.

### Consideraciones importantes:

- El procesamiento debe iniciarse solo cuando haya una suscripción activa.
- El archivo debe leerse en función de la demanda del suscriptor.
- La producción debe detenerse si el suscriptor cancela la suscripción.
- Se deben emitir únicamente los elementos solicitados.
- El archivo debe cerrarse correctamente una vez finalizado el flujo.

A continuación se muestra la solución implementada.

````java
public class FileReaderServiceImpl implements FileReaderService {

    private static final Logger log = LoggerFactory.getLogger(FileReaderServiceImpl.class);

    @Override
    public Flux<String> read(Path path) {
        return Flux.generate(
                () -> this.openFile(path),
                this::readFile,
                this::closeFile
        );
    }

    private BufferedReader openFile(Path path) throws IOException {
        log.info("Abriendo archivo");
        return Files.newBufferedReader(path);
    }

    private BufferedReader readFile(BufferedReader reader, SynchronousSink<String> synchronousSink) {
        try {
            String line = reader.readLine();
            log.info("Leyendo línea: {}", line);

            if (Objects.isNull(line)) {
                synchronousSink.complete();
            } else {
                synchronousSink.next(line);
            }

        } catch (IOException e) {
            synchronousSink.error(e);
        }
        return reader;
    }

    private void closeFile(BufferedReader reader) {
        try {
            log.info("Cerrando archivo");
            reader.close();
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }
}
````

La siguiente clase es la que ejecuta la aplicación.

````java
public class Lec09Assignment {
    public static void main(String[] args) {
        Path path = Path.of("src/main/resources/sec04/file.txt");
        FileReaderService fileReaderService = new FileReaderServiceImpl();
        fileReaderService.read(path)
                .take(6)
                .subscribe(Util.subscriber());
    }
}
````

A continuación ejecutamos la aplicación para que lea el archivo `file.txt` que contiene un total del `500 líneas`,
pero como estamos definiendo el método `take(6)`, se procesarán únicamente 6 líneas.

````bash
10:33:00.317 INFO  [           main] .m.a.s.a.FileReaderServiceImpl : Abriendo archivo
10:33:00.320 INFO  [           main] .m.a.s.a.FileReaderServiceImpl : Leyendo línea: Line_1
10:33:00.321 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Line_1
10:33:00.321 INFO  [           main] .m.a.s.a.FileReaderServiceImpl : Leyendo línea: Line_2
10:33:00.321 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Line_2
10:33:00.321 INFO  [           main] .m.a.s.a.FileReaderServiceImpl : Leyendo línea: Line_3
10:33:00.321 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Line_3
10:33:00.321 INFO  [           main] .m.a.s.a.FileReaderServiceImpl : Leyendo línea: Line_4
10:33:00.321 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Line_4
10:33:00.321 INFO  [           main] .m.a.s.a.FileReaderServiceImpl : Leyendo línea: Line_5
10:33:00.321 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Line_5
10:33:00.321 INFO  [           main] .m.a.s.a.FileReaderServiceImpl : Leyendo línea: Line_6
10:33:00.322 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Line_6
10:33:00.326 INFO  [           main] d.m.a.common.DefaultSubscriber :  ¡completado!
10:33:00.326 INFO  [           main] .m.a.s.a.FileReaderServiceImpl : Cerrando archivo
````

## Resumen: Flux - create/generate

| Create                                                                                               | Generate                                                                         |
|------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------|
| Acepta un `Consumer<FluxSink<T>>`                                                                    | Acepta un `Consumer<SynchronousSink<T>>`                                         |
| El consumidor se invoca solo una vez.                                                                | El consumidor es invocado una y otra vez.                                        |
| El consumidor puede emitir `0..N elementos` inmediatamente sin preocuparse por la demanda posterior. | El consumidor solo puede emitir un elemento. ¡Se respeta la demanda aguas abajo! |
| Seguro para subprocesos (`Thread-safe`).                                                             | N/A                                                                              |
