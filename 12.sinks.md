# Secci√≥n 12: Sinks

---

## Introducci√≥n

Hasta ahora, hemos aprendido a crear `publishers` utilizando varias formas est√°ndar que proporciona `Reactor`, como:

- `Mono.fromSupplier(...)`
- `Flux.range(...)`
- `Flux.generate(...)`
- `Flux.create(...)`
- `Flux.interval(...)`
- ...

Todas estas formas de creaci√≥n funcionan √∫nicamente cuando hay un `suscriptor` que consume los datos. Es decir, no se
emite nada hasta que alguien se suscriba.

Durante este curso, nos hemos enfocado principalmente en construir `pipelines reactivos` usando diferentes operadores.
Sin embargo, todav√≠a nos falta cubrir un aspecto importante: `la capacidad de emitir datos de manera manual`.

Cuando decimos `emitir manualmente`, nos referimos a poder enviar elementos:

- En cualquier momento.
- Si depender de bucles, rangos o intervalos.
- Sin necesidad inmediata de un suscriptor,
- Con la posibilidad de interactuar con m√∫ltiples hilos si lo deseamos.

Aqu√≠ es donde entran en escena los `Sinks`.

![01.png](assets/section-12/01.png)

Los `Sinks` en `Reactor` pueden actuar tanto como `productores` como `consumidores` de datos. Esto significa que se
pueden utilizar para recibir datos (como un `Subscriber`) y tambi√©n para emitirlos (como un `Publisher`).

Una vez creado un `Sink`, podemos:

- Usarlo para `emitir datos desde un hilo o clase`.
- Permitir que `otro hilo o clase reciba esos datos` mediante suscripci√≥n.

Esto resulta √∫til, por ejemplo, cuando necesitamos comunicar diferentes partes de nuestra aplicaci√≥n de forma as√≠ncrona
y desacoplada.

Adem√°s, los `Sinks` funcionan como puntos de integraci√≥n ideales. En un enfoque tradicional, una clase suele invocar
directamente los m√©todos de otra para realizar alguna acci√≥n, como:

- Enviar una notificaci√≥n por correo electr√≥nico,
- Enviar un SMS,
- Registrar una auditor√≠a, etc.

![02.png](assets/section-12/02.png)

Con `Sinks`, podemos cambiar este enfoque. En lugar de depender de llamadas directas entre clases, una clase simplemente
emite un evento a trav√©s del `Sink`, y otras clases que est√©n suscritas a ese flujo podr√°n reaccionar autom√°ticamente,
sin necesidad de acoplamiento directo.

Este patr√≥n favorece un dise√±o m√°s reactivo y desacoplado.

![03.png](assets/section-12/03.png)

### Ejemplo del mundo real

Imagina un sistema de alarma en una casa inteligente. Cuando se detecta movimiento en una zona restringida, el sensor
no necesita saber qui√©n debe reaccionar. Simplemente, `emite una se√±al` (evento) a trav√©s de un canal com√∫n.

Esa se√±al puede ser recibida por distintos sistemas al mismo tiempo:

- Uno activa la sirena,
- Otro env√≠a una notificaci√≥n al celular del due√±o,
- Otro graba el video desde las c√°maras de seguridad.

Cada uno de estos sistemas est√° suscrito a ese evento. As√≠ funcionan los `Sinks`: permiten que una parte del sistema
emita datos, y que otras reaccionen sin estar acopladas directamente entre s√≠.

## Sink One - TryEmit

Un Sink One (`Sinks.One<T>`) es un tipo de `Sink` dise√±ado para emitir un √∫nico valor (o bien una se√±al de `vac√≠o`
o `error`). Este tipo de `sink` se comporta como un `Mono`, por lo que puede ser transformado en un `Mono` al que uno
o m√°s `suscriptores` pueden reaccionar.

### Ejemplo 01: Explorando `Sinks.one()` para emitir un valor, vac√≠o o error

Cuando usamos `Sinks.one()`, estamos creando un sink que puede emitir `como m√°ximo un solo elemento`, o
alternativamente puede completar sin emitir (`empty`) o terminar con un error (`error`).

````java
public class Lec01SinkOne {
    public static void main(String[] args) {
        demo1();
    }

    private static void demo1() {
        Sinks.One<Object> sink = Sinks.one();
        Mono<Object> mono = sink.asMono();
        mono.subscribe(Util.subscriber());

        sink.tryEmitValue("Hola");
//        sink.tryEmitEmpty();
//        sink.tryEmitError(new RuntimeException("Error cuando se usaba sink"));
    }
}
````

En este ejemplo:

- Se crea un `Sink` y se convierte a un `Mono` usando `asMono()`.
- Luego, nos suscribimos al Mono.
- Finalmente, emitimos un valor con `tryEmitValue("Hola")`.

¬øQu√© sucede al emitir?

- Si usamos `sink.tryEmitValue("Hola")`, el suscriptor recibe ese valor y ejecuta `onNext`, seguido de `onComplete`.
- Si usamos `sink.tryEmitEmpty()`, el suscriptor ejecuta √∫nicamente `onComplete`.
- Si usamos `sink.tryEmitError(...)`, el suscriptor ejecuta `onError`, recibiendo la excepci√≥n especificada.

````bash
11:20:19.858 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Hola
11:20:19.863 INFO  [           main] d.m.a.common.DefaultSubscriber :  ¬°completado!
````

Este comportamiento es ideal cuando queremos tener un control total sobre cu√°ndo y qu√© emitir, con la posibilidad de
emitir desde una clase o hilo diferente, sin depender de generadores o flujos autom√°ticos.

### Ejemplo 02: M√∫ltiples suscriptores para un mismo `Sink`

En este ejemplo, creamos `dos suscriptores` que se suscriben al `Mono` derivado del `Sink`. Luego emitimos un valor, y
ambos suscriptores reciben ese mismo valor.

````java
public class Lec01SinkOne {
    public static void main(String[] args) {
        demo2();
    }

    private static void demo2() {
        Sinks.One<Object> sink = Sinks.one();
        Mono<Object> mono = sink.asMono();
        mono.subscribe(Util.subscriber("sam"));
        mono.subscribe(Util.subscriber("mike"));

        sink.tryEmitValue("Hola");
    }
}
````

Como resultado, ambos suscriptores reciben el mensaje `Hola` y finalizan con `onComplete`.

````bash
11:25:33.004 INFO  [           main] d.m.a.common.DefaultSubscriber : sam recibido: Hola
11:25:33.009 INFO  [           main] d.m.a.common.DefaultSubscriber : sam ¬°completado!
11:25:33.010 INFO  [           main] d.m.a.common.DefaultSubscriber : mike recibido: Hola
11:25:33.010 INFO  [           main] d.m.a.common.DefaultSubscriber : mike ¬°completado!
````

> üí°`Importante`: Aunque el `Sink.One` solo puede emitir un √∫nico valor o se√±al (`empty` o `error`), puede tener
> m√∫ltiples suscriptores, y todos ellos recibir√°n la misma se√±al (`valor` o `evento`) si se suscriben antes de la
> emisi√≥n.

### Diferencia entre `Mono.just(...)` y `sink.asMono()`

Ambos pueden emitir un solo valor, y ambos permiten m√∫ltiples suscriptores, pero su comportamiento en cuanto al momento
de la emisi√≥n y la naturaleza del publisher es distinto. Aqu√≠ est√° el detalle:

### üü† Mono.just(...) y Flux.just(...)

Estos son `cold publishers` (publicadores fr√≠os).

- Cada vez que alguien se suscribe, `se vuelve a emitir` el valor (se "reproduce" la se√±al desde cero).
- Es decir, `cada suscriptor recibe su propia emisi√≥n independiente`.
- No comparten los datos entre suscriptores. Es como una funci√≥n que se ejecuta cada vez que se llama.

### üü¢ sink.asMono() (a partir de Sinks.one())

Este es un `hot publisher` (publicador caliente).

- El valor `se emite una √∫nica vez`, cuando se llama a `sink.tryEmitValue(...)`.
- Todos los suscriptores `que ya estaban suscritos antes` de esa emisi√≥n `reciben ese mismo valor`.
- Pero si alguien se suscribe `despu√©s` de que se haya emitido,
  `tambi√©n lo recibe, siempre y cuando no haya expirado (completado)`.
- El valor `ya est√° "almacenado" internamente en el sink`, como si fuera un `buffer` que entrega a todos los que se
  suscriben.

> üí° Pero aqu√≠ la diferencia es que la emisi√≥n ocurre una sola vez con `tryEmitValue("Hola")`, y todos los suscriptores
> acceden al mismo valor ya emitido. No es que el sink vuelva a emitir como lo har√≠a un `Mono.just`.

### üí° Pero `Sinks.one()` `NO es un hot publisher tradicional`

Es un `caso especial`: es un hot publisher con memoria de un solo valor.

- `S√≠ es caliente` porque la emisi√≥n ocurre independientemente de las suscripciones.
- Pero guarda ese valor y se lo da a los suscriptores incluso si llegan despu√©s de la emisi√≥n (siempre que a√∫n no se
  haya completado el Mono).
- `sink.asMono()` act√∫a como un Mono con valor ya disponible: todos los que se suscriban despu√©s de la emisi√≥n a√∫n lo
  reciben, hasta que el `Mono` haya sido recolectado.
- En el caso de `Sinks.one().asMono()`, estamos ante un hot publisher con `buffer de 1`, por eso los suscriptores
  posteriores a√∫n ven ese valor √∫nico emitido, si no se ha recolectado a√∫n.
- En Reactor, hay varios de estos comportamientos h√≠bridos, y Sinks.one() es uno de los m√°s √∫tiles para emitir un valor
  manualmente y garantizar que todos los interesados (antes o despu√©s) lo reciban una sola vez.

### üìå Conclusi√≥n

No funcionan igual, aunque a veces el resultado pueda parecerse (todos reciben el mismo valor). Lo importante es cu√°ndo
y c√≥mo se emite el dato:

- `Mono.just(...)` lo emite cada vez que alguien se suscribe.
- `sink.asMono()` lo emite una vez, y todos los que se suscriban (antes o despu√©s) reciben esa misma emisi√≥n √∫nica.

## Sink One - `emitValue(...)` y `EmitFailureHandler`

Cuando usamos `Sinks.one()`, sabemos que solo se puede emitir un `valor`, o bien una se√±al `vac√≠a` o una se√±al de
`error`. Si intentamos emitir m√°s de una vez, el `Sink` rechazar√° esos intentos posteriores.

El m√©todo `tryEmitValue(...)` devuelve un `Sinks.EmitResult`, que indica si el intento fue exitoso (`OK`) o
fallido (`FAIL_TERMINATED`, entre otros). Este valor se puede capturar para decidir qu√© hacer, pero si no se captura,
el fallo pasa desapercibido silenciosamente.

Por otro lado, podemos usar `emitValue(...)`, que adem√°s de intentar emitir, acepta una funci√≥n de tipo
`EmitFailureHandler`, permiti√©ndonos manejar activamente esos fallos y, si lo deseamos, reintentar la emisi√≥n.

Esta interfaz tiene un m√©todo funcional que acepta:

- `SignalType`: el tipo de se√±al que se intent√≥ emitir (por ejemplo, `ON_NEXT`, `ON_COMPLETE`, etc.),
- `EmitResult`: el resultado del intento de emisi√≥n (por ejemplo, `FAIL_TERMINATED`, `FAIL_NON_SERIALIZED`, etc.).

Esto nos da la oportunidad de decidir si queremos reintentar la emisi√≥n devolviendo `true`, o no, devolviendo `false`.

### üß† ¬øPor qu√© usar emitValue(...)?

Porque te da m√°s control para manejar fallos de emisi√≥n (como cuando ya se ha completado el `sink`), y te permite
agregar l√≥gica de reintento personalizada si es necesario.

````java
public class Lec01SinkOne {
    private static final Logger log = LoggerFactory.getLogger(Lec01SinkOne.class);

    public static void main(String[] args) {
        demo3();
    }

    private static void demo3() {
        Sinks.One<Object> sink = Sinks.one();
        Mono<Object> mono = sink.asMono();

        mono.subscribe(Util.subscriber());

        sink.emitValue("Hola", (signalType, emitResult) -> {
            log.info("Hola");
            log.info(signalType.name());
            log.info(emitResult.name());

            return false; // no intentamos reemitir si falla
        });

        sink.emitValue("Buenas", (signalType, emitResult) -> {
            log.info("Buenas");
            log.info(signalType.name());
            log.info(emitResult.name());

            return false; // tampoco reintentamos aqu√≠
        });
    }
}
````

Explicaci√≥n del resultado:

- La primera llamada a `emitValue("Hola")` es exitosa. El `Subscriber` recibe el valor y se completa.
- La segunda llamada a `emitValue("Buenas")` falla, porque el `Sink` ya est√° terminado (solo permite una emisi√≥n). El
  manejador (`EmitFailureHandler`) se ejecuta e imprime.
- El `EmitResult.FAIL_TERMINATED` significa que el `sink` ya fue completado o cerrado, por lo que no se puede volver a
  emitir nada.

````bash
12:32:05.675 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Hola
12:32:05.681 INFO  [           main] d.m.a.common.DefaultSubscriber :  ¬°completado!
12:32:05.681 INFO  [           main] d.m.app.sec12.Lec01SinkOne     : Buenas
12:32:05.681 INFO  [           main] d.m.app.sec12.Lec01SinkOne     : ON_NEXT
12:32:05.681 INFO  [           main] d.m.app.sec12.Lec01SinkOne     : FAIL_TERMINATED
````

## Sink Types

Anteriormente, vimos el uso de `Sinks.one()`, que nos permite emitir un solo `valor` (o una se√±al `vac√≠a` o de `error`)
y permite m√∫ltiples suscriptores. Este tipo de `Sink` se traduce en un `Mono`, que es adecuado para emisiones √∫nicas.

Sin embargo, en situaciones donde necesitamos emitir m√∫ltiples elementos, `Reactor` proporciona otros tipos de `Sinks`
que se ajustan a distintos casos de uso. Elegir el tipo de `Sink` adecuado depender√° de c√≥mo queremos manejar las
emisiones y los suscriptores.

A continuaci√≥n se presenta una tabla con los principales tipos de `Sink` que ofrece `Reactor`:

| Sink Type            | Publisher Type | # de Subscribers | Comportamiento                                                                                        |
|----------------------|----------------|------------------|-------------------------------------------------------------------------------------------------------|
| `one`                | Mono           | N                | Emite solo un valor (o vac√≠o/error). Todos los suscriptores reciben la misma se√±al.                   |
| `many().unicast()`   | Flux           | 1                | Solo permite un suscriptor. Almacena en memoria los mensajes hasta que ese suscriptor se conecte.     |
| `many().multicast()` | Flux           | N                | Emite a m√∫ltiples suscriptores, pero solo recibir√°n los elementos emitidos despu√©s de su suscripci√≥n. |
| `many().replay()`    | Flux           | N                | Emite a m√∫ltiples suscriptores y reenv√≠a todos los valores pasados a los nuevos suscriptores.         |

### Descripci√≥n de cada tipo

- `Sinks.one()`: permite emitir un √∫nico valor. Despu√©s de emitir, el Sink se completa y no se puede volver a utilizar.
  Es √∫til cuando queremos notificar un solo evento o resultado.


- `Sinks.many().unicast()`: permite emitir m√∫ltiples elementos, pero solo acepta un suscriptor. Si el suscriptor a√∫n no
  est√° presente, los valores se almacenan en un buffer interno hasta que se suscriba.


- `Sinks.many().multicast()`: permite m√∫ltiples suscriptores, pero cada suscriptor solo ver√° los elementos emitidos
  despu√©s de haberse suscrito. No hay almacenamiento de valores anteriores.


- `Sinks.many().replay()`: permite m√∫ltiples suscriptores y almacena todos los valores emitidos para reenviarlos a
  cualquier nuevo suscriptor que se conecte posteriormente. Es ideal si queremos garantizar que todos los suscriptores
  reciban todos los valores, sin importar cu√°ndo se conecten.

## Sink Many - Unicast

### Ejemplo 01: Unicast con un √∫nico suscriptor (emisi√≥n previa a la suscripci√≥n)

Este ejemplo demuestra el uso de `Sinks.many().unicast().onBackpressureBuffer()` en `Project Reactor`.

Se trata de un `Sink unicast`, lo que significa que `solo puede haber un √∫nico suscriptor`. A trav√©s del objeto sink,
se emiten varios mensajes manualmente utilizando `tryEmitNext()`, y luego se conecta un subscriber al Flux resultante
(`sink.asFlux()`).

Es importante notar que el `unicast sink` tiene una `cola interna ilimitada` (gracias a `onBackpressureBuffer()`),
lo que le permite almacenar los elementos emitidos hasta que el suscriptor se conecte. Una vez que se suscribe, recibe
todos los elementos en orden.

````java
//Podemos enviar varios mensajes, pero solo habr√° un suscriptor.
public class Lec02SinkUnicast {
    private static final Logger log = LoggerFactory.getLogger(Lec02SinkUnicast.class);

    public static void main(String[] args) {
        demo1();
    }

    private static void demo1() {
        //Manija a trav√©s de la cual empujar√≠amos los elementos
        //onBackPressureBuffer - cola ilimitada
        Sinks.Many<Object> sink = Sinks.many().unicast().onBackpressureBuffer();

        //Manejador a trav√©s del cual los suscriptores recibir√°n elementos
        Flux<Object> flux = sink.asFlux();

        sink.tryEmitNext("Hola");
        sink.tryEmitNext("Buen d√≠a");
        sink.tryEmitNext("¬øC√≥mo est√°s?");

        flux.subscribe(Util.subscriber());
    }
}
````

Los elementos `Hola`, `Buen d√≠a` y `¬øC√≥mo est√°s?` se emiten antes de que el subscriber se conecte.
Gracias al `onBackpressureBuffer()`, los elementos quedan almacenados internamente hasta que el subscriber se suscriba.

Una vez que `flux.subscribe()` es invocado, todos los mensajes acumulados se entregan en orden al suscriptor.

````bash
15:47:49.980 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Hola
15:47:49.982 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Buen d√≠a
15:47:49.982 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: ¬øC√≥mo est√°s?
````

### Ejemplo 02: Error al usar m√∫ltiples suscriptores con un Sink Unicast

Este segundo ejemplo vuelve a utilizar un `Sink unicast`, espec√≠ficamente
`Sinks.many().unicast().onBackpressureBuffer()`, pero esta vez `se intenta suscribir dos veces al mismo Flux`.

Un `sink unicast` est√° dise√±ado para trabajar `exclusivamente con un √∫nico suscriptor`. Si se intenta agregar un segundo
suscriptor, `Reactor` lo considera una violaci√≥n de contrato y lanza una excepci√≥n.

Este tipo de `sink` es √∫til cuando se tiene un √∫nico consumidor responsable de procesar el flujo completo de datos, por
ejemplo en pipelines controlados o flujos internos de una sola direcci√≥n.

````java
public class Lec02SinkUnicast {
    private static final Logger log = LoggerFactory.getLogger(Lec02SinkUnicast.class);

    public static void main(String[] args) {
        demo2();
    }

    // Al unicast no le gustan los suscriptores m√∫ltiples, solo permitir√° un suscriptor
    private static void demo2() {
        Sinks.Many<Object> sink = Sinks.many().unicast().onBackpressureBuffer();
        Flux<Object> flux = sink.asFlux();

        sink.tryEmitNext("Hola");
        sink.tryEmitNext("Buen d√≠a");
        sink.tryEmitNext("¬øC√≥mo est√°s?");

        flux.subscribe(Util.subscriber("sam"));
        flux.subscribe(Util.subscriber("mike"));
    }
}
````

El primer suscriptor, `sam`, se conecta correctamente y recibe todos los elementos emitidos, ya que se almacenaron
internamente hasta su suscripci√≥n (gracias a `onBackpressureBuffer()`).

Cuando se intenta a√±adir un segundo suscriptor, `mike`, el sistema lanza una excepci√≥n con el mensaje:

> `Sinks.many().unicast() sinks only allow a single Subscriber`

Esto ocurre porque `unicast()` no admite m√∫ltiples suscriptores, incluso si uno ya termin√≥ de consumir.

````bash
15:56:25.925 INFO  [           main] d.m.a.common.DefaultSubscriber : sam recibido: Hola
15:56:25.928 INFO  [           main] d.m.a.common.DefaultSubscriber : sam recibido: Buen d√≠a
15:56:25.928 INFO  [           main] d.m.a.common.DefaultSubscriber : sam recibido: ¬øC√≥mo est√°s?
15:56:25.932 ERROR [           main] d.m.a.common.DefaultSubscriber : mike error: Sinks.many().unicast() sinks only allow a single Subscriber
````

## Sink Many - Seguridad en Hilos (Thread Safety)

### Ejemplo 01: Uso inseguro de `tryEmitNext` con m√∫ltiples hilos

En este ejemplo exploramos si un `Sink` tipo `unicast` es seguro para ser usado simult√°neamente desde `m√∫ltiples hilos`.
La pregunta central es: *¬øPodemos compartir el mismo sink entre varios hilos que emiten elementos al mismo tiempo sin
perder datos?*

La respuesta que encontraremos es que `no es seguro para hilos si usamos tryEmitNext(...)` sin sincronizaci√≥n.
Esto lo demostraremos emitiendo desde m√∫ltiples hilos y observando que varios elementos no llegan al flujo.

````java
public class Lec03SinkThreadSafety {
    private static final Logger log = LoggerFactory.getLogger(Lec03SinkThreadSafety.class);

    public static void main(String[] args) {
        demo1();
    }

    // Uso concurrente de tryEmitNext sin sincronizaci√≥n ‚Üí No es seguro para hilos
    private static void demo1() {
        Sinks.Many<Object> sink = Sinks.many().unicast().onBackpressureBuffer();
        Flux<Object> flux = sink.asFlux();

        ArrayList<Object> list = new ArrayList<>();
        flux.subscribe(list::add);

        for (int i = 0; i < 1000; i++) {
            int j = i;
            CompletableFuture.runAsync(() -> {
                sink.tryEmitNext(j); // ‚ùó El tryEmitNext no es seguro si lo usan varios hilos a la vez
            });
        }

        Util.sleepSeconds(2);
        log.info("Tama√±o de lista: {}", list.size());
    }
}
````

Aunque se espera que la lista contenga los `1000` elementos emitidos, el uso concurrente de `tryEmitNext(...)` en un
`sink unicast no es seguro para hilos` sin protecci√≥n, lo que provoca que muchos elementos se pierdan.

Esto ocurre porque `tryEmitNext(...)`:

- No realiza sincronizaci√≥n interna.
- No bloquea ni reintenta si falla.
- Es vulnerable a condiciones de carrera si es llamado por varios hilos a la vez.

Como resultado, el tama√±o final de la lista es mucho menor (en este caso, `113`). Adem√°s, al ejecutar varias veces, el
n√∫mero var√≠a, confirmando la condici√≥n de carrera.

Esto muestra que *no debemos compartir este tipo de sinks sin mecanismos adicionales para asegurar la exclusi√≥n
mutua o evitar condiciones de carrera.*

````bash
16:43:50.248 INFO  [           main] d.m.a.s.Lec03SinkThreadSafety  : Tama√±o de lista: 113
````

### Ejemplo 02: Emisi√≥n segura con `emitNext` y estrategia de reintento

En este ejemplo se demuestra c√≥mo lograr que la emisi√≥n de elementos hacia un sink sea segura para hilos
(`thread-safe`). Se usa `emitNext(...)` en lugar de `tryEmitNext(...)`, y se proporciona una funci√≥n de manejo de
errores que reintenta si ocurre un conflicto de concurrencia (`FAIL_NON_SERIALIZED`).

Gracias a este mecanismo, se garantiza la entrega completa de los `1000` elementos emitidos desde m√∫ltiples hilos
concurrentes.

````java

public class Lec03SinkThreadSafety {
    private static final Logger log = LoggerFactory.getLogger(Lec03SinkThreadSafety.class);

    public static void main(String[] args) {
        demo2();
    }

    private static void demo2() {
        Sinks.Many<Object> sink = Sinks.many().unicast().onBackpressureBuffer();
        Flux<Object> flux = sink.asFlux();

        ArrayList<Object> list = new ArrayList<>();
        flux.subscribe(list::add);

        for (int i = 0; i < 1000; i++) {
            int j = i;
            CompletableFuture.runAsync(() -> {
                sink.emitNext(j, (signalType, emitResult) -> {
                    // Hilo seguro: este manejador permite reintentar en caso de emisi√≥n no serializada (FAIL_NON_SERIALIZED),
                    // lo que garantiza la entrega de los mensajes incluso con m√∫ltiples hilos concurrentes
                    return Sinks.EmitResult.FAIL_NON_SERIALIZED.equals(emitResult);
                });
            });
        }

        Util.sleepSeconds(2);
        log.info("Tama√±o del list: {}", list.size());
    }
}
````

Como resultado, el tama√±o de la lista es el valor esperado 1000.

````bash
16:57:08.764 INFO  [           main] d.m.a.s.Lec03SinkThreadSafety  : Tama√±o del list: 1000
````

## Sink Many - Multicast

### Ejemplo 01: Emisi√≥n Multicast con Suscriptores Simult√°neos y Tard√≠os

Este ejemplo muestra c√≥mo funciona un `Sink.Many` con estrategia `multicast` usando `onBackpressureBuffer()`. Esta
estrategia permite emitir elementos a m√∫ltiples suscriptores de forma simult√°nea, pero con una diferencia importante:
`solo los suscriptores activos en el momento de la emisi√≥n recibir√°n los eventos`. Los suscriptores que se agregan
despu√©s solo recibir√°n los eventos emitidos desde el momento de su suscripci√≥n en adelante.

En el ejemplo, primero se crean dos suscriptores (`sam` y `mike`) que est√°n activos cuando se emiten los primeros dos
mensajes: `Hola` y `Buen d√≠a`. Luego de una pausa, se agrega un tercer suscriptor (`jake`) y se emite un nuevo evento
(`Examen del curso`), que s√≠ es recibido por los tres suscriptores porque en ese momento todos est√°n activos.

````java
public class Lec04Multicast {
    private static final Logger log = LoggerFactory.getLogger(Lec04Multicast.class);

    public static void main(String[] args) {
        demo1();
    }

    private static void demo1() {
        // onBackpressureBuffer - crea una cola limitada para manejar presi√≥n de backpressure
        Sinks.Many<Object> sink = Sinks.many().multicast().onBackpressureBuffer();
        Flux<Object> flux = sink.asFlux();

        // Primeros dos suscriptores
        flux.subscribe(Util.subscriber("sam"));
        flux.subscribe(Util.subscriber("mike"));

        // Se emiten dos eventos
        sink.tryEmitNext("Hola");
        sink.tryEmitNext("Buen d√≠a");

        // Pausa para simular retraso en la suscripci√≥n de "jake"
        Util.sleepSeconds(2);

        // Se agrega un nuevo suscriptor m√°s tarde
        flux.subscribe(Util.subscriber("jake"));

        // Se emite un nuevo evento
        sink.tryEmitNext("Examen del curso");
    }

}
````

Explicaci√≥n del resultado

- `Hola` y `Buen d√≠a` fueron recibidos solo por `sam` y `mike`, ya que `jake` a√∫n no estaba suscrito.
- `Examen del curso` fue recibido por los tres (`sam`, `mike`, y `jake`), porque en ese momento todos estaban suscritos.

````bash
17:19:56.540 INFO  [           main] d.m.a.common.DefaultSubscriber : sam recibido: Hola
17:19:56.540 INFO  [           main] d.m.a.common.DefaultSubscriber : mike recibido: Hola
17:19:56.540 INFO  [           main] d.m.a.common.DefaultSubscriber : sam recibido: Buen d√≠a
17:19:56.540 INFO  [           main] d.m.a.common.DefaultSubscriber : mike recibido: Buen d√≠a
17:19:58.552 INFO  [           main] d.m.a.common.DefaultSubscriber : sam recibido: Examen del curso
17:19:58.552 INFO  [           main] d.m.a.common.DefaultSubscriber : mike recibido: Examen del curso
17:19:58.552 INFO  [           main] d.m.a.common.DefaultSubscriber : jake recibido: Examen del curso
````

> üí° Nota: `multicast()` no reenv√≠a eventos pasados a nuevos suscriptores. Si necesitas ese comportamiento, deber√≠as
> considerar `replay()` en lugar de `multicast()`.

### Ejemplo 02: Emisi√≥n sin suscriptores activos y comportamiento del b√∫fer

Este ejemplo revela un comportamiento muy importante y a menudo inesperado de
`Sinks.many().multicast().onBackpressureBuffer()`:

`Cuando se emiten elementos y no hay ning√∫n suscriptor activo`, los eventos no se pierden inmediatamente. En su lugar,
se almacenan temporalmente en una `cola limitada (buffer)`. Esta cola sirve para entregar esos elementos al primer
suscriptor que se una, una vez que exista uno.

Despu√©s de esto, cualquier otro suscriptor que se una no recibir√° los eventos anteriores, sino solo los nuevos emitidos
desde el momento de su suscripci√≥n.

Este comportamiento es √∫til para escenarios donde un productor emite datos antes de que los consumidores est√©n listos,
pero se debe tener cuidado, ya que `si el buffer se llena, los elementos adicionales ser√°n descartados`.

````java
public class Lec04Multicast {
    private static final Logger log = LoggerFactory.getLogger(Lec04Multicast.class);

    public static void main(String[] args) {
        demo2();
    }

    private static void demo2() {
        Sinks.Many<Object> sink = Sinks.many().multicast().onBackpressureBuffer();
        Flux<Object> flux = sink.asFlux();

        // Emitimos tres eventos sin ning√∫n suscriptor activo
        sink.tryEmitNext("Hola");
        sink.tryEmitNext("Buen d√≠a");
        sink.tryEmitNext("¬øC√≥mo est√°n?");

        // Simulamos retraso antes de suscribir
        Util.sleepSeconds(2);

        // Tres suscriptores se unen despu√©s de los eventos
        flux.subscribe(Util.subscriber("sam"));
        flux.subscribe(Util.subscriber("mike"));
        flux.subscribe(Util.subscriber("jake"));

        // Emitimos un nuevo evento
        sink.tryEmitNext("Examen del curso");
    }
}
````

Explicaci√≥n del resultado

- `sam`, el primer suscriptor, recibe todos los elementos anteriores que estaban almacenados en el buffer (Hola, Buen
  d√≠a, ¬øC√≥mo est√°n?) y tambi√©n el nuevo (Examen del curso).
- `mike` y `jake`, que se suscriben al mismo tiempo que `sam`, solo reciben los elementos emitidos despu√©s de su
  suscripci√≥n, es decir, Examen del curso.

````bash
17:38:14.220 INFO  [           main] d.m.a.common.DefaultSubscriber : sam recibido: Hola
17:38:14.224 INFO  [           main] d.m.a.common.DefaultSubscriber : sam recibido: Buen d√≠a
17:38:14.224 INFO  [           main] d.m.a.common.DefaultSubscriber : sam recibido: ¬øC√≥mo est√°n?
17:38:14.224 INFO  [           main] d.m.a.common.DefaultSubscriber : sam recibido: Examen del curso
17:38:14.224 INFO  [           main] d.m.a.common.DefaultSubscriber : mike recibido: Examen del curso
17:38:14.224 INFO  [           main] d.m.a.common.DefaultSubscriber : jake recibido: Examen del curso
````

> ‚ö†Ô∏è Importante: Este buffer no es un historial permanente, ni se comparte entre todos los suscriptores. Solo el primer
> suscriptor activo despu√©s de una emisi√≥n "sin oyentes" podr√° acceder a los datos almacenados previamente.

> üí° Este patr√≥n puede ser √∫til para algunos escenarios de calentamiento o buffering inicial, pero no garantiza
> confiabilidad para nuevos suscriptores si el objetivo es que todos reciban todos los eventos. En esos casos,
> considera usar `replay()` o `Sinks.replay()`.

## Sink Many - Multicast - directBestEffort

### Ejemplo 01: Problemas al emitir a m√∫ltiples suscriptores con diferentes velocidades

Cuando trabajamos con m√∫ltiples suscriptores, cada uno puede tener una capacidad de procesamiento distinta. En
escenarios reales, no todos los consumidores (suscriptores) procesan los datos a la misma velocidad. Si uno de ellos es
lento, puede afectar la entrega de datos a los dem√°s, incluso si estos √∫ltimos son r√°pidos. Esto puede provocar
problemas de rendimiento o incluso p√©rdida de eventos si el buffer de emisi√≥n se llena.

En este primer ejemplo, veremos c√≥mo se comporta un `Sink` configurado con `multicast().onBackpressureBuffer()`, donde:

- Un suscriptor (`Sam`) procesa r√°pidamente los elementos.
- Otro suscriptor (`Mike`) introduce una demora artificial para simular lentitud.

Se reduce el tama√±o del buffer para forzar un escenario en el que pueda ocurrir desbordamiento (`overflow`), y as√≠
entender el problema que se intenta resolver posteriormente con `directBestEffort`.

````java
public class Lec05MulticastDirectBestEffort {
    private static final Logger log = LoggerFactory.getLogger(Lec05MulticastDirectBestEffort.class);

    public static void main(String[] args) {
        demo1();
        Util.sleepSeconds(25);
    }

    private static void demo1() {
        // Reducimos el tama√±o del buffer para observar f√°cilmente un desbordamiento
        System.setProperty("reactor.bufferSize.small", "16");

        // Sink multicast con manejo de backpressure mediante buffer
        Sinks.Many<Object> sink = Sinks.many().multicast().onBackpressureBuffer();
        Flux<Object> flux = sink.asFlux();

        // Suscriptor r√°pido (sin demoras)
        flux.subscribe(Util.subscriber("sam"));

        // Suscriptor lento (introduce una demora artificial de 200ms entre elementos)
        flux.delayElements(Duration.ofMillis(200)).subscribe(Util.subscriber("mike"));

        // Emitimos 100 elementos al sink
        for (int i = 1; i <= 100; i++) {
            Sinks.EmitResult emitResult = sink.tryEmitNext(i);
            log.info("Item: {}, result: {}", i, emitResult);
        }
    }
}
````

Explicaci√≥n del resultado:

- Los primeros 17 elementos se emiten correctamente (`result: OK`) hasta llenar el buffer.
- A partir del elemento 18, se produce `FAIL_OVERFLOW`, es decir, los eventos no pueden ser emitidos debido a que el
  buffer est√° lleno.
- Esto sucede porque uno de los suscriptores (`Mike`) es m√°s lento, y no puede procesar los eventos al mismo ritmo que
  el emisor y el otro suscriptor (`Sam`).
- El Sink en modo `multicast().onBackpressureBuffer()` requiere que todos los suscriptores est√©n al d√≠a para continuar
  emitiendo de manera efectiva. Un suscriptor lento puede provocar la p√©rdida de eventos si se llena el buffer.

````bash
10:46:57.641 INFO  [           main] d.m.a.common.DefaultSubscriber : sam recibido: 1
10:46:57.649 INFO  [           main] Lec05MulticastDirectBestEffort : Item: 1, result: OK
10:46:57.649 INFO  [           main] Lec05MulticastDirectBestEffort : Item: 2, result: OK
...
10:46:57.649 INFO  [           main] Lec05MulticastDirectBestEffort : Item: 16, result: OK
10:46:57.649 INFO  [           main] Lec05MulticastDirectBestEffort : Item: 17, result: OK
10:46:57.649 INFO  [           main] Lec05MulticastDirectBestEffort : Item: 18, result: FAIL_OVERFLOW
10:46:57.649 INFO  [           main] Lec05MulticastDirectBestEffort : Item: 19, result: FAIL_OVERFLOW
...
10:46:57.649 INFO  [           main] Lec05MulticastDirectBestEffort : Item: 99, result: FAIL_OVERFLOW
10:46:57.649 INFO  [           main] Lec05MulticastDirectBestEffort : Item: 100, result: FAIL_OVERFLOW
10:46:57.865 INFO  [     parallel-1] d.m.a.common.DefaultSubscriber : mike recibido: 1
10:46:57.865 INFO  [     parallel-1] d.m.a.common.DefaultSubscriber : sam recibido: 2
10:46:58.080 INFO  [     parallel-2] d.m.a.common.DefaultSubscriber : mike recibido: 2
...
10:47:00.802 INFO  [     parallel-7] d.m.a.common.DefaultSubscriber : sam recibido: 16
10:47:01.004 INFO  [     parallel-8] d.m.a.common.DefaultSubscriber : mike recibido: 16
10:47:01.004 INFO  [     parallel-8] d.m.a.common.DefaultSubscriber : sam recibido: 17
10:47:01.211 INFO  [     parallel-1] d.m.a.common.DefaultSubscriber : mike recibido: 17
````

### Ejemplo 02: Evitar que un Subscriber lento afecte a los dem√°s

En situaciones donde algunos suscriptores (`subscribers`) procesan los eventos m√°s lentamente que otros, podemos
utilizar el m√©todo `directBestEffort()` para asegurarnos de que el rendimiento de los suscriptores r√°pidos no se vea
afectado.

Este enfoque favorece el env√≠o directo y r√°pido de los elementos a cada suscriptor de forma independiente. Si un
suscriptor no puede seguir el ritmo, simplemente pierde eventos, pero los dem√°s contin√∫an recibi√©ndolos sin
interrupciones.

````java
public class Lec05MulticastDirectBestEffort {
    private static final Logger log = LoggerFactory.getLogger(Lec05MulticastDirectBestEffort.class);

    public static void main(String[] args) {
        demo2();
        Util.sleepSeconds(25);
    }

    private static void demo2() {
        System.setProperty("reactor.bufferSize.small", "16");

        // Usamos directBestEffort para priorizar al subscriber r√°pido
        Sinks.Many<Object> sink = Sinks.many().multicast().directBestEffort();
        Flux<Object> flux = sink.asFlux();

        flux.subscribe(Util.subscriber("sam"));
        flux.delayElements(Duration.ofMillis(200)).subscribe(Util.subscriber("mike"));

        for (int i = 1; i <= 100; i++) {
            Sinks.EmitResult emitResult = sink.tryEmitNext(i);
            log.info("item: {}, result: {}", i, emitResult);
        }
    }
}
````

A continuaci√≥n se muestra parte del resultado de la ejecuci√≥n del c√≥digo. Se puede observar que el suscriptor r√°pido
(`sam`) recibe todos los eventos correctamente. El suscriptor lento (`mike`) apenas ha comenzado a recibir cuando ya
todos los √≠tems han sido emitidos.

````bash
11:02:10.158 INFO  [           main] d.m.a.common.DefaultSubscriber : sam recibido: 1
11:02:10.158 INFO  [           main] Lec05MulticastDirectBestEffort : item: 1, result: OK
11:02:10.158 INFO  [           main] d.m.a.common.DefaultSubscriber : sam recibido: 2
11:02:10.158 INFO  [           main] Lec05MulticastDirectBestEffort : item: 2, result: OK
...
11:02:10.179 INFO  [           main] d.m.a.common.DefaultSubscriber : sam recibido: 98
11:02:10.179 INFO  [           main] Lec05MulticastDirectBestEffort : item: 98, result: OK
11:02:10.179 INFO  [           main] d.m.a.common.DefaultSubscriber : sam recibido: 99
11:02:10.179 INFO  [           main] Lec05MulticastDirectBestEffort : item: 99, result: OK
11:02:10.179 INFO  [           main] d.m.a.common.DefaultSubscriber : sam recibido: 100
11:02:10.179 INFO  [           main] Lec05MulticastDirectBestEffort : item: 100, result: OK
11:02:10.378 INFO  [     parallel-1] d.m.a.common.DefaultSubscriber : mike recibido: 1
````

‚úÖ Conclusi√≥n:
> Gracias a `directBestEffort()`, los suscriptores r√°pidos como `sam` pueden seguir recibiendo datos sin interrupci√≥n,
> mientras que los suscriptores lentos como `mike` pierden eventos si no pueden procesarlos a tiempo. Este enfoque es
> ideal en sistemas donde la prioridad es la velocidad y no la fiabilidad de entrega para todos los consumidores.

### Ejemplo 03: Entrega garantizada combinando directBestEffort y onBackpressureBuffer en m√∫ltiples subscribers

En este ejemplo, queremos lograr que ambos suscriptores, incluso el m√°s lento, reciban todos los elementos emitidos,
sin afectar el rendimiento del suscriptor m√°s r√°pido.

Para ello, usamos `directBestEffort()` (que prioriza entregar los elementos al suscriptor m√°s r√°pido), pero a√±adimos un
`onBackpressureBuffer()` al suscriptor lento. De esta forma, evitamos que se pierdan mensajes por su lentitud.

````java
public class Lec05MulticastDirectBestEffort {
    private static final Logger log = LoggerFactory.getLogger(Lec05MulticastDirectBestEffort.class);

    public static void main(String[] args) {
        demo3();
        Util.sleepSeconds(25);
    }

    private static void demo3() {
        System.setProperty("reactor.bufferSize.small", "16");

        Sinks.Many<Object> sink = Sinks.many().multicast().directBestEffort();
        Flux<Object> flux = sink.asFlux();

        flux.subscribe(Util.subscriber("sam"));
        flux.onBackpressureBuffer().delayElements(Duration.ofMillis(200)).subscribe(Util.subscriber("mike"));

        for (int i = 1; i <= 100; i++) {
            Sinks.EmitResult emitResult = sink.tryEmitNext(i);
            log.info("item: {}, res: {}", i, emitResult);
        }
    }
}
````

Resultado esperado

- Sam (r√°pido) recibe los elementos inmediatamente.
- Mike (lento) recibe todos los elementos, aunque con un retraso de 200ms por elemento.
- El resultado muestra que ning√∫n elemento se pierde, y que ambos suscriptores reciben del 1 al 100.

````bash
11:09:28.830 INFO  [           main] d.m.a.common.DefaultSubscriber : sam recibido: 1
11:09:28.846 INFO  [           main] Lec05MulticastDirectBestEffort : item: 1, res: OK
11:09:28.846 INFO  [           main] d.m.a.common.DefaultSubscriber : sam recibido: 2
11:09:28.846 INFO  [           main] Lec05MulticastDirectBestEffort : item: 2, res: OK
11:09:28.846 INFO  [           main] d.m.a.common.DefaultSubscriber : sam recibido: 3
11:09:28.846 INFO  [           main] Lec05MulticastDirectBestEffort : item: 3, res: OK
11:09:28.846 INFO  [           main] d.m.a.common.DefaultSubscriber : sam recibido: 4
11:09:28.846 INFO  [           main] Lec05MulticastDirectBestEffort : item: 4, res: OK
...
11:09:28.859 INFO  [           main] d.m.a.common.DefaultSubscriber : sam recibido: 99
11:09:28.859 INFO  [           main] Lec05MulticastDirectBestEffort : item: 99, res: OK
11:09:28.859 INFO  [           main] d.m.a.common.DefaultSubscriber : sam recibido: 100
11:09:28.859 INFO  [           main] Lec05MulticastDirectBestEffort : item: 100, res: OK
11:09:29.058 INFO  [     parallel-1] d.m.a.common.DefaultSubscriber : mike recibido: 1
11:09:29.265 INFO  [     parallel-2] d.m.a.common.DefaultSubscriber : mike recibido: 2
11:09:29.471 INFO  [     parallel-3] d.m.a.common.DefaultSubscriber : mike recibido: 3
...
11:09:49.202 INFO  [     parallel-2] d.m.a.common.DefaultSubscriber : mike recibido: 98
11:09:49.421 INFO  [     parallel-3] d.m.a.common.DefaultSubscriber : mike recibido: 99
11:09:49.627 INFO  [     parallel-4] d.m.a.common.DefaultSubscriber : mike recibido: 100
````

‚úÖ Con este patr√≥n, logramos:

- Mantener el rendimiento del suscriptor r√°pido.
- Asegurar la entrega completa de eventos al suscriptor lento.
- Evitar p√©rdidas de datos al utilizar `onBackpressureBuffer()`.
- Este enfoque es √∫til en escenarios en los que algunos consumidores pueden ser lentos, pero no podemos permitirnos
  perder datos en ning√∫n suscriptor.

## Sink Many - Multicast - directAllOrNothing

En el siguiente ejemplo utilizamos `Sinks.many().multicast().directAllOrNothing()`. Este tipo de `Sink` es muy
estricto: si uno de los subscribers no puede recibir el mensaje, el mensaje no se entrega a ninguno y el resultado es
`FAIL_OVERFLOW`.

Detalles clave del c√≥digo:

- Se establece `reactor.bufferSize.small` a 16, lo cual limita el b√∫fer interno y pone en evidencia la presi√≥n de
  backpressure.
- Se crea un `Sink` multicast con estrategia `directAllOrNothing`, que entrega cada mensaje a todos los subscribers o a
  ninguno.
- `sam` se suscribe sin demoras, pero `mike` se suscribe con `delayElements(Duration.ofMillis(200))`, simulando que es
  un subscriber lento.
- En el bucle, se emiten 100 mensajes usando `tryEmitNext()` y se registra el resultado con log.

````java
public class Lec06MulticastDirectAllOrNothing {
    private static final Logger log = LoggerFactory.getLogger(Lec06MulticastDirectAllOrNothing.class);

    public static void main(String[] args) {
        demo1();
        Util.sleepSeconds(10);
    }

    private static void demo1() {
        System.setProperty("reactor.bufferSize.small", "16");

        Sinks.Many<Object> sink = Sinks.many().multicast().directAllOrNothing();
        Flux<Object> flux = sink.asFlux();

        flux.subscribe(Util.subscriber("sam"));
        flux.delayElements(Duration.ofMillis(200)).subscribe(Util.subscriber("mike"));

        for (int i = 1; i <= 100; i++) {
            Sinks.EmitResult emitResult = sink.tryEmitNext(i);
            log.info("item: {}, result: {}", i, emitResult);
        }
    }
}
````

La salida muestra:

- El primer mensaje (1) fue emitido exitosamente: `result: OK`. Esto ocurri√≥ porque ambos subscribers estaban listos en
  ese instante.

- A partir del segundo mensaje (2) en adelante, todos fallan con `FAIL_OVERFLOW`. Esto indica que mike no pudo recibir
  tan r√°pido como sam, y al no estar listo, el sink decide no emitir el mensaje a ninguno.

````bash
11:24:44.806 INFO  [           main] d.m.a.common.DefaultSubscriber : sam recibido: 1
11:24:44.814 INFO  [           main] c06MulticastDirectAllOrNothing : item: 1, result: OK
11:24:44.814 INFO  [           main] c06MulticastDirectAllOrNothing : item: 2, result: FAIL_OVERFLOW
11:24:44.814 INFO  [           main] c06MulticastDirectAllOrNothing : item: 3, result: FAIL_OVERFLOW
11:24:44.814 INFO  [           main] c06MulticastDirectAllOrNothing : item: 4, result: FAIL_OVERFLOW
...
11:24:44.819 INFO  [           main] c06MulticastDirectAllOrNothing : item: 98, result: FAIL_OVERFLOW
11:24:44.819 INFO  [           main] c06MulticastDirectAllOrNothing : item: 99, result: FAIL_OVERFLOW
11:24:44.819 INFO  [           main] c06MulticastDirectAllOrNothing : item: 100, result: FAIL_OVERFLOW
11:24:45.015 INFO  [     parallel-1] d.m.a.common.DefaultSubscriber : mike recibido: 1
````

Este modo `directAllOrNothing` no tolera diferencias de velocidad entre subscribers. Si uno no puede recibir,
se cancela la entrega para todos, garantizando una entrega completamente sincr√≥nica y uniforme.

Ideal en casos donde todos los consumidores deben recibir absolutamente todos los eventos o ninguno.
