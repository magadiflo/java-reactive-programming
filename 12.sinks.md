# Secci√≥n 12: Sinks

---

## Introducci√≥n

Hasta ahora, hemos aprendido a crear `publishers` utilizando varias formas est√°ndar que proporciona `Reactor`, como:

- `Mono.fromSupplier(...)`
- `Flux.range(...)`
- `Flux.generate(...)`
- `Flux.create(...)`
- `Flux.interval(...)`
- ...

Todas estas formas de creaci√≥n funcionan √∫nicamente cuando hay un `suscriptor` que consume los datos. Es decir, no se
emite nada hasta que alguien se suscriba.

Durante este curso, nos hemos enfocado principalmente en construir `pipelines reactivos` usando diferentes operadores.
Sin embargo, todav√≠a nos falta cubrir un aspecto importante: `la capacidad de emitir datos de manera manual`.

Cuando decimos `emitir manualmente`, nos referimos a poder enviar elementos:

- En cualquier momento.
- Si depender de bucles, rangos o intervalos.
- Sin necesidad inmediata de un suscriptor,
- Con la posibilidad de interactuar con m√∫ltiples hilos si lo deseamos.

Aqu√≠ es donde entran en escena los `Sinks`.

![01.png](assets/section-12/01.png)

Los `Sinks` en `Reactor` pueden actuar tanto como `productores` como `consumidores` de datos. Esto significa que se
pueden utilizar para recibir datos (como un `Subscriber`) y tambi√©n para emitirlos (como un `Publisher`).

Una vez creado un `Sink`, podemos:

- Usarlo para `emitir datos desde un hilo o clase`.
- Permitir que `otro hilo o clase reciba esos datos` mediante suscripci√≥n.

Esto resulta √∫til, por ejemplo, cuando necesitamos comunicar diferentes partes de nuestra aplicaci√≥n de forma as√≠ncrona
y desacoplada.

Adem√°s, los `Sinks` funcionan como puntos de integraci√≥n ideales. En un enfoque tradicional, una clase suele invocar
directamente los m√©todos de otra para realizar alguna acci√≥n, como:

- Enviar una notificaci√≥n por correo electr√≥nico,
- Enviar un SMS,
- Registrar una auditor√≠a, etc.

![02.png](assets/section-12/02.png)

Con `Sinks`, podemos cambiar este enfoque. En lugar de depender de llamadas directas entre clases, una clase simplemente
emite un evento a trav√©s del `Sink`, y otras clases que est√©n suscritas a ese flujo podr√°n reaccionar autom√°ticamente,
sin necesidad de acoplamiento directo.

Este patr√≥n favorece un dise√±o m√°s reactivo y desacoplado.

![03.png](assets/section-12/03.png)

### Ejemplo del mundo real

Imagina un sistema de alarma en una casa inteligente. Cuando se detecta movimiento en una zona restringida, el sensor
no necesita saber qui√©n debe reaccionar. Simplemente, `emite una se√±al` (evento) a trav√©s de un canal com√∫n.

Esa se√±al puede ser recibida por distintos sistemas al mismo tiempo:

- Uno activa la sirena,
- Otro env√≠a una notificaci√≥n al celular del due√±o,
- Otro graba el video desde las c√°maras de seguridad.

Cada uno de estos sistemas est√° suscrito a ese evento. As√≠ funcionan los `Sinks`: permiten que una parte del sistema
emita datos, y que otras reaccionen sin estar acopladas directamente entre s√≠.

## Sink One - TryEmit

Un Sink One (`Sinks.One<T>`) es un tipo de `Sink` dise√±ado para emitir un √∫nico valor (o bien una se√±al de `vac√≠o`
o `error`). Este tipo de `sink` se comporta como un `Mono`, por lo que puede ser transformado en un `Mono` al que uno
o m√°s `suscriptores` pueden reaccionar.

### Ejemplo 01: Explorando `Sinks.one()` para emitir un valor, vac√≠o o error

Cuando usamos `Sinks.one()`, estamos creando un sink que puede emitir `como m√°ximo un solo elemento`, o
alternativamente puede completar sin emitir (`empty`) o terminar con un error (`error`).

````java
public class Lec01SinkOne {
    public static void main(String[] args) {
        demo1();
    }

    private static void demo1() {
        Sinks.One<Object> sink = Sinks.one();
        Mono<Object> mono = sink.asMono();
        mono.subscribe(Util.subscriber());

        sink.tryEmitValue("Hola");
//        sink.tryEmitEmpty();
//        sink.tryEmitError(new RuntimeException("Error cuando se usaba sink"));
    }
}
````

En este ejemplo:

- Se crea un `Sink` y se convierte a un `Mono` usando `asMono()`.
- Luego, nos suscribimos al Mono.
- Finalmente, emitimos un valor con `tryEmitValue("Hola")`.

¬øQu√© sucede al emitir?

- Si usamos `sink.tryEmitValue("Hola")`, el suscriptor recibe ese valor y ejecuta `onNext`, seguido de `onComplete`.
- Si usamos `sink.tryEmitEmpty()`, el suscriptor ejecuta √∫nicamente `onComplete`.
- Si usamos `sink.tryEmitError(...)`, el suscriptor ejecuta `onError`, recibiendo la excepci√≥n especificada.

````bash
11:20:19.858 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Hola
11:20:19.863 INFO  [           main] d.m.a.common.DefaultSubscriber :  ¬°completado!
````

Este comportamiento es ideal cuando queremos tener un control total sobre cu√°ndo y qu√© emitir, con la posibilidad de
emitir desde una clase o hilo diferente, sin depender de generadores o flujos autom√°ticos.

### Ejemplo 02: M√∫ltiples suscriptores para un mismo `Sink`

En este ejemplo, creamos `dos suscriptores` que se suscriben al `Mono` derivado del `Sink`. Luego emitimos un valor, y
ambos suscriptores reciben ese mismo valor.

````java
public class Lec01SinkOne {
    public static void main(String[] args) {
        demo2();
    }

    private static void demo2() {
        Sinks.One<Object> sink = Sinks.one();
        Mono<Object> mono = sink.asMono();
        mono.subscribe(Util.subscriber("sam"));
        mono.subscribe(Util.subscriber("mike"));

        sink.tryEmitValue("Hola");
    }
}
````

Como resultado, ambos suscriptores reciben el mensaje `Hola` y finalizan con `onComplete`.

````bash
11:25:33.004 INFO  [           main] d.m.a.common.DefaultSubscriber : sam recibido: Hola
11:25:33.009 INFO  [           main] d.m.a.common.DefaultSubscriber : sam ¬°completado!
11:25:33.010 INFO  [           main] d.m.a.common.DefaultSubscriber : mike recibido: Hola
11:25:33.010 INFO  [           main] d.m.a.common.DefaultSubscriber : mike ¬°completado!
````

> üí°`Importante`: Aunque el `Sink.One` solo puede emitir un √∫nico valor o se√±al (`empty` o `error`), puede tener
> m√∫ltiples suscriptores, y todos ellos recibir√°n la misma se√±al (`valor` o `evento`) si se suscriben antes de la
> emisi√≥n.

### Diferencia entre `Mono.just(...)` y `sink.asMono()`

Ambos pueden emitir un solo valor, y ambos permiten m√∫ltiples suscriptores, pero su comportamiento en cuanto al momento
de la emisi√≥n y la naturaleza del publisher es distinto. Aqu√≠ est√° el detalle:

### üü† Mono.just(...) y Flux.just(...)

Estos son `cold publishers` (publicadores fr√≠os).

- Cada vez que alguien se suscribe, `se vuelve a emitir` el valor (se "reproduce" la se√±al desde cero).
- Es decir, `cada suscriptor recibe su propia emisi√≥n independiente`.
- No comparten los datos entre suscriptores. Es como una funci√≥n que se ejecuta cada vez que se llama.

### üü¢ sink.asMono() (a partir de Sinks.one())

Este es un `hot publisher` (publicador caliente).

- El valor `se emite una √∫nica vez`, cuando se llama a `sink.tryEmitValue(...)`.
- Todos los suscriptores `que ya estaban suscritos antes` de esa emisi√≥n `reciben ese mismo valor`.
- Pero si alguien se suscribe `despu√©s` de que se haya emitido,
  `tambi√©n lo recibe, siempre y cuando no haya expirado (completado)`.
- El valor `ya est√° "almacenado" internamente en el sink`, como si fuera un `buffer` que entrega a todos los que se
  suscriben.

> üí° Pero aqu√≠ la diferencia es que la emisi√≥n ocurre una sola vez con `tryEmitValue("Hola")`, y todos los suscriptores
> acceden al mismo valor ya emitido. No es que el sink vuelva a emitir como lo har√≠a un `Mono.just`.

### üí° Pero `Sinks.one()` `NO es un hot publisher tradicional`

Es un `caso especial`: es un hot publisher con memoria de un solo valor.

- `S√≠ es caliente` porque la emisi√≥n ocurre independientemente de las suscripciones.
- Pero guarda ese valor y se lo da a los suscriptores incluso si llegan despu√©s de la emisi√≥n (siempre que a√∫n no se
  haya completado el Mono).
- `sink.asMono()` act√∫a como un Mono con valor ya disponible: todos los que se suscriban despu√©s de la emisi√≥n a√∫n lo
  reciben, hasta que el `Mono` haya sido recolectado.
- En el caso de `Sinks.one().asMono()`, estamos ante un hot publisher con `buffer de 1`, por eso los suscriptores
  posteriores a√∫n ven ese valor √∫nico emitido, si no se ha recolectado a√∫n.
- En Reactor, hay varios de estos comportamientos h√≠bridos, y Sinks.one() es uno de los m√°s √∫tiles para emitir un valor
  manualmente y garantizar que todos los interesados (antes o despu√©s) lo reciban una sola vez.

### üìå Conclusi√≥n

No funcionan igual, aunque a veces el resultado pueda parecerse (todos reciben el mismo valor). Lo importante es cu√°ndo
y c√≥mo se emite el dato:

- `Mono.just(...)` lo emite cada vez que alguien se suscribe.
- `sink.asMono()` lo emite una vez, y todos los que se suscriban (antes o despu√©s) reciben esa misma emisi√≥n √∫nica.

## Sink One - `emitValue(...)` y `EmitFailureHandler`

Cuando usamos `Sinks.one()`, sabemos que solo se puede emitir un `valor`, o bien una se√±al `vac√≠a` o una se√±al de
`error`. Si intentamos emitir m√°s de una vez, el `Sink` rechazar√° esos intentos posteriores.

El m√©todo `tryEmitValue(...)` devuelve un `Sinks.EmitResult`, que indica si el intento fue exitoso (`OK`) o
fallido (`FAIL_TERMINATED`, entre otros). Este valor se puede capturar para decidir qu√© hacer, pero si no se captura,
el fallo pasa desapercibido silenciosamente.

Por otro lado, podemos usar `emitValue(...)`, que adem√°s de intentar emitir, acepta una funci√≥n de tipo
`EmitFailureHandler`, permiti√©ndonos manejar activamente esos fallos y, si lo deseamos, reintentar la emisi√≥n.

Esta interfaz tiene un m√©todo funcional que acepta:

- `SignalType`: el tipo de se√±al que se intent√≥ emitir (por ejemplo, `ON_NEXT`, `ON_COMPLETE`, etc.),
- `EmitResult`: el resultado del intento de emisi√≥n (por ejemplo, `FAIL_TERMINATED`, `FAIL_NON_SERIALIZED`, etc.).

Esto nos da la oportunidad de decidir si queremos reintentar la emisi√≥n devolviendo `true`, o no, devolviendo `false`.

### üß† ¬øPor qu√© usar emitValue(...)?

Porque te da m√°s control para manejar fallos de emisi√≥n (como cuando ya se ha completado el `sink`), y te permite
agregar l√≥gica de reintento personalizada si es necesario.

````java
public class Lec01SinkOne {
    private static final Logger log = LoggerFactory.getLogger(Lec01SinkOne.class);

    public static void main(String[] args) {
        demo3();
    }

    private static void demo3() {
        Sinks.One<Object> sink = Sinks.one();
        Mono<Object> mono = sink.asMono();

        mono.subscribe(Util.subscriber());

        sink.emitValue("Hola", (signalType, emitResult) -> {
            log.info("Hola");
            log.info(signalType.name());
            log.info(emitResult.name());

            return false; // no intentamos reemitir si falla
        });

        sink.emitValue("Buenas", (signalType, emitResult) -> {
            log.info("Buenas");
            log.info(signalType.name());
            log.info(emitResult.name());

            return false; // tampoco reintentamos aqu√≠
        });
    }
}
````

Explicaci√≥n del resultado:

- La primera llamada a `emitValue("Hola")` es exitosa. El `Subscriber` recibe el valor y se completa.
- La segunda llamada a `emitValue("Buenas")` falla, porque el `Sink` ya est√° terminado (solo permite una emisi√≥n). El
  manejador (`EmitFailureHandler`) se ejecuta e imprime.
- El `EmitResult.FAIL_TERMINATED` significa que el `sink` ya fue completado o cerrado, por lo que no se puede volver a
  emitir nada.

````bash
12:32:05.675 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Hola
12:32:05.681 INFO  [           main] d.m.a.common.DefaultSubscriber :  ¬°completado!
12:32:05.681 INFO  [           main] d.m.app.sec12.Lec01SinkOne     : Buenas
12:32:05.681 INFO  [           main] d.m.app.sec12.Lec01SinkOne     : ON_NEXT
12:32:05.681 INFO  [           main] d.m.app.sec12.Lec01SinkOne     : FAIL_TERMINATED
````

## Sink Types

Anteriormente, vimos el uso de `Sinks.one()`, que nos permite emitir un solo `valor` (o una se√±al `vac√≠a` o de `error`)
y permite m√∫ltiples suscriptores. Este tipo de `Sink` se traduce en un `Mono`, que es adecuado para emisiones √∫nicas.

Sin embargo, en situaciones donde necesitamos emitir m√∫ltiples elementos, `Reactor` proporciona otros tipos de `Sinks`
que se ajustan a distintos casos de uso. Elegir el tipo de `Sink` adecuado depender√° de c√≥mo queremos manejar las
emisiones y los suscriptores.

A continuaci√≥n se presenta una tabla con los principales tipos de `Sink` que ofrece `Reactor`:

| Sink Type            | Publisher Type | # de Subscribers | Comportamiento                                                                                        |
|----------------------|----------------|------------------|-------------------------------------------------------------------------------------------------------|
| `one`                | Mono           | N                | Emite solo un valor (o vac√≠o/error). Todos los suscriptores reciben la misma se√±al.                   |
| `many().unicast()`   | Flux           | 1                | Solo permite un suscriptor. Almacena en memoria los mensajes hasta que ese suscriptor se conecte.     |
| `many().multicast()` | Flux           | N                | Emite a m√∫ltiples suscriptores, pero solo recibir√°n los elementos emitidos despu√©s de su suscripci√≥n. |
| `many().replay()`    | Flux           | N                | Emite a m√∫ltiples suscriptores y reenv√≠a todos los valores pasados a los nuevos suscriptores.         |

### Descripci√≥n de cada tipo

- `Sinks.one()`: permite emitir un √∫nico valor. Despu√©s de emitir, el Sink se completa y no se puede volver a utilizar.
  Es √∫til cuando queremos notificar un solo evento o resultado.


- `Sinks.many().unicast()`: permite emitir m√∫ltiples elementos, pero solo acepta un suscriptor. Si el suscriptor a√∫n no
  est√° presente, los valores se almacenan en un buffer interno hasta que se suscriba.


- `Sinks.many().multicast()`: permite m√∫ltiples suscriptores, pero cada suscriptor solo ver√° los elementos emitidos
  despu√©s de haberse suscrito. No hay almacenamiento de valores anteriores.


- `Sinks.many().replay()`: permite m√∫ltiples suscriptores y almacena todos los valores emitidos para reenviarlos a
  cualquier nuevo suscriptor que se conecte posteriormente. Es ideal si queremos garantizar que todos los suscriptores
  reciban todos los valores, sin importar cu√°ndo se conecten.

