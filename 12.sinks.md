# Sección 12: Sinks

---

## Introducción

Hasta ahora, hemos aprendido a crear `publishers` utilizando varias formas estándar que proporciona `Reactor`, como:

- `Mono.fromSupplier(...)`
- `Flux.range(...)`
- `Flux.generate(...)`
- `Flux.create(...)`
- `Flux.interval(...)`
- ...

Todas estas formas de creación funcionan únicamente cuando hay un `suscriptor` que consume los datos. Es decir, no se
emite nada hasta que alguien se suscriba.

Durante este curso, nos hemos enfocado principalmente en construir `pipelines reactivos` usando diferentes operadores.
Sin embargo, todavía nos falta cubrir un aspecto importante: `la capacidad de emitir datos de manera manual`.

Cuando decimos `emitir manualmente`, nos referimos a poder enviar elementos:

- En cualquier momento.
- Si depender de bucles, rangos o intervalos.
- Sin necesidad inmediata de un suscriptor,
- Con la posibilidad de interactuar con múltiples hilos si lo deseamos.

Aquí es donde entran en escena los `Sinks`.

![01.png](assets/section-12/01.png)

Los `Sinks` en `Reactor` pueden actuar tanto como `productores` como `consumidores` de datos. Esto significa que se
pueden utilizar para recibir datos (como un `Subscriber`) y también para emitirlos (como un `Publisher`).

Una vez creado un `Sink`, podemos:

- Usarlo para `emitir datos desde un hilo o clase`.
- Permitir que `otro hilo o clase reciba esos datos` mediante suscripción.

Esto resulta útil, por ejemplo, cuando necesitamos comunicar diferentes partes de nuestra aplicación de forma asíncrona
y desacoplada.

Además, los `Sinks` funcionan como puntos de integración ideales. En un enfoque tradicional, una clase suele invocar
directamente los métodos de otra para realizar alguna acción, como:

- Enviar una notificación por correo electrónico,
- Enviar un SMS,
- Registrar una auditoría, etc.

![02.png](assets/section-12/02.png)

Con `Sinks`, podemos cambiar este enfoque. En lugar de depender de llamadas directas entre clases, una clase simplemente
emite un evento a través del `Sink`, y otras clases que estén suscritas a ese flujo podrán reaccionar automáticamente,
sin necesidad de acoplamiento directo.

Este patrón favorece un diseño más reactivo y desacoplado.

![03.png](assets/section-12/03.png)

### Ejemplo del mundo real

Imagina un sistema de alarma en una casa inteligente. Cuando se detecta movimiento en una zona restringida, el sensor
no necesita saber quién debe reaccionar. Simplemente, `emite una señal` (evento) a través de un canal común.

Esa señal puede ser recibida por distintos sistemas al mismo tiempo:

- Uno activa la sirena,
- Otro envía una notificación al celular del dueño,
- Otro graba el video desde las cámaras de seguridad.

Cada uno de estos sistemas está suscrito a ese evento. Así funcionan los `Sinks`: permiten que una parte del sistema
emita datos, y que otras reaccionen sin estar acopladas directamente entre sí.
