# Secci√≥n 12: Sinks

---

## Introducci√≥n

Hasta ahora, hemos aprendido a crear `publishers` utilizando varias formas est√°ndar que proporciona `Reactor`, como:

- `Mono.fromSupplier(...)`
- `Flux.range(...)`
- `Flux.generate(...)`
- `Flux.create(...)`
- `Flux.interval(...)`
- ...

Todas estas formas de creaci√≥n funcionan √∫nicamente cuando hay un `suscriptor` que consume los datos. Es decir, no se
emite nada hasta que alguien se suscriba.

Durante este curso, nos hemos enfocado principalmente en construir `pipelines reactivos` usando diferentes operadores.
Sin embargo, todav√≠a nos falta cubrir un aspecto importante: `la capacidad de emitir datos de manera manual`.

Cuando decimos `emitir manualmente`, nos referimos a poder enviar elementos:

- En cualquier momento.
- Si depender de bucles, rangos o intervalos.
- Sin necesidad inmediata de un suscriptor,
- Con la posibilidad de interactuar con m√∫ltiples hilos si lo deseamos.

Aqu√≠ es donde entran en escena los `Sinks`.

![01.png](assets/section-12/01.png)

Los `Sinks` en `Reactor` pueden actuar tanto como `productores` como `consumidores` de datos. Esto significa que se
pueden utilizar para recibir datos (como un `Subscriber`) y tambi√©n para emitirlos (como un `Publisher`).

Una vez creado un `Sink`, podemos:

- Usarlo para `emitir datos desde un hilo o clase`.
- Permitir que `otro hilo o clase reciba esos datos` mediante suscripci√≥n.

Esto resulta √∫til, por ejemplo, cuando necesitamos comunicar diferentes partes de nuestra aplicaci√≥n de forma as√≠ncrona
y desacoplada.

Adem√°s, los `Sinks` funcionan como puntos de integraci√≥n ideales. En un enfoque tradicional, una clase suele invocar
directamente los m√©todos de otra para realizar alguna acci√≥n, como:

- Enviar una notificaci√≥n por correo electr√≥nico,
- Enviar un SMS,
- Registrar una auditor√≠a, etc.

![02.png](assets/section-12/02.png)

Con `Sinks`, podemos cambiar este enfoque. En lugar de depender de llamadas directas entre clases, una clase simplemente
emite un evento a trav√©s del `Sink`, y otras clases que est√©n suscritas a ese flujo podr√°n reaccionar autom√°ticamente,
sin necesidad de acoplamiento directo.

Este patr√≥n favorece un dise√±o m√°s reactivo y desacoplado.

![03.png](assets/section-12/03.png)

### Ejemplo del mundo real

Imagina un sistema de alarma en una casa inteligente. Cuando se detecta movimiento en una zona restringida, el sensor
no necesita saber qui√©n debe reaccionar. Simplemente, `emite una se√±al` (evento) a trav√©s de un canal com√∫n.

Esa se√±al puede ser recibida por distintos sistemas al mismo tiempo:

- Uno activa la sirena,
- Otro env√≠a una notificaci√≥n al celular del due√±o,
- Otro graba el video desde las c√°maras de seguridad.

Cada uno de estos sistemas est√° suscrito a ese evento. As√≠ funcionan los `Sinks`: permiten que una parte del sistema
emita datos, y que otras reaccionen sin estar acopladas directamente entre s√≠.

## Sink One - TryEmit

Un Sink One (`Sinks.One<T>`) es un tipo de `Sink` dise√±ado para emitir un √∫nico valor (o bien una se√±al de `vac√≠o`
o `error`). Este tipo de `sink` se comporta como un `Mono`, por lo que puede ser transformado en un `Mono` al que uno
o m√°s `suscriptores` pueden reaccionar.

### Ejemplo 01: Explorando `Sinks.one()` para emitir un valor, vac√≠o o error

Cuando usamos `Sinks.one()`, estamos creando un sink que puede emitir `como m√°ximo un solo elemento`, o
alternativamente puede completar sin emitir (`empty`) o terminar con un error (`error`).

````java
public class Lec01SinkOne {
    public static void main(String[] args) {
        demo1();
    }

    private static void demo1() {
        Sinks.One<Object> sink = Sinks.one();
        Mono<Object> mono = sink.asMono();
        mono.subscribe(Util.subscriber());

        sink.tryEmitValue("Hola");
//        sink.tryEmitEmpty();
//        sink.tryEmitError(new RuntimeException("Error cuando se usaba sink"));
    }
}
````

En este ejemplo:

- Se crea un `Sink` y se convierte a un `Mono` usando `asMono()`.
- Luego, nos suscribimos al Mono.
- Finalmente, emitimos un valor con `tryEmitValue("Hola")`.

¬øQu√© sucede al emitir?

- Si usamos `sink.tryEmitValue("Hola")`, el suscriptor recibe ese valor y ejecuta `onNext`, seguido de `onComplete`.
- Si usamos `sink.tryEmitEmpty()`, el suscriptor ejecuta √∫nicamente `onComplete`.
- Si usamos `sink.tryEmitError(...)`, el suscriptor ejecuta `onError`, recibiendo la excepci√≥n especificada.

````bash
11:20:19.858 INFO  [           main] d.m.a.common.DefaultSubscriber :  recibido: Hola
11:20:19.863 INFO  [           main] d.m.a.common.DefaultSubscriber :  ¬°completado!
````

Este comportamiento es ideal cuando queremos tener un control total sobre cu√°ndo y qu√© emitir, con la posibilidad de
emitir desde una clase o hilo diferente, sin depender de generadores o flujos autom√°ticos.

### Ejemplo 02: M√∫ltiples suscriptores para un mismo `Sink`

En este ejemplo, creamos `dos suscriptores` que se suscriben al `Mono` derivado del `Sink`. Luego emitimos un valor, y
ambos suscriptores reciben ese mismo valor.

````java
public class Lec01SinkOne {
    public static void main(String[] args) {
        demo2();
    }

    private static void demo2() {
        Sinks.One<Object> sink = Sinks.one();
        Mono<Object> mono = sink.asMono();
        mono.subscribe(Util.subscriber("sam"));
        mono.subscribe(Util.subscriber("mike"));

        sink.tryEmitValue("Hola");
    }
}
````

Como resultado, ambos suscriptores reciben el mensaje `Hola` y finalizan con `onComplete`.

````bash
11:25:33.004 INFO  [           main] d.m.a.common.DefaultSubscriber : sam recibido: Hola
11:25:33.009 INFO  [           main] d.m.a.common.DefaultSubscriber : sam ¬°completado!
11:25:33.010 INFO  [           main] d.m.a.common.DefaultSubscriber : mike recibido: Hola
11:25:33.010 INFO  [           main] d.m.a.common.DefaultSubscriber : mike ¬°completado!
````

> üí°`Importante`: Aunque el `Sink.One` solo puede emitir un √∫nico valor o se√±al (`empty` o `error`), puede tener
> m√∫ltiples suscriptores, y todos ellos recibir√°n la misma se√±al (`valor` o `evento`) si se suscriben antes de la
> emisi√≥n.
